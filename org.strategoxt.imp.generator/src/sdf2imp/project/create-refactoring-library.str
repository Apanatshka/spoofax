module sdf2imp/project/create-refactoring-library

imports
  sdf2imp/util/-

strategies

create-behavior-preservation =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "behavior-preservation.generated.str")>
${/** 
* This module contains functions to detect name collisions and semantic constraint errors 
* caused by the (refactoring) transformation.
*/
module lib-refactoring/behavior-preservation.generated

imports
  lib/editor-common.generated
  lib-refactoring/analysis-multifile.generated
  lib-refactoring/namebinding-preservation.generated
  lib-refactoring/correctness-preservation.generated
  lib-refactoring/binding-violations.generated

strategies

  /**
   * Returns behavior preservation errors and warnings by analyzing changes in the static semantics of
   * the ASTs before- and after- the transformation. The analysis covers:
   * - name binding violation errors
   * - semantic-constraint errors and warnings
   * 
   * This rule applies to a tuple consisting of a list of ASTs before the refactoring transformation and 
   * a list of ASTs after the transformation. 
   * All ASTs that are possible (semantically or structurally) affected by the transformation must be included in both lists.
   * - The ASTs before the transformation contain name binding annotations set by 
   *   @see analyze-top(|language) or @see analyze-top-multifile(|language, project-path).
   * - the ASTs after the transformation contain name binding annotations that express the EXPECTED binding structure
   *   (typically obtained by preserving annos during transformation and setting annos for new inserted definitions and their use sites) 
   * - The ASTs after the transformation are later (re)analyzed by @see analyze-asts-multifile 
   *
   * Remark: performance can be improved in case the endangered names are known
   * @see semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name) 
   *   or semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name)
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   */
  semantic-violation-errors(constraint-error, constraint-warning):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      (errors, warnings) := <semantic-violation-errors(constraint-error, constraint-warning, id)>

  /**
   * @see semantic-violation-errors(constraint-error, constraint-warning)
   * Improves the performance of name binding checks by only considering endangered names.
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   * @param endangered-names  List(String)
   */
  semantic-violation-errors(constraint-error, constraint-warning|endangered-names):
    (asts-before-analyzed, asts-after) -> <semantic-violation-errors(constraint-error, constraint-warning, is-in-list(|endangered-names'))>
    where
      endangered-names' := <map(strip-annos)> endangered-names
        
  /**
   * @see semantic-violation-errors(constraint-error, constraint-warning)
   * Improves the performance of name binding checks by only considering endangered names.
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   * @param is-endangered-name  String -> String
   */
  semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      (errors, warnings) := 
        <semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name, multifile-analyze-asts)>

  /**
   * @see semantic-violation-errors(constraint-error, constraint-warning)
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   * @param is-endangered-name  String -> String
   * @param analyze-multifile   List(ast) -> List(ast) stores semantic info in ASTs and name index
   */
  semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name, analyze-multifile):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      //errors and warnings on analyzed asts before the transformation
      errors-before   := <mapconcat(collect-all(constraint-error, conc))> asts-before-analyzed; 
      warnings-before := <mapconcat(collect-all(constraint-warning, conc))> asts-before-analyzed; 
      
      //errors and warnings on (re)analyzed asts after the transformation
      asts-after-analyzed := <analyze-multifile> asts-after;      
      errors-after   := <mapconcat(collect-all(constraint-error, conc))> asts-after-analyzed;
      warnings-after := <mapconcat(collect-all(constraint-warning, conc))> asts-after-analyzed;
      
      //errors and warnings by comparing the ASTs before- and after- the transformation      
      warnings := <compare-constraint-issues> (warnings-before, warnings-after);
      correctness-preservation-errors := <compare-constraint-issues> (errors-before, errors-after);
      namebinding-preservation-errors := <name-binding-violation-errors-on-trees(is-endangered-name)> (asts-after, asts-after-analyzed); 
      errors := <union(is-same-error-term)> (namebinding-preservation-errors, correctness-preservation-errors)

  //checks if semantic violations are reported for the same term.
  //prevents warnings about name binding violation errors that are also duplicate definition errors. 
  //@internal
  is-same-error-term:
    err-tup@((t1,_), (t2,_)) -> err-tup
    where
      <origin-equal(|t1)> t2 <+
      <origin-equal(|t2)> t1
  
  //backwards-compatibility
  get-semantic-violations(constraint-error, constraint-warning, is-endangered-name):
    ast-changes -> <semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name)> <unzip> ast-changes
}

create-namebinding-preservation =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "namebinding-preservation.generated.str")>
"/** 
* This module contains functions to detect name binding violations 
* caused by the (refactoring) transformation.
* REMARK: Only use this module in case semantic correctness preservation is not checked.
* Otherwise, use behavior-preservation.generated.str
*/
module lib-refactoring/namebinding-preservation.generated

imports
  lib-refactoring/analysis-multifile.generated
  lib/index-library.generated
  lib-refactoring/binding-violations.generated

strategies

  /**
   * Returns name collision errors by comparing the expected binding structure with the actual binding structure
   * in the ASTs after the transformation.
   * The ASTs after the transformation (asts-expected-bindings) contain name binding annotations that express the EXPECTED binding structure
   * (typically obtained by preserving annos during transformation and setting annos for new inserted definitions) 
   * The ASTs are later (re)analyzed by @see multifile-analyze-asts 
   *
   * @type  t -> List(errors)
   */
  name-binding-violation-errors:
    asts-expected-bindings -> <name-binding-violation-errors(id)>

  /**
   * @see name-binding-violation-errors
   * Improves the performance of name binding checks by only considering endangered names.
   *
   * @type  t -> List(errors)
   * @param endangered-names  List(String)
   */
  name-binding-violation-errors(|endangered-names):
    asts-expected-bindings -> <name-binding-violation-errors(is-in-list(|endangered-names'), multifile-analyze-asts)>
    where
      endangered-names' := <map(strip-annos)> endangered-names

  /**
   * @see name-binding-violation-errors
   * Improves the performance of name binding checks by only considering endangered names.
   *
   * @type  t -> List(errors)
   * @param is-endangered-name  String -> String
   */
  name-binding-violation-errors(is-endangered-name):
    asts-expected-bindings -> <name-binding-violation-errors(is-endangered-name, multifile-analyze-asts)>

  /**
   * @see name-binding-violation-errors(is-endangered-name)
   *
   * @param analyze-multifile sets the correct name annotations 
   * and preserves the structure of the ASTs.
   *
   * @type  t -> List(errors)
   * @param is-endangered-name  String -> String
   * @param analyze-multifile   List(ast) -> List(ast) stores semantic info in ASTs and name index
   */
  name-binding-violation-errors(is-endangered-name, analyze-multifile):
    asts-expected-bindings -> binding-violation-errors
    where
      asts-actual-bindings := <analyze-multifile> asts-expected-bindings;
      binding-violation-errors := 
        <name-binding-violation-errors-on-trees(is-endangered-name)> (asts-expected-bindings, asts-actual-bindings)

  /**
   * Returns name collision errors by comparing the expected binding structure with the actual binding structure.
   *
   * @type  (t,t) -> List(errors)
   */
  name-binding-violation-errors-on-trees(is-endangered-name):
    (asts-expected-bindings, asts-actual-bindings)  -> binding-violation-errors
    where
      binding-violation-errors := <
        binding-violation-terms(is-endangered-name);
        filter(not(?_{[Unresolved(_)|_], [Unresolved(_)|_]}));
        map(to-namebinding-error)
      > (asts-expected-bindings, asts-actual-bindings)

  is-broken-binding =
    ?_{nb1, [Unresolved(_)|_]};
    where(<not(?[Unresolved(_)|_])> nb1) 
  
rules //report name binding violation to end user

  to-namebinding-error =
    to-namebinding-error-broken <+
    to-namebinding-error-created <+
    to-namebinding-error-changed
  
  to-namebinding-error-broken:
    <is-broken-binding> -> (<strip-annos>, $[Variable becomes unbound '[<strip-annos>]'])
  
  to-namebinding-error-created:
    <is-created-binding> -> (<strip-annos>, $[Unbound variabele becomes bound '[<strip-annos>]'])

  to-namebinding-error-changed:
    t{nb1, nb2} -> (<strip-annos>, $[Name collision with name '[<strip-annos>]'])"


create-correctness-preservation =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "correctness-preservation.generated.str")>
${/** 
* This module contains functions to detect semantic constraint errors 
* caused by the (refactoring) transformation.
* REMARK: Only use this module in case name binding preservations are not checked.
* Otherwise, use behavior-preservation.generated.str
*/
module lib-refactoring/correctness-preservation.generated 

imports
  lib-refactoring/analysis-multifile.generated
  lib/editor-common.generated

strategies

  /**
   * Returns correctness preservation errors and warnings by analyzing semantic contraint issues 
   * in the ASTs before- and after- the transformation.
   * The analysis covers semantic-constraint errors and warnings, reporting problems for: 
   * - introduced issues
   * - (possible unintended) solved issues.
   * 
   * This rule applies to a tuple consisting of a list of ASTs before the transformation and 
   * a list of ASTs after the refactoring transformation. 
   * All ASTs that are possible (semantically or structurally) affected by the transformation must be included in both lists.
   * - The ASTs before the transformation contain name binding annotations set by @see analyze-top(|language) or @see analyze-asts-multifile.
   * - The ASTs after the transformation are later (re)analyzed by @see analyze-asts-multifile 
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   *
   * REMARK: Only use this rule in case the nambinding preservations are not checked.
   * Otherwise, use @see semantic-violation-errors(constraint-error, constraint-warning) 
   * in behavior-preservation.generated.str
   */
  correctness-violation-errors(constraint-error, constraint-warning):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      (errors, warnings) := <correctness-violation-errors(constraint-error, constraint-warning, multifile-analyze-asts)>

  /**
   * @see correctness-violation-errors(constraint-error, constraint-warning)
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   * @param analyze-multifile   List(ast) -> List(ast) stores semantic info in ASTs and name index
   */
  correctness-violation-errors(constraint-error, constraint-warning, analyze-multifile):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      //errors and warnings on analyzed asts before the transformation
      errors-before   := <mapconcat(collect-all(constraint-error, conc))> asts-before-analyzed; 
      warnings-before := <mapconcat(collect-all(constraint-warning, conc))> asts-before-analyzed; 
      
      //errors and warnings on (re)analyzed asts after the transformation
      asts-after-analyzed := <analyze-multifile> asts-after;      
      errors-after   := <mapconcat(collect-all(constraint-error, conc))> asts-after-analyzed;
      warnings-after := <mapconcat(collect-all(constraint-warning, conc))> asts-after-analyzed;
      
      //errors and warnings that are different in the ASTs before- and after- the transformation
      errors := <compare-constraint-issues> (errors-before, errors-after);
      warnings := <compare-constraint-issues> (warnings-before, warnings-after)

  //compares issues in the ASTs before transformation and in the ASTs after transformation
  compare-constraint-issues:
    (old-issues, new-issues) -> <conc> (introduced-issues, solved-issues)
    where
      introduced-issues := <diff(is-same-constraint-issue)> (new-issues, old-issues);
      solved-issues     := <diff(is-same-constraint-issue); map(!(<Fst>, $[SOLVED, [<Snd>]]))> (old-issues, new-issues)
  
  //decides wether an issue in the AST before transformation
  //and an issue in the AST after the transformation are the same.
  //@internal
  is-same-constraint-issue:
    issue-tuple@((trm1, message1), (trm2, message2)) -> issue-tuple
    where
      <origin-equal(|trm1)> trm2 <+
      <origin-equal(|trm2)> trm1
    where
      <equal> (message1, message2) <+ //unreliable because message may contain the string represenatation of the (changed) term
      <equal> (<has-annos; get-annos> trm1, <get-annos> trm2) //more reliable would be an annotation that indicates the error type
}

create-analysis-multifile =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "analysis-multifile.generated.str")>
"/** 
* This module contains analysis functions for refactorings that affect multiple files.
*/
module lib-refactoring/analysis-multifile.generated

imports
  lib/index-library.generated
  lib/analysis-library-internal.generated
  lib/editor-common.generated


rules //multifile name analysis

  /**
   * (Re)analyzes a set of ASTs. 
   * @see multifile-analyze-asts-internal(|language, project-path)
   *
   * @type List(ast) -> List(ast)
   */
  multifile-analyze-asts:
    asts -> asts-analyzed
    where
      asts-analyzed := <
        topdown(strip-annos);
        map(!(<id>, <origin-file>));
        multifile-analyze-asts-internal(|<language>, <project-path>)
      > asts

  /**
   * Analyzes a set of ASTs that are possible changed together in one operation.
   * The multifile analysis makes sure that all definitions are looked up from the ASTs in the set
   * instead of from the file system (represented by the current semantic index) which may contain the 
   * old version before the multifile change operation (refactoring) applied.
   * The analysis annotates definition and use sites found in the ASTs with URIs.
   *
   * Remark: The new analysis results are commited to the index.
   * TODO: The Spoofax refactoring class takes care of index rollback in case the refactoring is aborted
   * TODO: The Spoofax refactoring class implements reschedule analysis of changed files 
   * in case the refactoring is commited.
   *
   * @param language      The name of the language that is being analysed.
   * @param project-path  The path of the directory that contains all the source files.
   * @type List(ast, file) -> List(ast) REMARK: full-path file names are used.
   */
  multifile-analyze-asts-internal(|language, project-path):
    astFilePaths -> asts
    with
      <map(index-setup(|language, [project-path], <Snd>))> astFilePaths;
      <map(Snd; index-clear-file)> astFilePaths
    with
      {| Index-UnresolvedSet:
        unresolvedSet := <new-iset>;
        rules(Index-UnresolvedSet: _ -> unresolvedSet);
        astFilePairs := <map(!(<Fst>, (<Snd>, [])))> astFilePaths;
        (astFilePairs2, _) := <unzip> <map(analyze-top-defs)> astFilePairs;
        (astFilePairs3, _) := <unzip> <map(analyze-top-data(|language, <{path: ((_, (path, _)) -> path)}>))> astFilePairs2;
        (astFilePairs4, _) := <unzip> <map(analyze-top-uses(|language, <{path: ((_, (path, _)) -> path)}>))> astFilePairs3;
        (asts, _) := <unzip> astFilePairs4
      |}
    with
      <list-loop(analyze-top-store-ast(|language, <{path: ((_, (path, _)) -> path)}>))> astFilePairs4"

create-refactoring-files =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "files.generated.str")>
"/** 
* Functions to find and parse files
*/
module lib-refactoring/files.generated

imports
  lib/editor-common.generated
  lib/analysis-library.generated
  lib/index-library.generated

rules //parse files

  /**
   * Parses the file (project relative path) or reports an error ('file not found' or 'syntax errors')
   *
   * @type List(String) -> (List(ast), List(String)
   */
  files-to-asts:
    files -> <partition(parse-file, file-to-error-message)> files

  //@internal
  //constructs an error message for a file that can not be parsed
  file-to-error-message:
    file -> error-message
    where
      if <file-exists> file then
        error-message := $['[file]' can not be parsed because of syntax errors.]
      else
        error-message := $['[file]' can not be found.]
      end


rules //collect dependent files

  /**
   * Returns all files that contain Defs, Uses or Reads of the construct with the given URI
   *
   * @type String{[uri]} -> List(String)
   */
  files-with-references-to-uri:
    annotated-name -> <conc; make-set> (files-with-accesses, files-with-definition)
    where
      files-with-accesses := <files-with-accesses-to-uri> annotated-name; 
      files-with-definition := <files-with-definition-of-uri> annotated-name

  /**
   * Returns all files that contain Uses or Reads of the construct with the given URI
   *
   * @type String{[uri]} -> List(String)
   */
  files-with-accesses-to-uri:
    annotated-name -> project-relative-paths
    where
        project-relative-paths := <
          index-get-dependent-files;
          index-filepairs-to-files
        > [annotated-name]

  /**
   * Returns all files that contain Defs of the construct with the given URI
   *
   * @type String{[uri]} -> List(String)
   */
  files-with-definition-of-uri:
    annotated-name -> project-relative-paths
    where
        defsite := <index-lookup> annotated-name;
        project-relative-paths := <
          index-get-referenced-files(![defsite]);
          index-filepairs-to-files
        > [annotated-name]

  /**
   * Returns all files that contain an identifier with the given name (given as String, NOT as uri)
   *
   * @type String -> List(String)
   */
  files-with-terms-of-name:
    name -> <
      index-get-all-files; 
      filter(file-has-term-of-name(|name)); 
      index-filepairs-to-files
    >

  /**
   * Says whether a file contains an identifier with the given name (given as String, NOT as uri)
   *
   * @internal
   * @param String
   * @type String -> String
   */
  file-has-term-of-name(|name):
    filename -> filename
    where
      index-get-all-in-file; 
      fetch(?Use([_, name | _]) <+ ?BadUse([_, name | _]) <+ ?Def([_, name | _]) <+ ?Read([_, name | _]))"
      
create-rename-refactoring =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "rename-refactoring.generated.str")>
${/** 
* Language generic Rename refactoring
*/
module lib-refactoring/rename-refactoring.generated

imports
  lib-refactoring/analysis-multifile.generated
  lib-refactoring/behavior-preservation.generated
  lib-refactoring/files.generated
  lib/nbl-library.generated
  lib/index-library.generated
  lib/editor-common.generated

rules //generic rename refactoring

  /**
   * Implements a multifile rename refactoring based on the semantic index.
   * Renames the definition and use sites of the selected identifier, and
   * reports errors end warnings for name binding violations or semantic correctness violations.
   *
   * @type (String, String (annotated with uri), List(Int), AST, String, String) -> 
   * (List(Tuple(AST, AST)), List(Tuple(T,String)), List(Tuple(T,String) or String), List(Tuple(T,String)))
   * @param AST -> AST 
   * @param T -> Tuple(T, String) 
   * @param T -> Tuple(T, String)
   */
  generic-rename-refactoring(desugar, s-constraint-error, s-constraint-warning):
    (newname, oldname, position, ast, path, project-path) -> (ast-change-tuples, [], all-errors, warnings)
    where
      //Assumption: all files in project are indexed (or are in the analysis queue)!?
      //TODO: Spoofax refactoring component must show waiting dialog in case the analysis queue is not empty
      index-setup(|<language>, [project-path], ".");

      //Get analyzed asts of all files that contain oldname + uri identifiers 
      files-related-oldname := <files-with-references-to-uri; filter(not(?path))> oldname; //files that have changes
      (asts-related-oldname, file-errors-1) := <files-to-asts> files-related-oldname;
      asts-before := [ast | <map(desugar); multifile-analyze-asts> asts-related-oldname];

      //Apply renaming transformation on ASTs with oldname + uri identifiers
      //Construct change list that forms the result of the refactoring
      asts-after := <alltd(preserve-annos((oldname -> newname)))> asts-before;
      ast-change-tuples := <zip> (asts-before, asts-after);

      //Get analyzed asts of all files that may be involved in name collisions.
      files-containing-newname := <files-with-terms-of-name> newname; 
      files-to-check-newname := <diff> (files-containing-newname, [path|files-related-oldname]); 
      (asts-to-check-newname, file-errors-2) := <files-to-asts> files-to-check-newname;
      asts-to-check-newname-analyzed :=  <map(desugar); multifile-analyze-asts> asts-to-check-newname; 
      (errors, warnings) := <semantic-violation-errors(s-constraint-error <+ constraint-error, s-constraint-warning|[newname, oldname])> (
         <conc> (asts-before, asts-to-check-newname-analyzed), 
         <conc> (asts-after,  asts-to-check-newname-analyzed)
      );
       
      //all errors
      all-errors := <concat> [file-errors-1, file-errors-2, errors]
      
      // REMARK: all (possible) changed files are automatically queued for analysis in the Spoofax 
      // refactoring component after the refactoring is executed or canceled by the user
}

create-binding-violations =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "binding-violations.generated.str")>
"/**
 * Strategy to calculate binding violations by comparing binding annotations that 
 * express the actual and the intended binding structure.
 */
module lib-refactoring/binding-violations.generated

strategies 

  /**
   * @see binding-violation-terms(is-endangered-term)
   *
   * @type  (T, T) -> List(T{b1, b2})
   * @param endangered-terms  List with terms that must be checked for binding violations
   */
  binding-violation-terms(|endangered-terms) =
    binding-violation-terms(is-in-list(|endangered-terms))

  /**
   * Returns binding violations by comparing the expected binding structure with the actual binding structure
   * in the asts that result after the transformation.
   * Can be used to check for violations of name reference.
   * For performance reason, only the 'endangered' terms are compared.
   *
   * The input term must be a tuple (trm-intended-bindings, trm-actual-bindings) whereby
   * 1) both terms have the same abstract structure
   * 2) the trm-intended-bindings contains annotations that express the INTENDED binding structure
   *    (typically obtained by 'analyze; transform' whereby the transformation preserves the original annotations 
   *     and sets annotations for newly inserted terms)
   * 3) the trm-actual-bindings contain name annotations that express the ACTUAL binding structure
   *    (typically obtained by 'transform; analyze', i.e. reanalyzing the resulting asts)
   *
   * @type  (T, T) -> List(T{b1, b2})
   * @param is-endangered-term  String -> String
   */  
  binding-violation-terms(is-endangered-term):
    trees@(trm-intended-bindings, trm-actual-bindings) -> binding-violation-terms
    where
      binding-violation-terms := <
        bindings-construct-compare-ast;
        binding-violation-terms-internal(fail, is-endangered-term)
      > trees
  
   //Constructs an AST with information about the original binding structure, and the new binding structure.
   //Condition: 'trm-intended-bindings' and 'trm-actual-bindings' have the same structure and contain binding information.
  bindings-construct-compare-ast:
    (trm-intended-bindings, trm-actual-bindings) -> binding-compare-ast
    where
      binding-compare-ast := <merge-bindings>(trm-intended-bindings, trm-actual-bindings)
  
  //Returns binding violations by comparing the expected binding with the actual binding, 
  //both set as annotation on terms (t{b-intended, b-actual}) in the 'binding compare AST'.
  //For performance reason, only the 'endangered' terms are compared.
  binding-violation-terms-internal(uses-list-annos, is-endangered-term):
    binding-compare-ast -> binding-violations
    where 
      all-bindings := <
        bindings-collect-endangered-terms(is-endangered-term);
        filter(has-binding-info)
      > binding-compare-ast; 
      if not(uses-list-annos) then
        (binding-violations, _) := <bindings-partition-violations> all-bindings
      else
        (binding-violations, _) := <bindings-partition-violations-list-annos> all-bindings        
      end

  bindings-collect-endangered-terms(is-endangered-term):
    binding-compare-ast -> bindings-mapping
    where
      bindings-mapping := <
        collect-all(?_{_, _}; where(strip-annos; is-endangered-term), conc)
      > binding-compare-ast
  
  bindings-partition-violations:
    bindings -> (violated-bindings, binding-mapping)
    where
      (broken-bindings,  bindings-1)  := <partition(is-broken-binding)> bindings; 
      (created-bindings, bindings-2) := <partition(is-created-binding)> bindings-1;
      (changed-bindings, binding-mapping) := <partition-is-changed-binding> bindings-2;
      violated-bindings := <concat> [broken-bindings, created-bindings, changed-bindings]

  partition-is-changed-binding: 
    [t{b1,b2}|bindings] -> (conflicts, mapping)
    where 
      (related-bindings, unrelated-bindings) := <partition(?_{b1,_} <+ ?_{_,b2})> bindings;
      (rec-conflicts, rec-mapping):= <partition-is-changed-binding> unrelated-bindings;
      if <filter(not(?_{b1,b2})); ?[]> related-bindings then
        conflicts := rec-conflicts;
        mapping := [t{b1,b2}| rec-mapping]
      else
        conflicts := <conc> ([t{b1,b2}|related-bindings], rec-conflicts);
        mapping := rec-mapping
      end
  
  partition-is-changed-binding:
    [] -> ([], [])

  has-binding-info =
    has-annos;
    not(
      ?_{None(), None()} <+
      ?_{(),()} <+
      ?_{[],[]}
    )
  
  is-broken-binding =
    ?_{_, None()}; not(?_{None(), None()})

  is-broken-binding =
    ?_{_, ()}; not(?_{(),()})

  is-broken-binding =
    ?_{_, []}; not(?_{[],[]})
  
  is-created-binding =
    ?n{b1, b2}; 
    where(<is-broken-binding> n{b2, b1})


rules //helpers

  is-in-list(|lst):
    elem -> elem
    where
      <fetch(strip-annos; equal(|<strip-annos> elem))> lst

  //@internal    
  merge-bindings =
    merge-bindings-1 <+
    merge-bindings-2 <+
    merge-bindings-3 <+
    merge-bindings-4
  
  //@internal    
  merge-bindings-1:
    (s1{b1}, s2{b2}) -> s1{b1, b2}
    where
      <equal> (s1{},s2{})
  
  //@internal    
  merge-bindings-2:
    (s1{b1}, s2{}) -> s1{b1, None()}
    where
      <equal> (s1{},s2{})
  
  //@internal    
  merge-bindings-3:
    (s1{}, s2{b2}) -> s1{None(), b2}
    where
      <equal> (s1{},s2{})
  
  //@internal    
  merge-bindings-4:
    (c#(args1), c#(args2)) -> c#(args) 
    where
      args := <zip; map(merge-bindings)> (args1, args2)
      
rules //support for list annotations with the restriction 'single-anno-declarations + mult-anno-reads'

  /**
   * @see binding-violation-terms-list-annos(is-endangered-term)
   *
   * @type  (T, T) -> List(T{b1, b2})
   * @param endangered-terms  List with terms that must be checked for binding violations
   */
  binding-violation-terms-list-annos(|endangered-terms) =
    binding-violation-terms-list-annos(is-in-list(|endangered-terms))

  /**
   * Returns binding violations by comparing the expected binding structure with the actual binding structure
   * in the asts that result after the transformation.
   * Can be used to check for violations of data-flow where a term can have multiple predecessors.
   * For performance reason, only the 'endangered' terms are compared.
   *
   * The input term must be a tuple (trm-intended-bindings, trm-actual-bindings) whereby
   * 1) both terms have the same abstract structure
   * 2) the trm-intended-bindings contains annotations that express the INTENDED binding structure
   *    (typically obtained by 'analyze; transform' whereby the transformation preserves the original annotations 
   *     and sets annotations for newly inserted terms)
   * 3) the trm-actual-bindings contain name annotations that express the ACTUAL binding structure
   *    (typically obtained by 'transform; analyze', i.e. reanalyzing the resulting asts)
   * 4) TODO: for now it only works well in case the binding mapping can be constructed by considering single-anno elems only
   *
   * @type  (T, T) -> List(T{b1, b2})
   * @param is-endangered-term  String -> String
   */  
  binding-violation-terms-list-annos(is-endangered-term):
    trees@(trm-intended-bindings, trm-actual-bindings) -> binding-violation-terms
    where
      binding-violation-terms := <
        bindings-construct-compare-ast;
        binding-violation-terms-internal(id, is-endangered-term)
      > trees


  //Assumption: 'declarations' are single element (lists), 'reads' can be multiple element lists
  //The single element lists determine the mapping (and may have violations), reads are checked for violations
  //REMARK: useful for flow analysis where a read-access can have multiple predecessors
  bindings-partition-violations-list-annos:
    bindings -> (binding-violations, mapping)
    where
      (broken-list-bindings, bindings-1)  := <partition(is-broken-list-binding)> bindings; 
      (created-list-bindings, bindings-2)  := <partition(is-created-list-binding)> bindings-1; 
      list-bindings := <map(try(binding-single-to-list))> bindings-2;
      (changed-list-bindings, mapping) := <bindings-partition-violations-list-annos-2> list-bindings;
      binding-violations := <concat> [broken-list-bindings, created-list-bindings, changed-list-bindings]
  
  //@internal
  bindings-partition-violations-list-annos-2:
    list-bindings -> (binding-violations, mapping)
    with
      map({lb1, lb2: (?_{lb1, lb2}; <eq>(<length> lb1, <length> lb2))})
    where 
      (singleton-bindings, multiple-bindings) := <partition(?_{[_], [_]})> list-bindings; 
      (singleton-violations, singleton-mappings) := <bindings-partition-violations> singleton-bindings; 
      (multiple-bindings', list-violations) := <partition(filter-all-bindings-from-list-binding(|singleton-mappings))> multiple-bindings; 
      if <not(equal)> (multiple-bindings', multiple-bindings) then
        (rec-violations, rec-mapping) := <bindings-partition-violations-list-annos-2> multiple-bindings'
      else //TODO: we can not detect violations such as the 'a' in t{[a, b], [r, s]} and t{[a, c], [t, u]}
        (rec-violations, rec-mapping) := <bindings-partition-violations> multiple-bindings' 
        //detects '[a,b]' in t{[a, b], [r, s]} and t{[a, b], [r, u]}
      end;
      mapping := <conc>(singleton-mappings, rec-mapping);
      binding-violations := <concat> [singleton-violations, list-violations, rec-violations]
  
  
  filter-all-bindings-from-list-binding(|binding-mapping):
    lst-binding@t{b_lst1, b_lst2} -> lst-binding'
    where
      lst-binding' := <foldr(!lst-binding, filter-binding-mapping-from-list-binding)> binding-mapping
    
  filter-binding-mapping-from-list-binding:
    (_{[b1], [b2]}, t{b_lst1, b_lst2}) -> t{b_lst1', b_lst2'}
    where
      (matched-1, b_lst1') := <partition(?b1)> b_lst1;
      (matched-2, b_lst2') := <partition(?b2)> b_lst2;
      <eq>(<length> matched-1, <length> matched-2)
    

  is-broken-list-binding:
    t{lb1, lb2} -> t{lb1, lb2}
    where
      <gt>(<length> lb1, <length> lb2)

  is-broken-list-binding:
    t{lb1, lb2} -> t{lb1, lb2}
    where
      <is-list> lb1;
      <not(is-list)> lb2

  is-created-list-binding:
    t{lb1, lb2} -> t{lb1, lb2}
    where
      <is-broken-list-binding> t{lb2, lb1}
      
  binding-single-to-list:
    t{b1, b2} -> t{[b1], [b2]}
    where
      <not(is-list)> b1;
      <not(is-list)> b2"
  
create-data-flow-analysis =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "data-flow-analysis.generated.str")>
"/**
 * Language generic template strategy for data-flow analysis.
 */
module lib-refactoring/data-flow-analysis.generated

rules //rules that implement the language specific part of the data-flow analysis

  /**
   * Associates a df-anno to the declared variable. 
   * The df-anno is set as an annotation on the name of the declared variable, and stored to annotate its subsequent  read accesses. 
   *
   * @example VarDecl(name, type) -> VarDecl(<set-new-df-value> name, type)
   * @type VarDecl -> VarDecl
   */  
  df-anno-declare = fail
    
  /**
   * Associates a new df-anno to the assigned variable. 
   * The df-anno is set as an annotation on the name of the assigned variable, and stored to annotate its subsequent read accesses. 
   * @example
   *   Assign(name, value) -> Assign(df-name, value')
   *   where
   *     value' := <df-anno> value;
   *     df-name := <set-new-df-value> name      
   * @type VarAssignment -> VarAssignment
   */  
  df-anno-assign = fail
    
  /**
   * Implements the data-flow for constructs that affect the control flow (and thus also the data-flow).
   *
   * @example
   *   If(c, if-block, else-block) -> If(c, if-block', else-block')
   *   where
   *     if-block' := <df-anno> if-block
   *       \\DFAnno/
   *     else-block' := <df-anno> else-block
   * @type T -> T
   */
  df-anno-control-flow = fail 

    
rules //helper rules 
  
  /**
   * Helper rule to associate a new, unique df-anno to the name of a declared or assigned variable.
   * The df-anno is stored to annotate the names of its subsequent read accesses.
   * @type String -> String{List(String)}
   */
  set-new-df-value:
    name -> name{[df-anno]}
    where
      df-anno := <newname> \"df_\";
      rules(DFAnno :  name  ->  df-anno)

  
rules //rules that implement the language generic part of the data-flow analysis
  
  /**
   * Sets data-flow annotations on variable names, so that: 
   * - variables with the same df-anno have the same value, e.g., 
   *   VarDecl(\"a{df-x}\"); VarAssign(\"a{df-y}\"); VarUse(\"a{df-y}\"); VarUse(\"a{df-y}\"); VarAssign(\"a{df-z}\"); VarUse(\"a{df-z}\");
   * - multiple df-annos can be set to represent different control flows, e.g., 
   *   If(c, VarAssign(\"a{df-x}\");, VarAssign(\"a{df-y}\");); VarUse(\"a{[df-x, df-y]}\")
   *
   * @type T -> T
   */
  analyze-dataflow:
    trm -> trm'
    where
      {|DFAnno:
        trm' := <df-anno> trm
      |}
  
  //controls the dataflow traversal
  df-anno =
    df-anno-use <+
    df-anno-declare <+
    df-anno-assign <+
    df-anno-control-flow <+ 
    all(df-anno)
  
  //annotates read accesses with a list of df-predecessors
  //@type String -> String{List(String)} 
  df-anno-use:
    name -> name{df-annos} 
    where
      <is-string> name;
      df-annos := <bagof-DFAnno> name"

create-extract-refactoring =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "extract-refactoring.generated.str")>
"/** 
* Language generic components for Extract refactorings
*/
module lib-refactoring/extract-refactoring.generated

imports
  lib-refactoring/list-operations.generated
  lib-refactoring/binding-violations.generated 
  lib/analysis-library-internal.generated 
  lib-refactoring/fetch-positions.generated
  
rules
  
  /**
   * Applies the extract transformation, that is: 
   * - inserts the extracted construct after the construct where the extraction takes place, and
   * - replaces the selected elements with a list of new elements (such as missing declarations and a call to the extracted construct) 
   *
   * @param match-construct: matches definitions of the extracted sort
   * @param replacing-terms: List(T), replaces the selected terms
   * @param extracted-construct: construct that is extracted
   * @type (List(T), ast) -> ast
   */  
  extract-transformation(match-construct|replacing-terms, extracted-construct):
    (selected, ast) -> ast-transformed
    where
      (from, to) := <position-of-sublist-from-to(|ast)> selected;
      pos-original-method := <fetch-up-position(match-construct|ast)> from;
      pos-extracted-construct := <position-next-sibling> pos-original-method;
      ast-transformed := <
        replace-sublist(|from, to, replacing-terms);
        insert-list-element(|pos-extracted-construct, extracted-construct)
      > ast

  /**
   * @see extract-method-analysis(is-method-definition, analyze-dataflow, get-declaration-name)
   * @type (List(T), ast) -> (List(VarDecl), List(VarDecl), List(VarDecl), List(VarDecl))
   */    
  extract-method-analysis(is-method-definition, analyze-dataflow) =
    extract-method-analysis(is-method-definition, analyze-dataflow, nam-get-definition-key)

  /**
   * Calculates the required information to repair the data-flow after method extractions.
   * Repair consists of inserting missing declarations (preferrable), or passing variable values
   * in the form of (in-)parameters and return values (out-parameters).
   *
   * Determines the missing declarations in the remainder of the original method and the extracted method.
   * - missing-vardecls-original: declarations of variables that are used in the remainder of the original method, 
   *   but declared in the extracted method
   * - missing-vardecls-extracted: declarations of variables that are used in the extracted method, 
   *   but declared in the remainder of the original method (and not passed as a parameter).
   *
   * Determines the required in- and out- parameters based on a data-flow analysis
   * - in-parameter-vardecls: declarations of variables that are used in the extracted method, 
   *   after being assigned in the remainder of the original method 
   * - out-parameter-vardecls: declarations of variables that are used in the remainder of the original method, 
   *   after being assigned in the extracted method 
   *
   * @param is-method-definition: matches method definitions
   * @param analyze-dataflow: sets data-flow annotations on variable names, so that: 
   *  - variables with the same df-anno have the same value, e.g., 
   *    VarDecl(\"a{df-x}\"); VarAssign(\"a{df-y}\"); VarUse(\"a{df-y}\")
   *  - multiple df-annos can be set to represent different control flows, e.g., 
   *    If(c, VarAssign(\"a{df-x}\");, VarAssign(\"a{df-y}\");); VarUse(\"a{[df-x, df-y]}\")
   *   
   * @param get-declaration-name: maps a declaration onto its name (fails for terms that are not declarations)
   * @type (List(T), ast) -> (List(VarDecl), List(VarDecl), List(VarDecl), List(VarDecl))
   */    
  extract-method-analysis(is-method-definition, analyze-dataflow, get-declaration-name):
    (selected, ast) -> (missing-vardecls-original, missing-vardecls-extracted,  in-parameter-vardecls, out-parameter-vardecls)
    where
      (pos-from-ast, _) := <position-of-sublist-from-to(|ast)> selected;
      method := <fetch-up-term(is-method-definition|ast)> pos-from-ast; 
      (from, to) := <position-of-sublist-from-to(|method)> selected;
      (missing-vardecls-original, missing-vardecls-extracted') :=
        <extract-method-missing-declarations(get-declaration-name)> (method, from, to);
      (in-parameter-vardecls, out-parameter-vardecls) :=
        <extract-method-parameters(analyze-dataflow, get-declaration-name)> (method, from, to);
      missing-vardecls-extracted := <diff>(missing-vardecls-extracted', in-parameter-vardecls) //exclude in-parameters from the list of missing vardecls


rules //helper rules to perform the required data-flow analyses for method extraction 

  /**
   * Determines the missing declarations in the remainder of the original method and the extracted method.
   * - missing-vardecls-original: declarations of variables that are used in the remainder of the original method, 
   *   but declared in the extracted method
   * - missing-vardecls-extracted: declarations of variables that are used in the extracted method, 
   *   but declared in the remainder of the original method (and not passed as a parameter).
   *
   * @param get-declaration-name: maps a declaration onto its name (fails for terms that are not declarations)
   * @type (T, List(Int), List(Int)) -> (List(VarDecl), List(VarDecl))
   */    
  extract-method-missing-declarations(get-declaration-name):
    (method, from, to) -> (missing-vardecls-original, missing-vardecls-extracted)
    where
      missing-vardecls-original  := <get-missing-declarations(remove-sublist(|from, to), get-declaration-name)> method;
      missing-vardecls-extracted := <get-missing-declarations(select-sublist(|from, to), get-declaration-name)> method

  get-missing-declarations(transform, get-declaration-name):
    term-before -> missing-declarations
    where
      term-after := <transform> term-before; 
      declarations-before := <collect-all(where(get-declaration-name))> term-before;
      declarations-after := <collect-all(where(get-declaration-name))> term-after;
      lost-declarations := <diff(where(all(get-declaration-name); eq))> (declarations-before, declarations-after);
      variables-after := <collect-all(is-string)> term-after;
      missing-declarations := <filter(where(!(<get-declaration-name>, variables-after); elem))> lost-declarations
  
  /**
   * Determines the required in- and out- parameters based on a data-flow analysis
   * - in-parameters: variables that are used in the extracted method, after being assigned in the remainder of the original method 
   * - out-parameters: variables that are used in the remainder of the original method, after being assigned in the extracted method 
   *
   * @param analyze-dataflow: sets data-flow annotations on variable names, so that: 
   *  - variables with the same df-anno have the same value, e.g., 
   *    VarDecl(\"a{df-x}\"); VarAssign(\"a{df-y}\"); VarUse(\"a{df-y}\")
   *  - multiple df-annos can be set to represent different control flows, e.g., 
   *    If(c, VarAssign(\"a{df-x}\");, VarAssign(\"a{df-y}\");); VarUse(\"a{[df-x, df-y]}\")
   *   
   * @param get-declaration-name: maps a declaration onto its name (fails for terms that are not declarations)
   * @type (T, List(Int), List(Int)) -> (List(VarDecl), List(VarDecl))
   */    
  extract-method-parameters(analyze-dataflow, get-declaration-name):
    (method, from, to) -> (in-parameter-vardecls, out-parameter-vardecls)
    where
      in-parameter-vardecls := <get-df-changed-declarations(select-sublist(|from, to), get-declaration-name, analyze-dataflow)> method;
      out-parameter-vardecls := <get-df-changed-declarations(remove-sublist(|from, to), get-declaration-name, analyze-dataflow) > method

  get-df-changed-declarations(transform, get-declaration-name, analyze-dataflow):
    term -> df-changed-declarations
    where
      declarations := <collect-all(where(get-declaration-name))> term;
      declaration-names := <map(get-declaration-name)> declarations;
      df-changes := <get-df-changes(transform, analyze-dataflow|declaration-names); map(strip-annos); make-set> term;
      df-changed-declarations := <filter(where(get-declaration-name; is-in-list(|df-changes)))> declarations

  //Calculates df-changes by comparing INTENDED and ACTUAL 
  //dataflow annotations in the tree after transformation.
  //Intended df-annos are obtained via <analyze; transform>,
  //actual df-annos are obtained via <transform; analyze>
  get-df-changes(transform, analyze-dataflow|declaration-names):
    term-before -> df-changes
    where
      term-after-df-intended := <analyze-dataflow; transform> term-before; 
      term-after-df-actual := <transform; analyze-dataflow> term-before; 
      //df-changes := <binding-violation-terms(|declaration-names)>(term-after-df-intended, term-after-df-actual)
      df-changes := <binding-violation-terms-list-annos(|declaration-names)>(term-after-df-intended, term-after-df-actual)"
      
create-fetch-positions =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "fetch-positions.generated.str")>
${module lib-refactoring/fetch-positions.generated
  
imports
  lib/editor-common.generated
  lib-refactoring/list-operations.generated
    
rules //strategies for fetching terms and positions in the ast
  
  /**
   * fetches the AST position by visiting the ancestors 
   * of a term, bottum up, starting at a certain position.
   * @param match: matches ancestor term to be fetched
   * @param ast: AST
   * @type List(Int) ->  List(Int)
   */ 
  fetch-up-position(match|ast):
    position -> position'
    where
      term := <term-at-position(|position)> ast;
      (term', position') := <fetch-up-with-position(match|ast)> (term, position)
  
  /**
   * fetches the first ancestor of a term, bottum up, 
   * starting at a certain position.
   * @param matches ancestor term to be fetched
   * @param AST
   * @type List(Int) ->  T
   */ 
  fetch-up-term(match|ast):
    position -> term'
    where
      term := <term-at-position(|position)> ast;
      (term', position') := <fetch-up-with-position(match|ast)> (term, position)
          
  /**
   * fetches an ancestor and its AST position by visiting the ancestors of a term, bottum up
   * @param matches ancestor term to be fetched
   * @param AST
   * @type (Term, List(Int)) -> (Term, List(Int))
   */ 
  fetch-up-with-position(match|ast):
    (term, position) -> (term', position')
    where
      (term', position') := <fetch-up-with-position(match, fail|ast)> (term, position)
  
  /**
   * fetches an ancestor and its AST position by visiting the ancestors of a term, bottum up
   * @param matches ancestor term to be fetched
   * @param stop criteria
   * @param AST
   * @type (Term, List(Int)) -> (Term, List(Int))
   */  
  fetch-up-with-position(match, stop|ast):
    (term, position) -> (term', position')
    where
      <not(match)> term;
      <not(stop)> term;
      parent-tuple := (<parent-at-position(|position)> ast, <init> position);
      (term', position') := <fetch-up-with-position(match, stop|ast)> parent-tuple
  
  fetch-up-with-position(match, stop|ast):
    (term, position) -> (term, position)
    where
      <match> term
  
  /**
   * fetches a subterm in a chain of single-argument nodes
   * @param matches subterm to be fetched
   * @type Term -> Term
   */  
  fetch-down-term(match):
    term -> term'
    where
      term' := <fetch-down-with-position(match); Fst> (term, [])
  
  /**
   * fetches a subterm and its position in a chain of single-argument nodes
   * @param matches subterm to be fetched
   * @type (Term, List(Int)) -> (Term, List(Int))
   */  
  fetch-down-with-position(match):
    (term, position) -> (term', position')
    where 
      <not(match)> term; 
      <get-arguments; ?[e]> term; 
      (term', position') := <fetch-down-with-position(match)> (e, <conc>(position,[0]))
    
  fetch-down-with-position(match):
    (term, position) -> (term, position)
    where
      <match> term
  
  
rules //strategies for getting the tree positions of subterms
  
  /**
   * Returns the term positions of the first and last elements of a (sub)list,
   * relative to a given ancestor term.
   *
   * @param ast, ancestor term
   * @type ATerm -> (List(Int), List(Int))
  */  
  position-of-sublist-from-to(|ast):
    sublist -> <position-of-sublist-from-to(|ast, [])> sublist
  
  /**
   * Returns the AST positions of the first and last elements of a (sub)list,
   * calculated from an ancestor term at a given position.
   *
   * @param ast, ancestor term
   * @param position, List(Int) position of ancestor term  
   * @type ATerm -> (List(Int), List(Int))
  */  
  position-of-sublist-from-to(|ast, position):
    sublist -> (from, to)
    where
      from := <Hd; position-of-subterm(|ast, position)> sublist; 
      to := <last; position-of-subterm(|ast, position)> sublist
    where
      lst := <select-sublist(|from, to)> ast;
      <equal> (<length> lst, <length> sublist) //TODO: origin equal
      
  
  /**
   * Returns the position of a subterm relative to an ancestor term.
   *
   * @param ast, ancestor term
   * @type ATerm -> List(Int)
  */
  position-of-subterm(|ast) =
    position-of-subterm(|ast, [])
  
  /**
   * Returns the AST position of a subterm,
   * calculated from an ancestor term at a given position.
   *
   * @param term T, ancestor term
   * @param term-position List(Int), position of ancestor term  
   * @type ATerm -> List(Int)
  */
  position-of-subterm(|term, term-position):
    subterm -> <conc>(term-position, position)
    where
      position := <position-of-term(origin-equal(|subterm))> term
  
  
rules
  
  /**
   * Returns the position of the next sibling
   *
   * @type List(Int) -> List(Int)
  */
  position-next-sibling = at-last(([i] -> [<inc> i]))
}

create-list-operations =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "list-operations.generated.str")>
${module lib-refactoring/list-operations.generated
  
imports
  lib/editor-common.generated
  lib-refactoring/fetch-positions.generated  
  
  
rules //select list-elements at position
    
  /**
   * Returns the (sub)list that corresponds to the given AST positions 
   * @param The position of the first element as List(Int)
   * @param The position of the last element as List(Int)
   * @type ATerm -> List(a)
  */
  select-sublist(|from, to):
    ast -> sublist
    where
      <equal> (<init> from, <init> to) 
    where
      list-pos := <init> from;
      list := <term-at-position(|list-pos)> ast;
      sublist := <select-partial-list(|<last> from, <last> to)> list
      
  /**
   * Returns the (sub)list that corresponds to the given list indexes 
   * @param The index of the first element
   * @param The index of the last element
   * @type ATerm -> List(a)
  */
  select-partial-list(|from, to): 
    list -> mid-part
    where 
      (prefix, suffix) := <split-at(|<inc> to)> list;
      (pre, mid-part) := <split-at(|from)> prefix
      
  /**
   * Selects a (sub)list based on origin matching
   *
   * @param The subsequent list elements to be removed
   * @type ATerm -> ATerm
  */    
  select-sublist(|sublist):
    term -> <select-sublist(|from, to)> term
    where
      (from, to) := <position-of-sublist-from-to(|term)> sublist
    
rules //remove list-elements at position
      
  /**
   * Removes list elements at a given position in the AST
   *
   * @param The position of the first element to be removed (from) as List(Int)
   * @param The position of the last element to be removed (to) as List(Int)
   * @type ATerm -> ATerm
  */
  remove-sublist(|from, to):
    ast -> ast-with-deletion
    where
      <equal> (<init> from, <init> to) 
    where
      list-pos := <init> from;
      ast-with-deletion := <at-position-preserve(remove-partial-list(|<last> from, <last> to)|list-pos)> ast
  
  /**
   * Removes elements from a list
   *
   * @param The index of the first element to be removed (from)  
   * @param The index of the last element to be removed (to)
   * @type List(T) -> List(T)
  */
  remove-partial-list(|from, to): 
    list -> list-after-deletion
    where 
      (part1, tail):=<split-at(|from)> list; 
      (prefix, part2):=<split-at(|<inc> to)> list;
      list-after-deletion:=<conc> (part1, part2)//TODO: origin tracking
  
  /**
   * Removes an element at a given position in the AST
   *
   * @param The position of the element to be removed  
   * @type ATerm -> ATerm
  */
  remove-list-element(|position)=
    remove-sublist(|position, position)

    
rules //insert list elements at position
  
  /**
   * Inserts list elements at a given position 
   *
   * @param The position for inserting the sublist as List(Int)  
   * @param The sublist that will be inserted
   * @type ATerm -> ATerm
  */
  insert-sublist(|position, sublist):
    ast -> ast-with-insertion
    where
      list-pos:=<take(|<length; dec> position)> position;
      ast-with-insertion:=<at-position-preserve(insert-partial-list(|<last> position, sublist)|list-pos)> ast
  
  /**
   * Inserts list elements at a given index 
   *
   * @param The index for inserting the sublist  
   * @param The sublist that will be inserted
   * @type ATerm -> ATerm
  */
  insert-partial-list(|index, sublist): 
    list -> list-with-insertion
    where
      (prefix, suffix):=<split-at(|index)>;
      list-with-insertion:=<conc> (prefix, sublist, suffix)
  
  /**
   * Inserts an element at a given position 
   *
   * @param The position for inserting the sublist as List(Int)
   * @param The element that will be inserted
   * @type ATerm -> ATerm
  */
  insert-list-element(|position, element)=
    insert-sublist(|position, [element])
  

rules //replace list elements at a certain position
  
  /**
   * Replaces a sublist in the AST with another sublist
   *
   * @param The position of the first element of the sublist to be replaced (from)  
   * @param The position of the last element of the sublist to be replaced (to)
   * @param The new sublist
   * @type ATerm -> ATerm
  */
  replace-sublist(|from, to, sublist)=
    remove-sublist(|from, to); 
    insert-sublist(|from, sublist)
  
  /**
   * Replaces a sublist in the AST with a single list element
   *
   * @param The position of the first element of the sublist to be replaced (from)  
   * @param The position of the last element of the sublist to be replaced (to)
   * @param The new list element
   * @type ATerm -> ATerm
  */
  replace-sublist-with-element(|from, to, element)=
    replace-sublist(|from, to, [element])
  
  /**
   * Replaces a list-element in the AST with a sublist
   *
   * @param The position of the list element that ill be removed   
   * @param The sublist that will be inserted
   * @param The new list element
   * @type ATerm -> ATerm
  */
  replace-all-elements-with-sublist-in-list(|position, sublist)=
    replace-sublist(|position, position, sublist)
  
  
rules //remove list-elements that match a certain criterion
  
  /**
   * Removes all elements matching s  
   * @param Strategy that determines the elements that will be removed  
   * @type ATerm -> ATerm
  */
  remove-all-elements(s) =
    topdown(try(remove-all-elements-from-list(s)))
  
  /**
   * Removes all list elements matching s  
   * @param Strategy that determines the elements that will be removed  
   * @type List -> List
  */
  remove-all-elements-from-list(s) =
    replace-all-elements-with-sublist-in-list(s|[])

  /**
   * Removes elements of a (sub)list from a list that is a subterm of the given term
   *
   * @param The subsequent list elements to be removed
   * @type ATerm -> ATerm
  */    
  remove-sublist(|sublist):
    term -> <remove-sublist(|from, to)> term
    where
      (from, to) := <position-of-sublist-from-to(|term)> sublist

rules //replace elements that match a certain criterion
  
  /**
   * Replaces all elements in the AST that match a given strategy with a sublist 
   * @param Strategy that determines the elements that will be replaced
   * @param Sublist that replaces the elements
   * @type ATerm -> ATerm
  */
  replace-all-elements-with-sublist(s|sublist)=
    topdown(try(replace-all-elements-with-sublist-in-list(s|sublist)))
  
  /**
   * Replaces list elements matching a certain strategy with a sublist 
   * @param Strategy that determines the elements that will be replaced
   * @param Sublist that replaces the elements
   * @type List -> List
  */  
  replace-all-elements-with-sublist-in-list(s|sublist):
    list -> result-list
    where 
      result-list:=<
        try(
          split-fetch(s); 
          <conc>(
            <Fst>, 
            sublist, 
            <Snd; replace-all-elements-with-sublist-in-list(s|sublist)>
          )
        )
      > list
  
  
rules //helpers

  /**
   * Applies s at the given position in the AST, while preserving the annotations and origin-term. 
   *
   * @type AST -> AST
   * @param strategy to apply
   * @param position in AST as List(Int) 
   */  
  at-position-preserve(s|position) =
    origin-track-forced(
      preserve-annos(
        at-position-preserve-internal(s|position)
      )
    )
  
  at-position-preserve-internal(s|position):
    c#(t*) -> t'
    where
      !position => [i | position']
    where
      t' := c#(<at-index(at-position-preserve(s|position'))> (i, t*))

  at-position-preserve-internal(s|position):
    t -> t'
    where
      !position => [];
      t' := <s> t
}