module sdf2imp/project/create-refactoring-library

imports
  sdf2imp/util/-

strategies

create-behavior-preservation =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "behavior-preservation.generated.str")>
${/** 
* This module contains functions to detect name collisions and semantic constraint errors 
* caused by the (refactoring) transformation.
*/
module lib-refactoring/behavior-preservation.generated

imports
  lib/editor-common.generated
  lib-refactoring/analysis-multifile.generated
  lib-refactoring/namebinding-preservation.generated
  lib-refactoring/correctness-preservation.generated

strategies

  /**
   * Returns behavior preservation errors and warnings by analyzing changes in the static semantics of
   * the ASTs before- and after- the transformation. The analysis covers:
   * - name binding violation errors
   * - semantic-constraint errors and warnings
   * 
   * This rule applies to a tuple consisting of a list of ASTs before the refactoring transformation and 
   * a list of ASTs after the transformation. 
   * All ASTs that are possible (semantically or structurally) affected by the transformation must be included in both lists.
   * - The ASTs before the transformation contain name binding annotations set by 
   *   @see analyze-top(|language) or @see analyze-top-multifile(|language, project-path).
   * - the ASTs after the transformation contain name binding annotations that express the EXPECTED binding structure
   *   (typically obtained by preserving annos during transformation and setting annos for new inserted definitions and their use sites) 
   * - The ASTs after the transformation are later (re)analyzed by @see analyze-asts-multifile 
   *
   * Remark: performance can be improved in case the endangered names are known
   * @see semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name) 
   *   or semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name)
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   */
  semantic-violation-errors(constraint-error, constraint-warning):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      (errors, warnings) := <semantic-violation-errors(constraint-error, constraint-warning, id)>

  /**
   * @see semantic-violation-errors(constraint-error, constraint-warning)
   * Improves the performance of name binding checks by only considering endangered names.
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   * @param endangered-names  List(String)
   */
  semantic-violation-errors(constraint-error, constraint-warning|endangered-names):
    (asts-before-analyzed, asts-after) -> <semantic-violation-errors(constraint-error, constraint-warning, is-in-list(|endangered-names'))>
    where
      endangered-names' := <map(strip-annos)> endangered-names
        
  /**
   * @see semantic-violation-errors(constraint-error, constraint-warning)
   * Improves the performance of name binding checks by only considering endangered names.
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   * @param is-endangered-name  String -> String
   */
  semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      (errors, warnings) := 
        <semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name, multifile-analyze-asts)>

  /**
   * @see semantic-violation-errors(constraint-error, constraint-warning)
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   * @param is-endangered-name  String -> String
   * @param analyze-multifile   List(ast) -> List(ast) stores semantic info in ASTs and name index
   */
  semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name, analyze-multifile):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      //errors and warnings on analyzed asts before the transformation
      errors-before   := <mapconcat(collect-all(constraint-error, conc))> asts-before-analyzed; 
      warnings-before := <mapconcat(collect-all(constraint-warning, conc))> asts-before-analyzed; 
      
      //errors and warnings on (re)analyzed asts after the transformation
      asts-after-analyzed := <analyze-multifile> asts-after;      
      errors-after   := <mapconcat(collect-all(constraint-error, conc))> asts-after-analyzed;
      warnings-after := <mapconcat(collect-all(constraint-warning, conc))> asts-after-analyzed;
      
      //errors and warnings by comparing the ASTs before- and after- the transformation      
      warnings := <compare-constraint-issues> (warnings-before, warnings-after);
      correctness-preservation-errors := <compare-constraint-issues> (errors-before, errors-after);
      namebinding-preservation-errors := <name-binding-violation-errors-on-trees(is-endangered-name)> (asts-after, asts-after-analyzed); 
      errors := <union(is-same-error-term)> (namebinding-preservation-errors, correctness-preservation-errors)

  //checks if semantic violations are reported for the same term.
  //prevents warnings about name binding violation errors that are also duplicate definition errors. 
  //@internal
  is-same-error-term:
    err-tup@((t1,_), (t2,_)) -> err-tup
    where
      <origin-equal(|t1)> t2 <+
      <origin-equal(|t2)> t1
  
  //backwards-compatibility
  get-semantic-violations(constraint-error, constraint-warning, is-endangered-name):
    ast-changes -> <semantic-violation-errors(constraint-error, constraint-warning, is-endangered-name)> <unzip> ast-changes
}

create-namebinding-preservation =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "namebinding-preservation.generated.str")>
"/** 
* This module contains functions to detect name binding violations 
* caused by the (refactoring) transformation.
* REMARK: Only use this module in case semantic correctness preservation is not checked.
* Otherwise, use behavior-preservation.generated.str
*/
module lib-refactoring/namebinding-preservation.generated

imports
  lib-refactoring/analysis-multifile.generated
  lib/index-library.generated

strategies

  /**
   * Returns name collision errors by comparing the expected binding structure with the actual binding structure
   * in the ASTs after the transformation.
   * The ASTs after the transformation (asts-expected-bindings) contain name binding annotations that express the EXPECTED binding structure
   * (typically obtained by preserving annos during transformation and setting annos for new inserted definitions) 
   * The ASTs are later (re)analyzed by @see multifile-analyze-asts 
   *
   * @type  t -> List(errors)
   */
  name-binding-violation-errors:
    asts-expected-bindings -> <name-binding-violation-errors(id)>

  /**
   * @see name-binding-violation-errors
   * Improves the performance of name binding checks by only considering endangered names.
   *
   * @type  t -> List(errors)
   * @param endangered-names  List(String)
   */
  name-binding-violation-errors(|endangered-names):
    asts-expected-bindings -> <name-binding-violation-errors(is-in-list(|endangered-names'), multifile-analyze-asts)>
    where
      endangered-names' := <map(strip-annos)> endangered-names

  /**
   * @see name-binding-violation-errors
   * Improves the performance of name binding checks by only considering endangered names.
   *
   * @type  t -> List(errors)
   * @param is-endangered-name  String -> String
   */
  name-binding-violation-errors(is-endangered-name):
    asts-expected-bindings -> <name-binding-violation-errors(is-endangered-name, multifile-analyze-asts)>

  /**
   * @see name-binding-violation-errors(is-endangered-name)
   *
   * @param analyze-multifile sets the correct name annotations 
   * and preserves the structure of the ASTs.
   *
   * @type  t -> List(errors)
   * @param is-endangered-name  String -> String
   * @param analyze-multifile   List(ast) -> List(ast) stores semantic info in ASTs and name index
   */
  name-binding-violation-errors(is-endangered-name, analyze-multifile):
    asts-expected-bindings -> binding-violation-errors
    where
      asts-actual-bindings := <analyze-multifile> asts-expected-bindings;
      binding-violation-errors := 
        <name-binding-violation-errors-on-trees(is-endangered-name)> (asts-expected-bindings, asts-actual-bindings)

  /**
   * Returns name collision errors by comparing the expected binding structure with the actual binding structure.
   *
   * @type  (t,t) -> List(errors)
   */
  name-binding-violation-errors-on-trees(is-endangered-name):
    (asts-expected-bindings, asts-actual-bindings)  -> binding-violation-errors
    where
      binding-violation-errors := <
        name-binding-violation-terms-on-trees(is-endangered-name);
        map(to-namebinding-error)
      > (asts-expected-bindings, asts-actual-bindings)

  /**
   * Returns name binding violations by comparing the expected binding structure with the actual binding structure.
   * For performance reason, only the 'endangered' names are compared.
   *
   * The input term must be a tuple (asts-expected, asts-actual) whereby
   * 1) both terms have the same abstract structure
   * 2) the asts-expected contain name annotations that express the EXPECTED binding structure
   *    (typically obtained by preserving annos during transformation and setting annos for new inserted definitions)
   * 3) the asts-actual contain name annotations that express the ACTUAL binding structure
   *    (typically obtained by reanalyzing the asts-expected)
   *
   * @type  (asts-expected, asts-actual) -> List(t{nb1, nb2})
   * @param is-endangered-name  String -> String
   */  
  name-binding-violation-terms-on-trees(is-endangered-name):
    trees@(asts-expected-bindings, asts-actual-bindings) -> binding-violation-terms
    where
      binding-violation-terms := <
        name-binding-construct-compare-ast;
        name-binding-violation-terms-on-compare-tree(is-endangered-name)
      > trees
  
   //Constructs an AST with information about the original binding structure, and the new binding structure.
   //Condition: 'asts-expected-bindings' and 'asts-actual-bindings' have the same structure and contain binding information.
  name-binding-construct-compare-ast:
    (asts-expected-bindings, asts-actual-bindings) -> binding-compare-ast
    where
      binding-compare-ast := <merge-bindings>(asts-expected-bindings, asts-actual-bindings)
  
  //Returns name binding violations by comparing the expected binding with the actual binding, 
  //both set as annotation on identifier terms.
  //For performance reason, only the 'endangered' names are compared.
  name-binding-violation-terms-on-compare-tree(is-endangered-name):
    binding-compare-ast -> binding-violation-terms
    where 
      all-bindings := <
        collect-binding-pairs(is-endangered-name)
      > binding-compare-ast; 
      binding-mapping := <make-set> all-bindings; 
      binding-violations := <filter-violations> binding-mapping; 
      binding-violation-terms := <isect> (all-bindings, binding-violations) 

  collect-binding-pairs(is-endangered-name):
    binding-compare-ast -> bindings-mapping
    where
      bindings-mapping := <
        collect-all(is-string; ?_{_, _}; where(strip-annos; is-endangered-name), conc)
      > binding-compare-ast
              
  filter-violations:
    binding-mapping -> <concat> [broken-bindings, created-bindings, changed-bindings]
    where
      (broken-bindings,  binding-mapping')  := <partition(is-broken-binding)> binding-mapping;
      (created-bindings, binding-mapping'') := <partition(is-created-binding)> binding-mapping';
      changed-bindings := <filter-changed-bindings> binding-mapping''

  filter-changed-bindings: 
    [t{nb1,nb2}|bindings] -> <conc>(conflicts, <filter-changed-bindings> unrelated-bindings)
    where 
      (related-bindings, unrelated-bindings) := <partition(?_{nb1,_} <+ ?_{_,nb2})> bindings;
      if <filter(not(?_{nb1,nb2})); ?[]> related-bindings then
        conflicts := []
      else
        conflicts := [t{nb1,nb2}|related-bindings]
      end
  
  filter-changed-bindings:
    [] -> []

  is-broken-binding =
    ?_{_, None()} 

  is-broken-binding =
    ?_{nb1, [Unresolved(_)|_]};
    where(<not(?[Unresolved(_)|_])> nb1) 
  
  is-created-binding =
    ?n{nb1, nb2}; 
    where(<is-broken-binding> n{nb2, nb1})


rules //report name binding violation to end user

  to-namebinding-error =
    to-namebinding-error-broken <+
    to-namebinding-error-created <+
    to-namebinding-error-changed
  
  to-namebinding-error-broken:
    <is-broken-binding> -> (<strip-annos>, $[Variable becomes unbound '[<strip-annos>]'])
  
  to-namebinding-error-created:
    <is-created-binding> -> (<strip-annos>, $[Unbound variabele becomes bound '[<strip-annos>]'])

  to-namebinding-error-changed:
    t{nb1, nb2} -> (<strip-annos>, $[Name collision with name '[<strip-annos>]'])

rules //helpers

  is-in-list(|names):
    name -> name
    where
      <fetch(?name{})> names

  //@internal    
  merge-bindings =
    merge-bindings-1 <+
    merge-bindings-2 <+
    merge-bindings-3 <+
    merge-bindings-4
  
  //@internal    
  merge-bindings-1:
    (s1{nb1}, s2{nb2}) -> s1{nb1, nb2}
    where
      <is-string> s1;
      <equal> (s1{},s2{})
  
  //@internal    
  merge-bindings-2:
    (s1{nb1}, s2{}) -> s1{nb1, None()}
    where
      <is-string> s1;
      <equal> (s1{},s2{})
  
  //@internal    
  merge-bindings-3:
    (s1{}, s2{nb2}) -> s1{None(), nb2}
    where
      <is-string> s1;
      <equal> (s1{},s2{})
  
  //@internal    
  merge-bindings-4:
    (c#(args1), c#(args2)) -> c#(args) 
    where
      args := <zip; map(merge-bindings)> (args1, args2)"


create-correctness-preservation =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "correctness-preservation.generated.str")>
${/** 
* This module contains functions to detect semantic constraint errors 
* caused by the (refactoring) transformation.
* REMARK: Only use this module in case name binding preservations are not checked.
* Otherwise, use behavior-preservation.generated.str
*/
module lib-refactoring/correctness-preservation.generated 

imports
  lib-refactoring/analysis-multifile.generated
  lib/editor-common.generated

strategies

  /**
   * Returns correctness preservation errors and warnings by analyzing semantic contraint issues 
   * in the ASTs before- and after- the transformation.
   * The analysis covers semantic-constraint errors and warnings, reporting problems for: 
   * - introduced issues
   * - (possible unintended) solved issues.
   * 
   * This rule applies to a tuple consisting of a list of ASTs before the transformation and 
   * a list of ASTs after the refactoring transformation. 
   * All ASTs that are possible (semantically or structurally) affected by the transformation must be included in both lists.
   * - The ASTs before the transformation contain name binding annotations set by @see analyze-top(|language) or @see analyze-asts-multifile.
   * - The ASTs after the transformation are later (re)analyzed by @see analyze-asts-multifile 
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   *
   * REMARK: Only use this rule in case the nambinding preservations are not checked.
   * Otherwise, use @see semantic-violation-errors(constraint-error, constraint-warning) 
   * in behavior-preservation.generated.str
   */
  correctness-violation-errors(constraint-error, constraint-warning):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      (errors, warnings) := <correctness-violation-errors(constraint-error, constraint-warning, multifile-analyze-asts)>

  /**
   * @see correctness-violation-errors(constraint-error, constraint-warning)
   *
   * @type (List(ast), List(ast)) -> (List(errors), List(warnings)
   * @param constraint-error    t -> (t, String)
   * @param constraint-warning  t -> (t, String)
   * @param analyze-multifile   List(ast) -> List(ast) stores semantic info in ASTs and name index
   */
  correctness-violation-errors(constraint-error, constraint-warning, analyze-multifile):
    (asts-before-analyzed, asts-after) -> (errors, warnings)
    where
      //errors and warnings on analyzed asts before the transformation
      errors-before   := <mapconcat(collect-all(constraint-error, conc))> asts-before-analyzed; 
      warnings-before := <mapconcat(collect-all(constraint-warning, conc))> asts-before-analyzed; 
      
      //errors and warnings on (re)analyzed asts after the transformation
      asts-after-analyzed := <analyze-multifile> asts-after;      
      errors-after   := <mapconcat(collect-all(constraint-error, conc))> asts-after-analyzed;
      warnings-after := <mapconcat(collect-all(constraint-warning, conc))> asts-after-analyzed;
      
      //errors and warnings that are different in the ASTs before- and after- the transformation
      errors := <compare-constraint-issues> (errors-before, errors-after);
      warnings := <compare-constraint-issues> (warnings-before, warnings-after)

  //compares issues in the ASTs before transformation and in the ASTs after transformation
  compare-constraint-issues:
    (old-issues, new-issues) -> <conc> (introduced-issues, solved-issues)
    where
      introduced-issues := <diff(is-same-constraint-issue)> (new-issues, old-issues);
      solved-issues     := <diff(is-same-constraint-issue); map(!(<Fst>, $[SOLVED, [<Snd>]]))> (old-issues, new-issues)
  
  //decides wether an issue in the AST before transformation
  //and an issue in the AST after the transformation are the same.
  //@internal
  is-same-constraint-issue:
    issue-tuple@((trm1, message1), (trm2, message2)) -> issue-tuple
    where
      <origin-equal(|trm1)> trm2 <+
      <origin-equal(|trm2)> trm1
    where
      <equal> (message1, message2) <+ //unreliable because message may contain the string represenatation of the (changed) term
      <equal> (<has-annos; get-annos> trm1, <get-annos> trm2) //more reliable would be an annotation that indicates the error type
}

create-analysis-multifile =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "analysis-multifile.generated.str")>
"/** 
* This module contains analysis functions for refactorings that affect multiple files.
*/
module lib-refactoring/analysis-multifile.generated

imports
  lib/index-library.generated
  lib/analysis-library-internal.generated
  lib/editor-common.generated


rules //multifile name analysis

  /**
   * (Re)analyzes a set of ASTs. 
   * @see multifile-analyze-asts-internal(|language, project-path)
   *
   * @type List(ast) -> List(ast)
   */
  multifile-analyze-asts:
    asts -> asts-analyzed
    where
      asts-analyzed := <
        topdown(strip-annos);
        map(!(<id>, <origin-file>));
        multifile-analyze-asts-internal(|<language>, <project-path>)
      > asts

  /**
   * Analyzes a set of ASTs that are possible changed together in one operation.
   * The multifile analysis makes sure that all definitions are looked up from the ASTs in the set
   * instead of from the file system (represented by the current semantic index) which may contain the 
   * old version before the multifile change operation (refactoring) applied.
   * The analysis annotates definition and use sites found in the ASTs with URIs.
   *
   * Remark: The new analysis results are commited to the index.
   * TODO: The Spoofax refactoring class takes care of index rollback in case the refactoring is aborted
   * TODO: The Spoofax refactoring class implements reschedule analysis of changed files 
   * in case the refactoring is commited.
   *
   * @param language      The name of the language that is being analysed.
   * @param project-path  The path of the directory that contains all the source files.
   * @type List(ast, file) -> List(ast) REMARK: full-path file names are used.
   */
  multifile-analyze-asts-internal(|language, project-path):
    astFilePaths -> asts
    with
      <map(index-setup(|language, [project-path], <Snd>))> astFilePaths;
      <map(Snd; index-clear-file)> astFilePaths
    with
      {| Index-UnresolvedSet:
        unresolvedSet := <new-iset>;
        rules(Index-UnresolvedSet: _ -> unresolvedSet);
        astFilePairs := <map(!(<Fst>, (<Snd>, [])))> astFilePaths;
        (astFilePairs2, _) := <unzip> <map(analyze-top-defs)> astFilePairs;
        (astFilePairs3, _) := <unzip> <map(analyze-top-data(|language, <{path: ((_, (path, _)) -> path)}>))> astFilePairs2;
        (astFilePairs4, _) := <unzip> <map(analyze-top-uses(|language, <{path: ((_, (path, _)) -> path)}>))> astFilePairs3;
        (asts, _) := <unzip> astFilePairs4
      |}
    with
      <list-loop(analyze-top-store-ast(|<{path: ((_, (path, _)) -> path)}>))> astFilePairs4"

create-refactoring-files =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "files.generated.str")>
"/** 
* Functions to find and parse files
*/
module lib-refactoring/files.generated

imports
  lib/editor-common.generated
  lib/analysis-library.generated
  lib/index-library.generated

rules //parse files

  /**
   * Parses the file (project relative path) or reports an error ('file not found' or 'syntax errors')
   *
   * @type List(String) -> (List(ast), List(String)
   */
  files-to-asts:
    files -> <partition(parse-file, file-to-error-message)> files

  //@internal
  //constructs an error message for a file that can not be parsed
  file-to-error-message:
    file -> error-message
    where
      if <file-exists> file then
        error-message := $['[file]' can not be parsed because of syntax errors.]
      else
        error-message := $['[file]' can not be found.]
      end


rules //collect dependent files

  /**
   * Returns all files that contain Defs, Uses or Reads of the construct with the given URI
   *
   * @type String{[uri]} -> List(String)
   */
  files-with-references-to-uri:
    annotated-name -> <conc; make-set> (files-with-accesses, files-with-definition)
    where
      files-with-accesses := <files-with-accesses-to-uri> annotated-name; 
      files-with-definition := <files-with-definition-of-uri> annotated-name

  /**
   * Returns all files that contain Uses or Reads of the construct with the given URI
   *
   * @type String{[uri]} -> List(String)
   */
  files-with-accesses-to-uri:
    annotated-name -> project-relative-paths
    where
        project-relative-paths := <
          index-get-dependent-files;
          index-filepairs-to-files
        > [annotated-name]

  /**
   * Returns all files that contain Defs of the construct with the given URI
   *
   * @type String{[uri]} -> List(String)
   */
  files-with-definition-of-uri:
    annotated-name -> project-relative-paths
    where
        defsite := <index-lookup> annotated-name;
        project-relative-paths := <
          index-get-referenced-files(![defsite]);
          index-filepairs-to-files
        > [annotated-name]

  /**
   * Returns all files that contain an identifier with the given name (given as String, NOT as uri)
   *
   * @type String -> List(String)
   */
  files-with-terms-of-name:
    name -> <
      index-get-all-files; 
      filter(file-has-term-of-name(|name)); 
      index-filepairs-to-files
    >

  /**
   * Says whether a file contains an identifier with the given name (given as String, NOT as uri)
   *
   * @internal
   * @param String
   * @type String -> String
   */
  file-has-term-of-name(|name):
    filename -> filename
    where
      index-get-all-in-file; 
      fetch(?Use([_, name | _]) <+ ?BadUse([_, name | _]) <+ ?Def([_, name | _]) <+ ?Read([_, name | _]))"
      
create-rename-refactoring =
try(<file-exists <+ mkdir> "lib-refactoring");
<output-text-file(|["lib-refactoring"], "rename-refactoring.generated.str")>
${/** 
* Language generic Rename refactoring
*/
module lib-refactoring/rename-refactoring.generated

imports
  lib-refactoring/analysis-multifile.generated
  lib-refactoring/behavior-preservation.generated
  lib-refactoring/files.generated
  lib/nbl-library.generated
  lib/index-library.generated
  lib/editor-common.generated

rules //generic rename refactoring

  /**
   * Implements a multifile rename refactoring based on the semantic index.
   * Renames the definition and use sites of the selected identifier, and
   * reports errors end warnings for name binding violations or semantic correctness violations.
   *
   * @type (String, String (annotated with uri), List(Int), AST, String, String) -> 
   * (List(Tuple(AST, AST)), List(Tuple(T,String)), List(Tuple(T,String) or String), List(Tuple(T,String)))
   * @param AST -> AST 
   * @param T -> Tuple(T, String) 
   * @param T -> Tuple(T, String)
   */
  generic-rename-refactoring(desugar, s-constraint-error, s-constraint-warning):
    (newname, oldname, position, ast, path, project-path) -> (ast-change-tuples, [], all-errors, warnings)
    where
      index-setup(|<language>, [project-path], ".");

      //Get analyzed asts of all files that contain oldname + uri identifiers 
      files-related-oldname := <files-with-references-to-uri; filter(not(?path))> oldname; //files that have changes
      (asts-related-oldname, file-errors-1) := <files-to-asts> files-related-oldname;
      asts-before := [ast | <map(desugar); multifile-analyze-asts> asts-related-oldname];

      //Apply renaming transformation on ASTs with oldname + uri identifiers
      //Construct change list that forms the result of the refactoring
      asts-after := <alltd(preserve-annos((oldname -> newname)))> asts-before;
      ast-change-tuples := <zip> (asts-before, asts-after);

      //Get analyzed asts of all files that may be involved in name collisions.
      files-containing-newname := <files-with-terms-of-name> newname; 
      files-to-check-newname := <diff> (files-containing-newname, [path|files-related-oldname]); 
      (asts-to-check-newname, file-errors-2) := <files-to-asts> files-to-check-newname;
      asts-to-check-newname-analyzed :=  <map(desugar); multifile-analyze-asts> asts-to-check-newname; 
      (errors, warnings) := <semantic-violation-errors(s-constraint-error <+ constraint-error, s-constraint-warning|[newname, oldname])> (
         <conc> (asts-before, asts-to-check-newname-analyzed), 
         <conc> (asts-after,  asts-to-check-newname-analyzed)
      );
       
      //all errors
      all-errors := <concat> [file-errors-1, file-errors-2, errors];
      
      //reanalyze (possible) changed files TODO: in Spoofax component?
      <map(origin-file); queue-analysis> asts-after
}
