module sdf2imp/project/create-runtime-libraries

imports
  sdf2imp/util/-

strategies
  
  create-analysis-analysis = 
    <output-text-file(|["lib", "runtime", "analysis"], "analysis.str")>
"module runtime/analysis/analysis

imports
  
  libstratego-lib
  
  runtime/analysis/-
  runtime/index/-
  runtime/nabl/-
  runtime/properties/-
  runtime/relations/-
  runtime/task/-
  runtime/types/-

"

  create-analysis-builtins = 
    <output-text-file(|["lib", "runtime", "analysis"], "builtins.str")>
"module runtime/analysis/builtins

imports
  
  runtime/analysis/core
  runtime/analysis/interface
  
rules

  analysis-analyze-builtin-partitions(collector|language, project-path) =
    analysis-get-builtin-partitions; map(analysis-analyze-builtin-partition(collector|language, project-path))  

  analysis-get-builtin-partitions =
    analysis-builtin-partitions <+ ![]

  analysis-analyze-builtin-partition(collector|language, project-path):
    (path, ast) -> analyzed-ast
    with
      partition := <analysis-partition(|project-path)> path
    ; Result([FileResult(_, _, _, _, analyzed-ast, _, _, _)], _, _, _) := 
        <analysis-files-no-builtins(id, collector, id, id, id, id|language, project-path)> [File(partition, ast, 0.0)]

"

  create-analysis-complete = 
    <output-text-file(|["lib", "runtime", "analysis"], "complete.str")>
"module runtime/analysis/complete

imports
  
  runtime/nabl/complete
  runtime/task/core
  runtime/index/core
  
rules
  
  analysis-propose-completions(|language, project-path):
    ast -> <nabl-propose-completions> ast
    with
      task-setup(|project-path);
      index-setup(|language, project-path)

"

  create-analysis-core = 
    <output-text-file(|["lib", "runtime", "analysis"], "core.str")>
"module runtime/analysis/core

imports
  
  runtime/analysis/builtins
  runtime/analysis/legacy
  runtime/analysis/interface
  runtime/nabl/collect
  runtime/nabl/uri
  runtime/nabl/incremental
  runtime/relations/incremental
  runtime/index/core
  runtime/task/core
  runtime/task/messages
  runtime/editor/origins
  runtime/editor/editor
  runtime/editor/queue
  runtime/editor/dynrule
  runtime/editor/time
  runtime/nabl/utils
  
signature

  constructors
  
    // File(partition, initial-ast, parse-time)
    File : String * Term * Int -> File
    // File(partition, initial-ast, transformed-ast, parse-time)
    File : String * Term * Term * Int -> File
    
    // Result(file-result*, affected-source*, debug-result, time-result)
    Result : List(FileResult) * List(String) * DebugResult * TimeResult -> Result
    
    // FileResult(language, project-path, partition, initial-ast, analyzed-ast, error*, warning*, note*)
    FileResult : String * String * String * Term * Term * List(Term) * List(Term) * List(Term) -> FileResult
    
    // CollectDebugResult(removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count)
    CollectDebugResult : Int * Int * Int * Int * Int -> CollectDebugResult
    
    // DebugResult(collect-debug-result, evaluated-task*, skipped-task*, unevaluated-task*)
    DebugResult : CollectDebugResult * List(TaskID) * List(TaskID) * List(TaskID) -> DebugResult
    
    // TimeResult(parse-time, pre-trans-time, collect-time, perform-time, post-trans-time, index-persist-time, task-persist-time)
    TimeResult : Real * Real * Real * Real * Real * Real * Real -> TimeResult

rules // Interface
  
  analysis-spoofax = (is-list; queue-strategy(|\"analysis-interface\", \"Analyzing files\")) <+ analysis-interface
  analysis-cmd = analysis-interface
  
  
  analysis-top(parse-file, pre-trans, post-trans, pp-message|language, project-path) = 
    analysis-top(parse-file, pre-trans, nabl-collect, post-trans, pp-message|language, project-path)
  
  analysis-top(parse-file, pre-trans, collector, post-trans, pp-message|language, project-path):
    input -> <analysis-files(pre-trans, collector, post-trans, pp-message|language, project-path)>
    where
      <is-list; map(?File(_, _, _))> input
  
  analysis-top(parse-file, pre-trans, collector, post-trans, pp-message|language, project-path):
    input -> <analysis-files-spoofax(parse-file, pre-trans, collector, post-trans, pp-message|language, project-path)>
    where
      <is-tuple <+ (is-list; map(is-string))> input

rules // Core multi-file analysis that takes File/3 appls, analyzes those files, and returns a Result/4.
  
  analysis-files(pre-trans, post-trans, pp-message|language, project-path) = 
    analysis-files(pre-trans, nabl-collect, post-trans, pp-message|language, project-path)
    
  analysis-files(pre-trans, collector, post-trans, pp-message|language, project-path) =
    where(analysis-analyze-builtin-partitions(collector|language, project-path))
  ; analysis-files-no-builtins(pre-trans, collector, post-trans, pp-message, id, id|language, project-path)
    
  analysis-files-no-builtins(pre-trans, collector, post-trans, pp-message, try-recover, should-setup|language, project-path):
    file* -> Result(
      post-trans-result*
    , affected-source*
    , debug-result
    , TimeResult(parse-time, pre-trans-time, collect-time, evaluate-time, post-trans-time, index-persist-time, task-persist-time)
    )
    with
      total-progress := <analysis-files-total-progress> file*
    ; <analysis-set-progress> total-progress
    with
      parse-time := <map(?File(_, _, <id>)); foldr(!0.0, addr)> file*
    ; measure-time(
        pre-trans-file* := <map(analysis-files-pre-trans(pre-trans); analysis-inc-progress(|total-progress))> file*
      , ?pre-trans-time
      )
    ; try(should-setup; index-setup(|language, project-path))
    ; try(try-recover; index-recover)
    ; try(should-setup; task-setup(|project-path))
    ; try(try-recover; task-recover)
    ; measure-time(
        collect-result* := <map(analysis-collect(collector|language, project-path); analysis-inc-progress(|total-progress))> pre-trans-file*
      , ?collect-time
      )
    ; (result*, collect-debug-result*) := <unzip> collect-result*
    ; measure-time(
        task-evaluate-scheduled => (evaluated-task*, skipped-task*, unevaluated-task*)
      ; <map(analysis-collect-legacy-messages)> result*
      , ?evaluate-time
      )
    ; analysis-inc-progress(|total-progress)
    ; task-sources-of(|evaluated-task*) => affected-source*
    ; messages-result* := <map(analysis-add-messages(pp-message))> result*
    ; measure-time(
        post-trans-result* := <map(analysis-files-post-trans(post-trans))> messages-result*
      , ?post-trans-time
    )
    ; collect-acc-debug-result := <analysis-accumulate-collect-debug-results> collect-debug-result*
    with
      (
        analysis-disable-persist; 
        index-persist-time := 0.0;
        task-persist-time := 0.0
      )
      <+
      (
        measure-time(index-persist, ?index-persist-time)
      ; measure-time(task-persist, ?task-persist-time)
      )
    with
      debug-result := DebugResult(collect-acc-debug-result, evaluated-task*, skipped-task*, unevaluated-task*)
    ; <analysis-debug-results> debug-result
      
  analysis-files-pre-trans(pre-transform):
    File(path, ast, parse-time) -> File(path, ast, <analysis-pre-trans <+ pre-transform> ast, parse-time)
    
  analysis-files-post-trans(post-trans):
    FileResult(language, project-path, partition, initial-ast, analyzed-ast, error* , warning*, note*) ->
    FileResult(language, project-path, partition, initial-ast, analyzed-transformed-ast, error*, warning* , note*)
    where
      analyzed-transformed-ast := <analysis-post-trans(|partition) <+ post-trans> analyzed-ast
      // TODO: This might destroy origins, such that setting error markers in another file may not work??
      
  analysis-files-total-progress:
    file* -> <add> (<mul> (<length> file*, 2), 1)

rules // Common
  
  analysis-collect(collector|language, project-path):
    File(partition, initial-ast, transformed-ast, _) -> ( 
      FileResult(language, project-path, partition, initial-ast, analyzed-ast, [], [], [])
    , CollectDebugResult(<length> removed-entry*, <length> added-entry*, <length> removed-task*, <length> added-task*, <length> invalidated-task*)
    )
    with
      index-start-collection(|partition);
      task-start-collection(|partition);

      analyzed-ast := <collector(id|Language(language), partition, <new-hashtable>, [])> transformed-ast;

      index-stop-collection(|partition) => (removed-entry*, added-entry*);
      task-stop-collection(|partition)  => (removed-task*, added-task*);
      
      change*            := [removed-entry*, added-entry*];
      nabl-changed-read* := <nabl-get-changed-reads> change*;
      rel-changed-read*  := <relation-get-changed-reads> change*;
      changed-read*      := [nabl-changed-read*, rel-changed-read*];

      task-invalidate-task-reads(|changed-read*) => invalidated-task*


  analysis-add-messages(pp-message):
    FileResult(language, project-path, partition, initial-ast, analyzed-ast, _, _, _) -> 
    FileResult(language, project-path, partition, initial-ast, analyzed-ast, error*, warning*, note*)
    with
      (error*, warning*, note*) := <analysis-get-messages(pp-message)> partition

  analysis-get-messages(pp-message):
    partition -> (error*, warning*, note*)
    with
      task-message*   := <task-get-messages(|partition)>;
      legacy-message* := <analysis-get-legacy-messages(|partition)>;
      message* := [task-message*, legacy-message*];
      error*   := <filter(?Error(_, _, _); analysis-message-to-tuple; pp-message)> message*;
      warning* := <filter(?Warning(_, _, _); analysis-message-to-tuple; pp-message)> message*;
      note*    := <filter(?Note(_, _, _); analysis-message-to-tuple; pp-message)> message*
      
  analysis-message-to-tuple:
    message -> (<origin-location-offset-set(|origin)> term, msg)
    with
      origin := <task-message-origin> message;
      term   := <task-message-term> message;
      msg    := <task-message> message
      
      
  analysis-accumulate-collect-debug-results:
    debug-result* -> <foldl(analysis-concat-debug-result)> (debug-result*, CollectDebugResult(0, 0, 0, 0, 0))
      
  analysis-concat-debug-result:
    (
      CollectDebugResult(removed-entry1-count, added-entry1-count, removed-task1-count, added-task1-count, invalidated-task1-count)
    , CollectDebugResult(removed-entry2-count, added-entry2-count, removed-task2-count, added-task2-count, invalidated-task2-count)
    )
    ->
    CollectDebugResult(removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count)
    with
      removed-entry-count    := <add> (removed-entry1-count, removed-entry2-count);
      added-entry-count      := <add> (added-entry1-count, added-entry2-count);
      removed-task-count     := <add> (removed-task1-count, removed-task2-count);
      added-task-count       := <add> (added-task1-count, added-task2-count);
      invalidated-task-count := <add> (invalidated-task1-count, invalidated-task2-count)
      
rules // Spoofax Eclipse interfacing
  
  analysis-files-spoofax(parse-file, pre-trans, post-trans, pp-message|language, project-path) = 
    analysis-files-spoofax(parse-file, pre-trans, nabl-collect, post-trans, pp-message|language, project-path)
    
  analysis-files-spoofax(parse-file, pre-trans, collector, post-trans, pp-message|language, project-path):
    input -> output
    with
      file*  := <analysis-spoofax-to-files(parse-file|project-path)> input
    ; result := <analysis-files(pre-trans, collector, post-trans, pp-message|language, project-path)> file*
    ; output := <analysis-spoofax-output(pp-message)> result

  analysis-spoofax-to-files(parse-file|project-path):
    (ast, path, _) -> [File(<analysis-partition(|project-path)> path, ast, -1.0)]
    
  analysis-spoofax-to-files(parse-file|project-path):
    path* -> file*
    where
      <is-list> path*
    with
      file* := <map(analysis-partition(|project-path); analyze-parse-file(parse-file))> path*
      
  analyze-parse-file(parse-file):
    path -> File(path, ast, parse-time)
    with
      if not(measure-time(ast := <file-exists; parse-file> path, ?parse-time)) then
        ast := ()
      ; parse-time := -1.0
      end
  
    
  analysis-spoofax-output(pp-message):
    Result(file-result*, affected-source*, _, _) -> (analyzed-ast, error*, warning*, note*)
    where
      <not(Tl; Tl)> file-result*
    with
      FileResult(_, _, partition, _, analyzed-ast, error*, warning*, note*) := <Hd> file-result*
    ; changed-partition* := <filter(analysis-spoofax-updatable-partition(|[partition]))> affected-source*
    ; <map(analysis-spoofax-update-file(pp-message))> changed-partition*
    
  analysis-spoofax-output(pp-message):
    result@Result(file-result*, affected-source*, _, _) -> result
    where
       <Tl; Tl> file-result*
    with
      <map(analysis-spoofax-update-file-from-result)> file-result*
    ; analyzed-partition* := <map(analysis-file-result-partition)> file-result*
    ; changed-partition* := <filter(analysis-spoofax-updatable-partition(|analyzed-partition*))> affected-source*
    ; <map(analysis-spoofax-update-file(pp-message))> changed-partition*
  

  analysis-spoofax-update-file(pp-message):
    partition -> <analysis-get-messages(pp-message); set-only-markers(|partition)> partition

  analysis-spoofax-update-file-from-result:
    FileResult(_, _, partition, initial-ast, analyzed-ast, error*, warning*, note*) -> None()
    with
      <set-markers(|partition)> (analyzed-ast, error*, warning*, note*)


  analysis-spoofax-updatable-partition = is-string; not(string-ends-with(|\".spt\"))
  analysis-spoofax-updatable-partition(|partition*):
    partition -> <analysis-spoofax-updatable-partition> partition
    where
      <not(fetch(?partition))> partition*

rules // Utility
  
  analysis-partition(|project-path):
    path -> $[[project-path]/[path]]
  
  analysis-file-result-partition:
    FileResult(_, _, partition, _, _, _, _, _) -> partition
    
  analysis-set-progress = try(where(<gt> (<id>, 0)); set-total-work-units)
  analysis-inc-progress(|total-size) = where(try(<gt> (total-size, 0); complete-work-unit))
    
rules // Debugging
  
  analysis-debug(msg) = try(analysis-debug-interface(msg))
  analysis-debug = try(analysis-debug-interface)
  analysis-debug-interface(msg) = fail
  analysis-debug-interface = fail
  
  analysis-debug-results:
    DebugResult(CollectDebugResult(removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count), evaluated-task*, skipped-task*, unevaluated-task*) -> <id>
    with
      <analysis-debug> $[Entries : [removed-entry-count] removed, [added-entry-count] added.];
      <analysis-debug> $[Tasks   : [removed-task-count] removed, [added-task-count] added, [invalidated-task-count] invalidated, [<length> evaluated-task*] evaluated, [<length> skipped-task*] skipped, [<length> unevaluated-task*] unevaluated.];
      <map(task-debug-info(|<id>); analysis-debug(!\"Unevaluated: \"))> unevaluated-task* 
  
"

  create-analysis-debug = 
    <output-text-file(|["lib", "runtime", "analysis"], "debug.str")>
"module runtime/analysis/debug

imports
  
  runtime/index/core
  runtime/index/query
  runtime/task/core
  runtime/task/debug
  runtime/task/insert
  runtime/editor/interop
  runtime/nabl/entries
  runtime/nabl/uri

rules // Index
   
  analysis-debug-show-all-partitions(|language) = analysis-debug-index-project(|language)
  analysis-debug-show-current-partition(|language) = analysis-debug-index-partition(|language)
   
  analysis-debug-index-project(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      result-ast := <index-get-all-sources; map(\\f -> (f, <index-get-all-pairs-in-source> f)\\)>;
      if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast then
        filename := $[[project-path]/[<dirname> path]/project.index];
        result   := result-index
      else
        filename := $[[project-path]/[<dirname> path]/index.project.aterm];
        result   := result-ast
      end
      
  analysis-debug-index-project-resolve(|language):
  (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      task-setup(|project-path);
      result-ast := <index-get-all-sources; map(\\f -> (f, <index-get-all-pairs-in-source> f)\\)>;
      result-ast' := <beautify-indices> result-ast;
    if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast' then
    filename := $[[project-path]/[<dirname> path]/project.index];
    result   := result-index
    else
    filename := $[[project-path]/[<dirname> path]/index.project.aterm];
    result   := result-ast'
    end
   
  analysis-debug-index-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      partition  := $[[project-path]/[path]];
      result-ast := [(partition, <index-get-all-pairs-in-source> partition)];
      if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast then
        filename := <guarantee-extension(|\"partition.index\")> path;
        result   := result-index
      else
        filename := <guarantee-extension(|\"index.partition.aterm\")> path;
        result   := result-ast
      end
      
  analysis-debug-index-partition-resolve(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      task-setup(|project-path);
      partition  := $[[project-path]/[path]];
      result-ast := [((partition, []), <index-get-all-pairs-in-source> partition)];
      result-ast' := <beautify-indices> result-ast;
      if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast' then
        filename := <guarantee-extension(|\"partition.index\")> path;
        result   := result-index
      else
        filename := <guarantee-extension(|\"index.partition.aterm\")> path;
        result   := result-ast'
      end
  
rules // Task engine    
      
  analysis-debug-show-tasks(|language) = analysis-debug-task-partition(|language)
  analysis-debug-show-tasks-selection(|language) = analysis-debug-task-selection(|language)

  analysis-debug-task-project(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      task-setup(|project-path);
      result-ast := <task-debug-info(|())>;
      if result-task := <foreign-call(|\"Analysis\", \"from-task-debug-str\")> result-ast then
        filename := $[[project-path]/[<dirname> path]/project.task];
        result   := result-task
      else
        filename := $[[project-path]/[<dirname> path]/task.project.aterm];
        result   := result-ast
      end
      
  analysis-debug-task-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      task-setup(|project-path);
      partition  := $[[project-path]/[path]];
      result-ast := <task-debug-info(|partition)>;
      if result-task := <foreign-call(|\"Analysis\", \"from-task-debug-str\")> result-ast then
        filename := <guarantee-extension(|\"partition.task\")> path;
        result   := result-task
      else
        filename := <guarantee-extension(|\"task.partition.aterm\")> path;
        result   := result-ast
      end
      
  analysis-debug-task-selection(|language):
    (selected, _, _, path, project-path) -> (filename, result)
    with
      task-setup(|project-path);
      partition  := $[[project-path]/[path]];
      result-ast := <task-debug-ast> selected;
      if result-task := <foreign-call(|\"Analysis\", \"from-task-debug-str\")> result-ast then
        filename := <guarantee-extension(|\"selection.task\")> path;
        result   := result-task
      else
        filename := <guarantee-extension(|\"task.selection.aterm\")> path;
        result   := result-ast
      end
      
rules // Index & task engine
  
  analysis-debug-project(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      task-setup(|project-path);
      task-debug  := <task-debug-info(|())>;
      index-debug := <index-get-all-sources; map(\\f -> (f, <index-get-all-pairs-in-source; sort-index> f)\\)>;
      result-ast  := (task-debug, index-debug);
      if result-analysis := <foreign-call(|\"Analysis\", \"from-debug-str\")> result-ast then
        filename := $[[project-path]/[<dirname> path]/project.analysis];
        result   := result-analysis
      else
        filename := $[[project-path]/[<dirname> path]/analysis.project.aterm];
        result   := result-ast
      end
      
  analysis-debug-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      task-setup(|project-path);
      partition   := $[[project-path]/[path]];
      task-debug  := <task-debug-info(|partition)>;
      index-debug := [(partition, <index-get-all-pairs-in-source; sort-index> partition)];
      result-ast  := (task-debug, index-debug);
      if result-analysis := <foreign-call(|\"Analysis\", \"from-debug-str\")> result-ast then
        filename := <guarantee-extension(|\"partition.analysis\")> path;
        result   := result-analysis
      else
        filename := <guarantee-extension(|\"partition.aterm\")> path;
        result   := result-ast
      end
   
rules // Resetting  
      
  analysis-debug-reset-index(|language):
    (_, _, _, path, project-path) -> None()
    with
      partition := $[[project-path]/[path]];
      index-setup(|language, project-path);
      index-reset
      
  analysis-debug-reset-task(|language):
    (_, _, _, path, project-path) -> None()
    with
      task-setup(|project-path);
      task-reset

  analysis-debug-reanalyze(|language):
    (_, _, _, path, project-path) -> None()
    with
      partition := $[[project-path]/[path]];
      task-setup(|project-path);
      task-reset;
      index-setup(|language, project-path);
      index-reload

rules // Helper rules for Index Resolved

  beautify-indices: indices -> indices''
    where
      indices'  := <filter(ignore-extension)> indices;
      indices'' := <map(beautify-index)>indices'
    
  beautify-index: (partition, index) -> (partition, index4)
    where
      index2 := <give-all-tasks-results>index;
      index3 := <reverse-uris> index2;
      index4 := <sort-index> index3

  // ignore partitions of generated files
  ignore-extensions: _ -> [\"index\", \"analysis\", \"task\"]
  ignore-extension: (partition, index) -> (partition, index)
    where
      (path, _) := partition;
      extension := <get-extension>path;
      <not(elem)> (extension, <ignore-extensions>)
  
  // resolve all task results
  give-all-tasks-results = bottomup(try(give-task-results))
  give-task-results: e@Result(_) -> <insert-results-or-delay <+ with(fail|\"Task has no result yet: \")>e
  
  sort-index = qsort(index-compare)
  
  // order the index entries
  index-ordering: _ -> [\"Def\",\"Prop\",\"RelTuple\",\"Alias\",\"InverseAlias\",\"Use\"]

  index-compare: ((a, _), (b, _)) -> <id>
    where
      a-order := <get-index> (<get-constructor>a, <index-ordering>);
      b-order := <get-index> (<get-constructor>b, <index-ordering>);
      if <eq>(a-order, b-order) then
        if Use(_) := a then
          Use([Def(URI(_, a-url))]) := a;
          Use([Def(URI(_, b-url))]) := b
        else
          [URI(_, a-url)|_] := <get-arguments>a;
          [URI(_, b-url)|_] := <get-arguments>b
        end;
        <uri-compare> (a-url, b-url)
      else
        cmp-o := <lt>(a-order, b-order)
      end
  
  uri-compare: ([], []) -> <fail>
  uri-compare: (a, []) -> <fail>
  uri-compare: ([], b) -> ([], b)
  uri-compare: ([a|as], [b|bs]) -> ([a|as], [b|bs]) 
    where
      ID(a-namespace, a-name, _) := a;
      ID(b-namespace, b-name, _) := b;
      if <eq>(a-namespace, b-namespace) then
        if <eq>(a-name, b-name) then
          <uri-compare> (as, bs)
        else
          <string-lt>(a-name, b-name)
        end
      else
        <string-lt>(<get-constructor>a-namespace, <get-constructor>b-namespace)
      end
      
  // reverse URIs (for having urls in the right order, and for ordering as tree)
  reverse-uris = bottomup(try(reverse-uri))
  reverse-uri: URI(language, uri) -> URI(language, <reverse>uri)

"

  create-analysis-defaults = 
    <output-text-file(|["lib", "runtime", "analysis"], "defaults.str")>
"module runtime/analysis/defaults

rules // Empty file to clear previous definitions

"

  create-analysis-interface = 
    <output-text-file(|["lib", "runtime", "analysis"], "interface.str")>
"module runtime/analysis/interface

rules

  analysis-interface = fail
  
  analysis-pre-trans = fail
  analysis-post-trans(|ctx) = fail
  
  analysis-disable-persist = fail
  
  analysis-builtin-partitions = fail
  
"

  create-analysis-legacy = 
    <output-text-file(|["lib", "runtime", "analysis"], "legacy.str")>
"module runtime/analysis/legacy

imports
  
  runtime/analysis/core
  runtime/analysis/save
  runtime/analysis/complete
  runtime/analysis/resolve
  runtime/editor/eclipse
  runtime/editor/queue
  runtime/index/core
  runtime/task/core
  runtime/nabl/collect
  runtime/task/messages
  runtime/task/core
  
rules // Interface
  
  analysis-single-default-interface = fail
  analysis-multiple-default-interface = fail
  
  constraint-error = fail
  constraint-warning = fail
  constraint-note = fail
  
rules // Analysis
  
  analysis-default-editor = 
    (where(is-tuple); analysis-single-default-interface) <+ 
    queue-strategy(|\"analysis-multiple-default-interface\", \"Analyzing files (legacy)\")
  analysis-default-cmd = 
    analysis-multiple-default-interface
  analysis-cmd = 
    analysis-multiple-default-interface
    
  // Called by only by Spoofax.
  analysis-single-default(pre-trans, post-trans, pp-message|language) = 
    analysis-single-default(pre-trans, nabl-collect, post-trans, pp-message|language)
  analysis-single-default(pre-trans, collector, post-trans, pp-message|language) = 
    analysis-files-spoofax(fail, pre-trans, post-trans, pp-message|language, <project-path>)
  
  // Called by Spoofax and Sunshine, let analysis-top choose the correct strategy based on input.
  analysis-multiple-default(parse-file, pre-trans, post-trans, pp-message|language, project-path) = 
    analysis-top(parse-file, pre-trans, nabl-collect, post-trans, pp-message|language, project-path)
  analysis-multiple-default(parse-file, pre-trans, collector, post-trans, pp-message|language, project-path) = 
    analysis-top(parse-file, pre-trans, post-trans, pp-message|language, project-path)
  
rules // Other services
  
  analysis-save-default(|language) = analysis-spoofax-save(|language)
  analysis-propose-completions(|language, project-path, path) = analysis-propose-completions(|language, project-path)
  analysis-resolve(|language, project-path, path) = analysis-resolve(|language, project-path)

rules // Messages
  
  analysis-get-legacy-messages(|source) = task-get-messages(|$[[source]_legacy])
  
  analysis-collect-legacy-messages:
    result@FileResult(_, _, source, _, ast, _, _, _) -> result
    with
      error-tuple*   := <collect-all(constraint-error); flatten-list> ast
    ; warning-tuple* := <collect-all(constraint-warning); flatten-list> ast
    ; note-tuple*    := <collect-all(constraint-note); flatten-list> ast
    ; if <Tl> error-tuple* <+ <Tl> warning-tuple* <+ <Tl> note-tuple* then
        legacy-source  := $[[source]_legacy]
      ; task-start-collection(|legacy-source)
      ; error*   := <filter(analysis-legacy-convert-error(|legacy-source))> error-tuple*
      ; warning* := <filter(analysis-legacy-convert-warning(|legacy-source))> warning-tuple*
      ; note*    := <filter(analysis-legacy-convert-note(|legacy-source))> note-tuple*
      ; task-stop-collection(|legacy-source)
      ; <task-evaluate-now> [error*, warning*, note*]
    end

  analysis-legacy-convert-error(|source):
    (term, message) -> <task-create-error(|source, message); task-result-id> term
    
  analysis-legacy-convert-warning(|source):
    (term, message) -> <task-create-warning(|source, message); task-result-id> term
    
  analysis-legacy-convert-note(|source):
    (term, message) -> <task-create-note(|source, message); task-result-id> term

"

  create-analysis-multiple = 
    <output-text-file(|["lib", "runtime", "analysis"], "multiple.str")>
"module runtime/analysis/multiple

rules // Empty file to clear previous definitions

"

  create-analysis-reanalysis = 
    <output-text-file(|["lib", "runtime", "analysis"], "reanalysis.str")>
"module runtime/analysis/reanalysis

imports
  
  runtime/analysis/core
  runtime/task/core
  runtime/index/core
  runtime/nabl/collect
  runtime/nabl/namegen
  runtime/properties/collect

rules
  
  start-reanalysis(|language, path, project-path) =
    nabl-namegen-clear(|<analysis-partition(|project-path)> path);
    index-push;
    task-push
    
  stop-reanalysis(|language, path, project-path) =
    task-pop;
    index-pop
  
  reanalysis(s|language, path, project-path) =
    where(start-reanalysis(|language, path, project-path); s; stop-reanalysis(|language, path, project-path))
  
  reanalyze-ast(|language, path, project-path):
    ast -> analyzed-ast
    with
      property-kind* := <nabl-get-all-properties>
    ; ast' := <topdown(try(remove-property-annotations(|property-kind*)))> ast
    ; partition := <analysis-partition(|project-path)> path
    ; Result([FileResult(_, _, _, _, analyzed-ast, error*, warning*, note*)], _, debug-result, _) := 
        <analysis-files-no-builtins(id, nabl-collect, id, id, fail, fail|language, project-path)> [File(partition, ast, 0.0)]
    ; <analysis-debug-results> debug-result  
    ; <map(analysis-debug(!\"Error: \"))> error*
    ; <map(analysis-debug(!\"Warning: \"))> warning*
    ; <map(analysis-debug(!\"Note: \"))> note*

"

  create-analysis-resolve = 
    <output-text-file(|["lib", "runtime", "analysis"], "resolve.str")>
"module runtime/analysis/resolve

imports
  
  runtime/nabl/resolve
  runtime/nabl/entries
  runtime/task/core
  runtime/index/core
  runtime/index/query
  
rules
  
  analysis-resolve(|language, project-path):
    node -> definition'
    where
      task-setup(|project-path);
      index-setup(|language, project-path);
      definition  := <has-annos; get-annos; fetch-elem(?Use(<id>)); task-get-results; Hd> node;
      definition' := <index-get-one-value> definition // Get definition from index again to get updated origin location.

"

  create-analysis-save = 
    <output-text-file(|["lib", "runtime", "analysis"], "save.str")>
"module runtime/analysis/save

imports
  
  runtime/index/core
  runtime/task/core
  
rules
  
  analysis-spoofax-save(|language):
    (_, _, _, _, project-path) -> None()
    with
      index-setup(|language, project-path);
      index-persist;
      task-setup(|project-path);
      task-persist

"

  create-analysis-single = 
    <output-text-file(|["lib", "runtime", "analysis"], "single.str")>
"module runtime/analysis/single

rules // Empty file to clear previous definitions

"

  create-analysis-singleast = 
    <output-text-file(|["lib", "runtime", "analysis"], "singleast.str")>
"module singleast

imports
  
  runtime/analysis/core
  runtime/nabl/collect
  
rules
  
  analysis-singleast = analysis-singleast(nabl-collect|-1.0)
  analysis-singleast(collector|parse-time):
    ast -> (analyzed-ast, (error*, warning*, note*))
    with
      language     := \"Language\"
    ; path         := \"path\"
    ; project-path := \".\"
    ; partition := <analysis-partition(|project-path)> path
    ; Result([FileResult(_, _, _, _, analyzed-ast, error*, warning*, note*)], _, _, _) := 
        <analysis-files(id, id, id|language, project-path)> [File(partition, ast, parse-time)]

"

  create-editor-annotations = 
    <output-text-file(|["lib", "runtime", "editor"], "annotations.str")>
"module runtime/editor/annotations

imports
  
rules // TODO: does not belong to editor, move to a new 'utils' directory
  
  get-annotation(s) =
    has-annos;
    get-annos;
    collect-one(s)

  add-annotation(|a):
    t{a*} -> t{a, a*} where <not(is-list)> a
  
  add-annotations(|a'*):
    t{a*} -> t{a''*} where <is-list> a'*; a''* := [a'*, a*] 

  remove-annotations(s):
    t{a*} -> t{a'*}
    where
      a'* := <remove-all(s)> a*
      
  replace-annotation(s|a):
    t{a*} -> t{a, a'*}
    where
      a'* := <remove-all(s)> a*
      
  replace-annotations(s|a'*):
    t{a*} -> t{a'*, a''*}
    where
      a''* := <remove-all(s)> a*

  preserve-annotations-attachments(s) = prim(\"SSL_preserve_annotations_attachments\", s|)

"

  create-editor-dynrule = 
    <output-text-file(|["lib", "runtime", "editor"], "dynrule.str")>
"module runtime/editor/dynrule

rules
  
  editor-init =
    // Ensure all dynamic rules are properly scoped
    try(dr-scope-all-end);
    dr-scope-all-start

"

  create-editor-eclipse = 
    <output-text-file(|["lib", "runtime", "editor"], "eclipse.str")>
"module runtime/editor/eclipse

rules
  
  project-path = prim(\"SSL_EXT_projectpath\")
  
  plugin-path = prim(\"SSL_EXT_pluginpath\")
    
  refresh-workspace-file:
    path -> <prim(\"SSL_EXT_refreshresource\", path)>

"

  create-editor-editor = 
    <output-text-file(|["lib", "runtime", "editor"], "editor.str")>
"module runtime/editor/editor

imports
  
  libstratego-lib
  
  runtime/editor/-

"

  create-editor-interop = 
    <output-text-file(|["lib", "runtime", "editor"], "interop.str")>
"module runtime/editor/interop

rules
  
  foreign-call(|lang,strategy) = prim(\"SSL_EXT_foreigncall\", lang, strategy)

"

  create-editor-origins = 
    <output-text-file(|["lib", "runtime", "editor"], "origins.str")>
"module runtime/editor/origins

imports
  
  runtime/editor/eclipse

strategies
  
  origin-term      = prim(\"SSL_EXT_origin_term\", <id>) <+ origin-sublist-term
  origin-text      = origin-support-sublist(prim(\"SSL_EXT_origin_text\", <id>))
  origin-offset    = origin-support-sublist(prim(\"SSL_EXT_origin_offset\", <id>))
  origin-location  = prim(\"SSL_EXT_origin_location\", <id>)
  origin-line      = origin-location => (<id>, _, _, _)
  origin-column    = origin-location => (_, <id>, _, _)
  origin-file      = prim(\"SSL_EXT_origin_file\", <id>)
  origin-strip     = prim(\"SSL_EXT_origin_strip\", <id>)
  origin-equal(|t) = prim(\"SSL_EXT_origin_equal\", <id>, t)

  origin-location-offset = prim(\"SSL_EXT_origin_location_offset\", <id>)
  origin-location-offset-set(|origin-location-offset) = prim(\"SSL_EXT_set_origin_location_offset\", origin-location-offset)

  origin-language-description =
    prim(\"SSL_EXT_languagedescription\", <id>)

  origin-language =
    origin-file; 
    origin-language-description;
    Fst

  origin-track-forced(s) =
    ![<id>]; all(s); ?[<id>]

  origin-relative-path:
    trm -> rel-path
    where
      full-path := <origin-file> trm;
      len-project-prefix := <project-path; string-length; inc>;
      rel-path := <string-as-chars(drop(|len-project-prefix))> full-path

  origin-debug-all = topdown(try(origin-debug))
  origin-debug = where(debug(!$[[<(origin-offset; write-to-string) <+ !\"NO ORIGIN\">][\" \"]]))

strategies
  
  origin-term-desugared = prim(\"SSL_EXT_origin_term_desugared\", <id>)
  origin-term-fuzzy = prim(\"SSL_EXT_origin_term_fuzzy\", <id>)

  origin-indent = origin-support-sublist(prim(\"SSL_EXT_origin_indentation\", <id>))
  origin-separation = origin-support-sublist(prim(\"SSL_EXT_origin_separation\", <id>)) // only succeeds if list size >= 2 elems
  origin-layout-prefix = origin-support-sublist(prim(\"SSL_EXT_origin_layout_prefix\", <id>))
  layout-prefix = origin-layout-prefix <+ !\"\"
  
  origin-deletion-offset = 
    origin-support-sublist(prim(\"SSL_EXT_origin_deletion_offset\", <id>)); 
    !(<Fst>, <Snd; inc>) //exclusive end
  
  origin-start-offset = origin-offset; Fst
  origin-end-offset = origin-offset; Snd
  origin-deletion-start-offset = origin-deletion-offset; Fst 
  origin-deletion-end-offset = origin-deletion-offset; Snd
  origin-layout-prefix-start-offset = origin-insert-before-offset

  is-origin-term = <equal> (<origin-term>, <id>)
  is-origin-term-desugared = <equal> (<origin-term-desugared>, <id>)
  has-origin-term = where(origin-term)
  has-origin-sublist-term = where(origin-sublist-term)
  is-origin-sublist-term = <equal> (<origin-sublist-term>, <id>)

  origin-sublist-term = prim(\"SSL_EXT_origin_sublist_term\", <id>)

  origin-support-sublist(s) =
    (origin-sublist-term; s) <+ 
    (?[h|[]]; <s> h) <+
    s

  origin-set-relation:
    (origin-node, new-node) -> origin-tracked-node
    where
      origin-tracked-node := <!Some(<id>); all(!new-node); ?Some(<id>)> origin-node
    
strategies // comments

  origin-documentation-comment =
    origin-surrounding-comments;
    filter(string-as-chars(documentation-comment-chars));
    concat-strings
  
  documentation-comment-chars:
    ['*' | c*] -> <ltrim(' ' + '\\t' + '\\n' + '\\r')> c*
    
  origin-surrounding-comments = prim(\"SSL_EXT_origin_surrounding_comments\", <origin-language>, <id>)
  origin-comments-after       = origin-support-sublist(prim(\"SSL_EXT_origin_comments_after\", <id>))
  comments-after = origin-comments-after <+ !\"\"
  origin-insert-before-offset = origin-support-sublist(prim(\"SSL_EXT_origin_insert_before_offset\", <id>))
  origin-insert-at-end-offset = origin-support-sublist(prim(\"SSL_EXT_origin_insert_at_end_offset\", <id>))
  origin-text-with-layout     = origin-support-sublist(prim(\"SSL_EXT_origin_text_with_layout\", <id>))

"

  create-editor-outline-library = 
    <output-text-file(|["lib", "runtime", "editor"], "outline-library.str")>
"module runtime/editor/outline-library

imports
  
  runtime/editor/origins
  runtime/editor/annotations
  
strategies
  
  /**
   * Creates an outline given a strategy s1 that rewrites AST nodes to outline labels.
   * Only AST nodes for which s1 succeed end up in the outline.
   *
   * Example:
   *   outline = simple-label-outline(to-outline-label)
   *   to-outline-label: Entity(name, _) -> name
   *   to-outline-label: Property(name, _) -> name
   */
  simple-label-outline(s1) = collect-om(to-outline-node(s1, fail), conc)
  
  /**
   * Similar to simple-label-outline(s1), but with an additional strategy s2 that rewrites
   * AST nodes to outline nodes. Strategy s2 gets priority over strategy s1 in case both succeed.
   *
   * Example:
   *   outline = custom-label-outline(to-outline-label, to-outline-node)
   *   to-outline-label: Entity(name, _) -> name
   *   to-outline-node: Property(name, _) -> Node(name, [Node(\"dummy\", [])])
   */
  custom-label-outline(s1, s2) = collect-om(origin-track-forced(s2) <+ to-outline-node(s1, s2), conc)

  /**
  * @internal
  * Note: we annotate labels with random numbers to guarantee that similar labels do not share the
  * same in-memory term, which would cause origins to be overwritten.
  */  
  to-outline-node(s1, s2):
    term -> Node(label, children)
    where
      random := <next-random>;
      label := <origin-track-forced(s1; term-to-outline-label; add-annotation(|random); remove-annotations(?random))> term;
      children := <get-arguments; custom-label-outline(s1, s2)> term
      
  /**
  * @internal
  */  
  term-to-outline-label =
    is-string 
      <+
    ?term{a}; origin-text; ?label; !label{a}
      <+
    write-to-string // fallback

rules

rules
  
  /**
  * Given a string of literals (e.g. \"context-free syntax\"), converts the string
  * into an outline label by providing it with origin information. The result is
  * that the correct portion of text in the editor gets selected, upon selecting
  * nodes with this label in the outline view.
  * Note: this strategy is useful for constructing outline labels for unnamed
  * elements. 
  *
  * @param term (e.g. 'context-free-syntax([])') provides the origin.
  */  
  literals-to-outline-label(|term):
    literals -> literals
    where
      literals' := <split-at-space> literals;
      (a, b, c, d, e) := <origin-location-offset> term;
      (before, after) := <split-before> (<origin-text> term, <Hd> literals');
      start-offset := <add> (d, <string-length> before);
      end-offset := <get-literals-end-offset(|literals', start-offset)> after;
      <origin-location-offset-set(|(a, b, c, start-offset, end-offset))> literals
      
  /**
  * @internal
  */      
  get-literals-end-offset(|literals, start-offset):
    text -> end-offset
    where
      (before, after) := <split-after> (text, <Hd> literals);
      end-offset := <get-literals-end-offset(|<Tl> literals, <add> (start-offset, <string-length> before))> after

  /**
  * @internal
  */
  get-literals-end-offset(|literals, start-offset):
    _ -> <dec> start-offset
    where
      [] := literals

rules

  /**
  * Given a term application, gets the portion of the origin text up to the start
  * of the origin text of the first subterm. If the result is an empty string, it
  * gets the origin text of the first subterm instead. Excess whitespace, such as
  * tabs and new lines, are removed.
  */
  origin-text-at-start:
    term -> result'
    where
      (cons, args) := <explode-term> term;
      offset1 := <origin-offset; ?(<id>, _)> term;
      offset2 := <Hd; origin-offset; ?(<id>, _)> args;
      offset-diff := <subt> (offset2, offset1);
      if (0 := offset-diff)
      then result' := <Hd; origin-text; guarantee-one-space-separation> args
      else result := <origin-text; explode-string; take(!offset-diff); rtrim(is-whitespace + test('\\n')); implode-string> term;
        result' := <guarantee-one-space-separation> result;
        (a, b, c, d, e) := <origin-location-offset> term;
        <origin-location-offset-set(|(a, b, c, d, <add> (d, <string-length; dec> result)))> result'
      end
  
  /**
  * @internal
  */
  guarantee-one-space-separation = string-as-chars(
      map(try(test('\\n' + ' '); !' '));
      foldr(![], rm-double-space <+ MkCons)
    )
  rm-double-space: (' ', l@[' '|xs]) -> l
  
signature constructors
  
  Node: label * children -> Node

"

  create-editor-positions = 
    <output-text-file(|["lib", "runtime", "editor"], "positions.str")>
"module runtime/editor/positions

signature constructors

  MARKER: Term
  
strategies

  desugar-position(desugar|ast):
    position -> position'
    where
      ast'  := <at-position(!<id>{MARKER()}|position)> ast;
      ast'' := <topdown(repeat(preserve-annos({?x; desugar; not(?x)})))> ast';
      position' := <position-of-term({?_{a*}; <one(?MARKER())> a*})> ast''
   
  at-position(s|position):
    c#(t*) -> t'
    where
      !position => [i | position']
    where
      t' := c#(<at-index(at-position(s|position'))> (i, t*))

  at-position(s|position):
    t -> t'
    where
      !position => [];
      t' := <s> t

  position-of-term(is-term):
    t -> []
    where
      is-term
  
  position-of-term(is-term):
    _#(t*) -> <position-of-term(is-term|0)> t*
    where
      not(is-term)
  
  position-of-term(is-term|start-index):
    [t | t*] -> position
    where
      if i* := <position-of-term(is-term)> t then
        position := [start-index | i*]
      else
        position := <position-of-term(is-term | <inc> start-index)> t*
      end

  term-at-position(|position):
    t -> t'
    where
      at-position(?t'|position) 

  parent-at-position(|position):
    t -> t'
    where
      !position => [i, _];
      t' := <subterm-at(|i)> t
  
  parent-at-position(|position):
    t -> <parent-at-position(|position')> t'
    where
      !position => [i | position' @ [_, _ | _]];
      t' := <subterm-at(|i)> t

  subterm-at(|index):
    _#(t*) -> <index(|<inc> index)> t*

"

  create-editor-properties = 
    <output-text-file(|["lib", "runtime", "editor"], "properties.str")>
"module runtime/editor/properties

imports

  libstratego-gpp 
  runtime/editor/interop
  
  runtime/index/core
  runtime/nabl/collect
  runtime/nabl/entries
  runtime/nabl/uri
  runtime/properties/collect
  runtime/properties/query
  runtime/task/core
  runtime/types/query
  runtime/types/collect
  
rules // Properties
  
  get-editor-properties(language-pp | language, project-path) = 
    get-all-editor-properties(language-pp | language, project-path)
  ; filter(not-none)
  
  get-all-editor-properties(language-pp | language, project-path):
    t ->
      <concat
      ;map(\\(a,b)->(a,<pp-property>b)\\)>
      [
        [
          (\"Target\",      <target-prop(language-pp)>t),
          (\"Target Constructor\",<cons-prop>t),
          (\"Name\",        <name-prop>t),
          (\"Defines\",     <def-prop>t),
          (\"Refers to\",   <ref-prop>t)
        ]
      , <nabl-props>t
      ]
      with
        index-setup(|language, project-path);
        task-setup(|project-path)
  
  target-prop(language-pp): t -> tar
    with
      tar := <pp-ast(language-pp)>t <+
      tar := None()
  
  cons-prop: _ -> None()
    where is-string
  cons-prop: t -> constr
    where not(is-string)
    with
      constr := <pp-cons>t <+
      constr := None()
  
  type-prop: t -> type
    with
      type := <get-type>t <+
      type := None()

  name-prop: t -> name
    where
      name := <nabl-get-name>t <+
      name := None()

  def-prop: t -> uri
    with
      uri := <nabl-collect-def;nabl-uri;pp-uri>t <+
      uri := None()

  ref-prop: Def(uri) -> <pp-uri>uri //TODO: remove this when we can use hover without resolving 
  ref-prop: t -> uri
    with
      uri := <nabl-collect-use;nabl-uri;pp-uri>t <+
      uri := None()
  
  nabl-props: t -> props
    with
      nabl-props := [Type()|<nabl-collect-custom-properties>]
    with
      props := <map(nabl-prop(|t))> nabl-props <+
      props := []
  nabl-prop(|t): p -> <nabl-prop>(t, p)
  nabl-prop: (t, property) -> (name, prop)
    with
      name := <pp-nabl-prop-name>property
    with
      prop := <get-properties(|property);de-list;not(?Result(_); task-has-failed)>t <+
      prop := <get-property(|property)  ;        not(?Result(_); task-has-failed)>t <+
      prop := None()
    
rules // helper rules: filtering

  not-none: (a, b) -> (a, b)
    where
      <not(eq)>(b, None())
    ; <not(eq)>(b, \"-\")
  
  de-list: [] -> None()
  de-list: [a] -> a
  de-list: [a|rest] -> [a|rest]
  
rules // helper rules: formatting
  
  pp-ast(language-pp) = topdown(try(rm-annotations));language-pp
  
  pp-cons: t -> $[[<get-constructor> t]/[<get-arguments;length> t]]
  
  pp-uri = reverse-uri;foreign-call(|\"Analysis\", \"make-abstract\");foreign-call(|\"Analysis\", \"prettyprint-example\");box2text-string(|80)
  
  reverse-uri: URI(language, uri) -> URI(language, <reverse>uri)
  
  pp-nabl-prop-name : Type() -> \"Type\"
  pp-nabl-prop-name = write-to-string;string-replace(|\"NablProp_\",\"\");string-replace(|\"-\",\" \");upper-case-first
  
  upper-case-first: string -> <implode-string>[<to-upper>c|hars]
    with [c|hars] := <explode-string>string
  
  pp-property: a -> a
    where is-string
  pp-property: None() -> \"-\"
  pp-property: a -> <map(pp-property;\\x->(\"\",x)\\)>a
    where is-list
  pp-property: Def(uri) -> <pp-uri>uri
  pp-property = topdown(try(rm-annotations));write-to-string
  
rules // helper rules: format to HTML for hover
  
  properties-to-html = map(property-to-html);separate-by(|\"<br/>\\n\");concat-strings
  property-to-html: (\"\", prop) -> $[[<property-to-html>prop]]
  property-to-html: (name, prop) -> $[<b>[name]</b>: [<property-to-html>prop]]
  property-to-html: list -> $[<div>[<properties-to-html>list]</div>]
    where is-list
  property-to-html: prop -> <escape-for-html> $[[prop]]

  escape-for-html =
    string-replace(|\"&\", \"&amp;\") ;
    string-replace(|\"<\", \"&lt;\") ;
    string-replace(|\">\", \"&gt;\")

"

  create-editor-queue = 
    <output-text-file(|["lib", "runtime", "editor"], "queue.str")>
"module runtime/editor/queue

rules
  
  // Set markers and analyzed AST for a given file. Use when checking files from a queued strategy.
  // Current term: (ast-analyzed, errors, warnings, notes) tuple
  // fileOrAST: file to set the markers on or the root node of the file to set markers on 
  set-markers(|fileOrAST) = prim(\"SSL_EXT_set_markers\", fileOrAST)
  
  // Set only the markers for given file, does not change the stored AST.
  // Current term: (errors, warnings, notes) tuple
  // fileOrAST: file to set the markers on or the root node of the file to set markers on 
  set-only-markers(|fileOrAST) = prim(\"SSL_EXT_set_only_markers\", fileOrAST)

  // Indicate that one or more files need analysis. 
  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
  queue-analysis = 
       (is-list; list-loop(queue-analysis))
    <+ prim(\"SSL_EXT_queue_analysis\")
    
  // Gets the number of background analyses for currenct project and language.
  // Current term: ignored
  analysis-count = prim(\"SSL_EXT_queue_analysis_count\")

  // Set the total number of work units to complete. Can be called multiple times. 
  // Current term: number of work units (int).
  set-total-work-units = prim(\"SSL_EXT_set_total_work_units\")
  
  // Complete one work unit and update progress monitors.
  // Current term: ignored
  complete-work-unit = prim(\"SSL_EXT_complete_work_unit\")
  
  // Queue a strategy for background processing with a progress indicator.
  // Current term: the term to pass to the background strategy
  // s: the strategy, as string
  // description: name of the task (will be shown in progress view)
  queue-strategy(|s,description) = prim(\"SSL_EXT_queue_strategy\", s, description)
  
  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
  set-analysis-backgrounded = !\"BACKGROUNDED\"

"

  create-editor-time = 
    <output-text-file(|["lib", "runtime", "editor"], "time.str")>
"module runtime/analysis/time
  
rules
  
  cputime = prim(\"SSL_cputime\")
  
  cputime-to-seconds:
    cputime -> <div> (cputime, 1000000000)
  
  measure-time(s, match) =
    where(before := <cputime>);
    s;
    where(after := <cputime>; !(after, before); subt; match)

"

  create-index-core = 
    <output-text-file(|["lib", "runtime", "index"], "core.str")>
"module runtime/index/core

signature

  sorts
  
    URI Entry
  
rules

  /**
   * Sets up the index library for given language, project paths and current file.
   * Must be called once before doing anything with the library.
   *
   * Example:
   *   <index-setup(|\"MiniJava\", <project-path>)
   *
   * @param language          The language to set the index up for.
   * @param project-path      The project path that contains all source files to analyse.
   * @type x -> x
   */
  index-setup(|language, project-path) =
    prim(\"LANG_index_setup_new\", language, <index-setup-paths> project-path)
  index-setup:
    (language, project-path) -> <prim(\"LANG_index_setup_new\", language, <index-setup-paths> project-path)>
  index-setup-paths = try(is-list; Hd)
    
  /**
   * Unloads the currently loaded index.
   *
   * Example:
   *   index-unload(|<project-path>)
   *
   * @param project-path The project path that contain all source files to analyse and compile.
   *
   * @type x -> x
   */
  index-unload(|project-path) =
    prim(\"LANG_index_unload\", project-path)

  /**
   * Tries to recover the index from an invalid state, for example after a crash.
   */
  index-recover =
    prim(\"LANG_index_recover\")
    
  /**
   * Starts collection for a given source. Used in conjunction with index-stop-collection to 
   * retrieve a list of added and removed index entries in relation to the previous entries in
   * given source.
   *
   * Example:
   *   index-start-collection(|\"fullpath/file.ext\")
   *
   * @type x -> x
   */
  index-start-collection(|source) =
    prim(\"LANG_index_start_collection\", source)
    
  /**
   * Collects given element, which will be added to the index when collection stops.
   *
   * @param value Value of the element.
   * @param source The source to collect the element for.
   * @type key -> key
   */
  index-collect(|value, source):
    key -> <prim(\"LANG_index_collect\", key, value)>
    
  /**
   * Collects given element without value, which will be added to the index when collection stops.
   *
   * @param source The source to collect the element for.
   * @type key -> key
   */
  index-collect(|source):
    key -> <prim(\"LANG_index_collect_boolean\", key)>
    
  /**
   * Stops collection for given source. Returns a tuple with removed and added entries in relation to the previous 
   * entries in that source.
   *
   * Example:
   *   index-stop-collection(|\"fullpath/file.ext\") => (removed, added)
   *
   * @type _ -> (List(elem), List(elem))
   */
  index-stop-collection(|source) =
    prim(\"LANG_index_stop_collection\", source)
  
  /**
   * Pushes a new index on the stack and sets that as the current index. Entries from the parent
   * index are still visible, but additions only apply to the current index. Clearing a partition
   * also hides all entries in that partition from the parent index.
   *
   * Example:
   *   index-push
   *
   * @type x -> x 
   */ 
  index-push = 
    prim(\"LANG_index_push\")

  /**
   * Pops the current index from the stack and sets the parent index as the current index. All
   * modifications from the current index are discarded. The root index cannot be popped.
   *
   * Example:
   *   index-pop
   *
   * @type x -> x 
   */ 
  index-pop = 
    prim(\"LANG_index_pop\")

  /**
   * Pops the current index from the stack and sets the parent index as the current index. All
   * modifications from the current index are merged into the parent index; partitions that were
   * cleared in the current index are cleared in the parent, and entries added to the current
   * index are also added to the parrent. The root index cannot be merged.
   *
   * Example:
   *   index-merge
   *
   * @type x -> x 
   */ 
  index-merge = 
    prim(\"LANG_index_merge\")
    
  /**
   * Adds given element to the index.
   *
   * @param value Value of the element.
   * @param source The source to add the element to.
   * @type key -> key
   */
  index-add(|value, source):
    key -> <prim(\"LANG_index_add\", key, value, source)>
    
  /**
   * Adds given element without value to the index.
   *
   * @param source The source to add the element to.
   * @type key -> key
   */
  index-add(|source):
    key -> <prim(\"LANG_index_add_boolean\", key, source)>
    
  /**
   * Removes all elements from the index that are contained in given source.
   *
   * Example:
   *   <index-clear-source> \"fullpath/file.ext\"
   *
   * @type source -> source
   */
  index-clear-source:
    source -> <prim(\"LANG_index_clear_source\", source)>
    
  /**
   * Removes all elements from the index.
   *
   * @type x -> x
   */
  index-reset = 
    prim(\"LANG_index_clear_all\")
    
  /**
   * Removes all elements from the index and re-analyzes all partitions in the project.
   *
   * @type x -> x
   */
  index-reload = 
    prim(\"LANG_index_reload\")
   
  /**
   * Persists index to a cache on disk.
   *
   * @type x -> x
   */
  index-persist = 
    prim(\"LANG_index_persist\")

"

  create-index-globals = 
    <output-text-file(|["lib", "runtime", "index"], "globals.str")>
"module runtime/index/globals

imports

  runtime/index/core
  runtime/index/query
  
signature 

  constructors
    
    Global : URI -> Key
    
rules
    
  /**
   * Gets the 'fake' path where globals are stored in the index.
   *
   * @internal
   */
  index-globals-path:
    names -> <separate-by(|\"/\"); concat-strings> path
    with
      if is-list then
        path := <concat> [names, [\"globals\", \".internal\"]]
      else
        path := [names, \"global\", \".internal\"]
      end
    
  /**
   * Gets the URI where globals are stored in the index for given name or names.
   *
   * @internal
   * @type name or List(name) -> uri
   */
  index-globals-uri:
    names -> uri
    with
      if is-list then
        uri := <concat> [names, [\"globals\", \".internal\"]]
      else
        uri := [names, \"global\", \".internal\"]
      end
    
  /**
   * Gets the first value in global storage with given name, or fail.
   *
   * Example:
   *   index-get-global(|\"last-compile\") => Timestamp(1334322856)
   *   index-get-global(|[\"last-compile\", \"file.str\"]) => Timestamp(1334322856)
   * 
   * @param name  The name or list of names to identify the global value.
   * @type _ -> ?value
   */
  index-get-global(|name):
    _ -> <index-get-one-value> Global(<index-globals-uri> name)
    
  /**
   * Gets all values in global storage with given name.
   *
   * Example:
   *   index-get-global(|\"last-compile\") => [Timestamp(1334322856), ...]
   *   index-get-global(|[\"last-compile\", \"file.str\"]) => [Timestamp(1334322856), ...]
   *
   * @param name  The name or list of names to identify the global value.
   * @type _ -> List(value)
   */ 
  index-get-all-globals(|name):
    _ -> <index-get-all-values> Global(<index-globals-uri> name)
    
  /**
   * Add value to global storage with given name.
   *
   * Example:
   *   <index-add-global(|\"last-compile\")> Timestamp(1334322856)
   *   <index-add-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-add-global(|name):
    value -> <id>
    with
      <index-add(|value, <index-globals-path>)> Global(<index-globals-uri> name)
      
  /**
   * Overwrites value in global storage with given value.
   *
   * Example:
   *   <index-set-global(|\"last-compile\")> Timestamp(1334322856)
   *   <index-set-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-set-global(|name):
    value -> <id>
    with
      index-clear-global(|name);
      <index-add-global(|name)> value
    
  /**
   * Removes all values from global storage with given name.
   *
   * Example:
   *   index-clear-global(|\"last-compile\")
   *   index-clear-global(|[\"last-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-clear-global(|name):
    _ -> <id>
    with
      <index-globals-path; index-clear-source> name
rules
  
  /**
   * Gets the 'fake' path where boolean globals are stored in the index.
   *
   * @internal
   */
  index-boolean-globals-path:
    names -> <separate-by(|\"/\"); concat-strings> path
    with
      if is-list then
        path := <concat> [names, [\"boolean\", \"globals\", \".internal\"]]
      else
        path := [names, \"boolean\", \"global\", \".internal\"]
      end
        
  /**
   * Gets the URI where boolean globals are stored in the index for given name or names.
   *
   * @internal
   */
  index-boolean-globals-uri:
    names -> uri
    with
      if is-list then
        uri := <concat> [names, [\"boolean\", \"globals\", \".internal\"]]
      else
        uri := [names, \"boolean\", \"global\", \".internal\"]
      end
      
  /**
   * Sets boolean value true to global boolean storage with given name.
   *
   * Example:
   *   index-enable-global(|\"can-compile\")
   *   index-enable-global(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> x
   */   
  index-enable-global(|name):
    _ -> <id>
    with
      <index-add(|<index-globals-path>)> Global(<index-boolean-globals-uri> name)
      
  /**
   * Sets boolean value false to global boolean storage with given name.
   *
   * Example:
   *   index-disable-global(|\"can-compile\")
   *   index-disable-global(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> x
   */   
  index-disable-global(|name):
    _ -> <id>
    with
      <index-boolean-globals-path; index-clear-source> name
      
  /**
   * Query for boolean value true in global boolean storage with given name.
   *
   * Example:
   *   index-is-global-enabled(|\"can-compile\")
   *   index-is-global-enabled(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> ?x
   */   
  index-is-global-enabled(|name):
    _ -> <id>
    where
      <index-get-one-value> Global(<index-boolean-globals-uri> name)

"

  create-index-legacy = 
    <output-text-file(|["lib", "runtime", "index"], "legacy.str")>
"module runtime/index/legacy

imports
  
  runtime/index/core
  runtime/index/query

rules // Redirects
  
  index-setup(|language, project-path, current-partition) =
    index-setup(|language, <index-setup-paths> project-path)
    
  index-clear = index-reset
  index-clear-all = index-reset
  
  index-commit = index-persist
  
  index-clear-partition = index-clear-source
  
  index-get-all = index-get-all-values
  index-get-children = index-get-all-childs
  index-get-all-partitions = index-get-all-sources
  index-get-all-in-partition = index-get-all-values-in-source
  index-get-partitions-of = index-get-all-sources-of
  
rules // Deprecated
    
  index-depricated-disable = fail
  index-depricated = try(not(index-depricated-disable); with(fail|\"Deprecated.\"))
  
  index-add-all(|source) = index-depricated
    
  index-get-all-with-partitions = index-depricated
    
  index-remove(|partition) = index-depricated
    
  index-remove-all = index-depricated
    
  index-remove-one = index-depricated
  
  index-get-current-partition = index-depricated
  
  index-set-current-partition = index-depricated
  
  index-get-partition-revision = index-depricated
    
  index-start-transaction = index-depricated
  
  index-end-transaction = index-depricated
  
  index-transaction(s) = index-depricated; s

"

  create-index-query = 
    <output-text-file(|["lib", "runtime", "index"], "query.str")>
"module runtime/index/query

rules

  /**
   * Get one value from an index entry that matches the given key, or fail.
   *
   * @type key -> ?value
   */
  index-get-one-value:
    key -> <prim(\"LANG_index_get_one_value\", key)>

  /**
   * Get all values from index entries that match the given key.
   *
   * @type key -> List(value)
   */
  index-get-all-values:
    key -> <prim(\"LANG_index_get_all_values\", key)>
    
  /**
   * Get one key-value pair from an index entry that matches the given key, or fail.
   *
   * @type key -> ?Tuple(key, value)
   */
  index-get-one-pair:
    key -> <prim(\"LANG_index_get_one_pair\", key)>

  /**
   * Get all key-value pairs from index entries that match the given key.
   *
   * @type key -> List(Tuple(key, value))
   */
  index-get-all-pairs:
    key -> <prim(\"LANG_index_get_all_pairs\", key)>

  /**
   * Gets all values of child index entries of the given key.
   *
   * @type key -> List(value)
   */    
  index-get-all-childs:
    key -> <prim(\"LANG_index_get_all_childs\", key)>
  
  /**
   * Gets a list of all sources for the current project.
   *
   * @type _ -> List(source)
   */   
  index-get-all-sources =
    prim(\"LANG_index_get_all_sources\")
  
  /**
   * Gets all values of index entries for the given source.
   *
   * @type source -> List(elem)
   */  
  index-get-all-values-in-source:
    source -> <prim(\"LANG_index_get_all_values_in_source\", source)>
    
  /**
   * Gets all key-value pairs of index entries for the given source.
   *
   * @type source -> List(elem)
   */  
  index-get-all-pairs-in-source:
    source -> <prim(\"LANG_index_get_all_pairs_in_source\", source)>

  /**
   * Gets the containing sources of index entries with given key.
   *
   * @type key -> List(source)
   */  
  index-get-all-sources-of:
    key -> <prim(\"LANG_index_get_all_sources_of\", key)>

"

  create-modelware-model2tree = 
    <output-text-file(|["lib", "runtime", "modelware"], "model2tree.str")>
"module runtime/modelware/model2tree

imports
  
  runtime/modelware/signatures
  runtime/nabl/-
  runtime/editor/origins

rules
  
  mw-model2tree: M(obj)                    -> <origin-track-forced(mw-obj2term)> obj
  mw-obj2term  : Obj(_, QID(\"ast\", c), s*) -> c#(<map(mw-slot2term)> s*)
  mw-slot2term : None()                    -> None()
  mw-slot2term : Some(val)                 -> Some(<mw-val2term> val)
  mw-slot2term : []                        -> []
  mw-slot2term : val                       -> <mw-val2term>
  mw-val2term  : Data(val)                 -> val
  mw-val2term  : Link(uri)                 -> <mw-name-of + map(mw-name-of)> uri
  mw-val2term  : Contain(obj)              -> <mw-obj2term + map(mw-obj2term)> obj
  
rules
  
  mw-name-of = ?URI(_, <id>); Hd; ?ID(_, <id>, _)

"

  create-modelware-modelware = 
    <output-text-file(|["lib", "runtime", "modelware"], "modelware.str")>
"module runtime/modelware/modelware

imports
  
  libstratego-lib
  
  runtime/modelware/-

"

  create-modelware-signatures = 
    <output-text-file(|["lib", "runtime", "modelware"], "signatures.str")>
"module runtime/modelware/signatures

signature constructors // grammar

  // TODO

signature constructors // metamodel
  
  // TODO
  
signature constructors // model
  
  M         : Object                      -> Model
  Obj       : Opt(URI) * QID * List(Slot) -> Object
            : Value                       -> Slot
            : Opt(Value)                  -> Slot
            : List(Value)                 -> Slot
  Data      : String                      -> Value
  Contain   : Object                      -> Value
  Link      : QID                         -> Value
  QID       : PackName * ClassName        -> QID
  Unresolved:                                QID

"

  create-modelware-tree2model = 
    <output-text-file(|["lib", "runtime", "modelware"], "tree2model.str")>
"module runtime/modelware/tree2model

imports
  
  runtime/modelware/signatures
  runtime/nabl/-
  runtime/index/-
  runtime/editor/-

rules
  
  mw-tree2model: t       -> M(<origin-track-forced(mw-term2obj)>)
  mw-term2obj  : c#(t*)  -> Obj(<mw-def-uris>, QID(\"ast\", c), <map(mw-term2slot)> t*)
  mw-term2slot : None()  -> None()
  mw-term2slot : Some(t) -> Some(<mw-term2val> t)
  mw-term2slot : t*      -> <map(mw-term2val); mw-combine>
  mw-term2slot : t       -> <mw-term2val>
  mw-term2val  : t       -> Data(t) where is-string; not(mw-ref-uri)
  mw-term2val  : t       -> Link(<mw-ref-uri>)
  mw-term2val  : t       -> Contain(<origin-track-forced(mw-term2obj)> t) where mw-is-compound

rules
  
  mw-def-uris    = get-arguments; map(get-annos; filter(?Def(_))); concat
  mw-ref-uri     = get-annos; fetch-elem(?Use(_)); (nabl-collect-one-resolved-def; index-get-one-value; ?Def(_) <+ ?Use(<id>) <+ !Unresolved())
  mw-is-compound = where(not(?Some(_))); explode-term + map(explode-term)
  
  mw-combine = ?[]
  mw-combine:
    t* -> c#([<map(get-arguments; Hd)> t*])
    where
      c#(_) := <Hd> t*

"

  create-nabl-check = 
    <output-text-file(|["lib", "runtime", "nabl"], "check.str")>
"module runtime/nabl/check

imports
  
  runtime/nabl/resolve
  runtime/nabl/collect
  runtime/nabl/query
  runtime/nabl/tasks
  runtime/nabl/entries
  runtime/nabl/interface
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/task/core
  runtime/task/messages
  runtime/task/tasks
  
rules // Error checking tasks
  
  nabl-unresolved-task(|partition, task):
    name -> name
    where
      not(nabl-check-disable-unresolved)
    with
      <nabl-fix-name; task-create-error-on-failure(|partition, task, \"Unresolved reference\")> name
      
  nabl-duplicate-task(|ctx, unique):
    name -> name
    where
      uri := <nabl-uri> name;
      ns  := <nabl-uri-namespace> uri;
      not(<nabl-check-disable-duplicate(|uri, ns)> name)
    with
      if Unique() := unique then
        uri'    := <nabl-uri-parent> uri;
        resolve := <nabl-create-resolvedefs(|ctx, ns, name, [])> uri';
        if(
          parent:= <nabl-uri-name> uri';
          parent-ns := <nabl-uri-namespace> uri'
        )then
          <task-create-error-on-multiple(|ctx, resolve, [\"Duplicate \", <pp-ns>ns ,\" \", name , \" in \", <pp-ns>parent-ns, \" \", parent ])> name
        else
          <task-create-error-on-multiple(|ctx, resolve, [\"Duplicate \", <pp-ns>ns ,\" \", name])> name
        end
      end

  pp-ns = write-to-string;string-replace(|\"NablNs\",\"\")

rules // Legacy
 
  nabl-is-unresolved =
    ?node;
    has-annos;
    get-annos;
    where(nabl-has-reference);
    not(nabl-collect-one-resolved-def)
  
  nabl-get-ambiguities =
    nabl-collect-all-resolved-defs;
    mapconcat(nabl-get-all-aliases);
    filter(nabl-uri; nabl-uri-parent);
    make-set;
    where(<gt> (<length>, 1))
  
  nabl-get-duplicate-definitions =
    has-annos;
    get-annos;
    collect-one(?Def(_));
    nabl-get-all-definitions;
    make-set;
    where(<gt> (<length>, 1))

"

  create-nabl-collect = 
    <output-text-file(|["lib", "runtime", "nabl"], "collect.str")>
"module runtime/nabl/collect

imports
  
  runtime/task/core
  runtime/task/tasks
  runtime/task/messages
  runtime/nabl/tasks
  runtime/nabl/entries
  runtime/nabl/check
  runtime/nabl/namegen
  runtime/nabl/interface
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/properties/collect
  runtime/properties/entries
  runtime/properties/tasks
  runtime/editor/origins
  runtime/editor/annotations
  runtime/types/collect

signature 

  sorts
  
    State DefScope ImplicitDef Use RefScope Range

  constructors // state
    
    State : String * Term -> State

  constructors // def

    Current    :                    DefScope
    Subsequent :                    DefScope
    DefScope   : Term            -> DefScope
    Scope      : Namespace       -> Scope
    FixedScope : Namespace * URI -> Scope
    
  constructors // use
      
    UseCandidate  : Namespace * List(Property) * RefScope * WildcardImport * List(Dependency) -> Use
    
    True  : WildcardImport
    False : WildcardImport
  
    Current     :                                                   RefScope
    Surrounding :                                                   RefScope
    Context     : String * Namespace * List(Property) * RefScope -> RefScope
    RefScope    : Term                                           -> RefScope
    
    Completion : Result -> Completion
  
  constructors // import
    
    Wildcard : List(Import) * RefScope * DefScope * List(Dependency) -> ImportDesc
    Single   : Namespace * Term * DefScope * List(Dependency) -> ImportDesc
    Imported : Namespace                   -> Namespace
    Import   : Namespace                   -> Property
    Import   : Language * Namespace        -> Property
    Import   : Language * Namespace * Name -> Property
      
  constructors // partition
  
    CollectPartition : Partition
  
  constructors // annotation
    
    ExternalDef  : URI -> Anno
    
strategies // generic traversal
  
  /**
   * Performs the collection in a topdown traversal. 
   * At each node, it tries various calls to generated strategies, which call back to generic strategies.
   */
  nabl-collect(sibling-uris|lang, partition, unique*, uri*) =
    nabl-state-pop(?state*)
  ; try(nabl-scoping-site)
  ; (
       nabl-scope-site(?uri'*|lang, partition, unique*, uri*)
    <+ nabl-new-scope-site(?uri'*|lang, partition, unique*, uri*)
    <+ match(?uri'*|uri*) 
    ) 
  ; (
       nabl-def-site(?child-uri*, sibling-uris, ?implicit*|lang, partition, unique*, uri'*, state*)
     ; try(nabl-new-scoping-site)
    <+ match(sibling-uris|uri*)
     ; match(?child-uri*|uri'*)
    )    
  ; try(nabl-state-site)
  // visit children from left to right
  ; try(nabl-collect-rewrite(|lang, partition, uri*, uri'*))
  ; preserve-annos(origin-track-forced(id#(nabl-siblings(|lang, partition, unique*, child-uri*))))
  ; try(nabl-external-def-site(|lang, partition, unique*, uri'*, state*, implicit*))
  ; try(nabl-use-site(|lang, partition, unique*, uri'*, state*))
  ; try(nabl-import-site(|lang, partition, unique*, child-uri*, state*))
  ; try(nabl-filtering-site(|lang, partition, unique*, uri*, state*))
  ; try(nabl-disambiguation-site(|lang, partition, unique*, uri*, state*))
  ; try(nabl-prop-site(|lang, partition, uri*, state*, implicit*))
  ; nabl-annotate-properties(|lang, partition, uri*, uri'*)
    
  nabl-siblings(|lang, partition, unique*, uri*) = 
    []  
  + [ nabl-collect(?sibling-uri*|lang, partition, unique*, uri*)
    | nabl-siblings(|lang, partition, unique*, sibling-uri*) ]

rules // generic analysis of state
  
  nabl-state(pattern|state) =
    map(try(nabl-state-annotate(pattern|state)))
      
  nabl-state-annotate(pattern|state) =
    ?pattern; add-annotation(|state)
    
  nabl-state-pop(states'):
    term{anno*} -> term'
    where
      state* := <collect-all(?State(_, _))> anno*;
      term'  := <remove-annotations(?State(_, _))> term;
      match(states'|state*)
      
  nabl-get-state(|name) =
    fetch-elem(?State(name, _))

rules // generic analysis of scopes
  
  nabl-scope-site(adapted-uris|lang, partition, unique*, uri*) =
    remove-annotations(?Scope(ns*))
  ; where (
      uri'* := <extend-scope-uri(nabl-extend-uri-anonymous(|unique*, partition)|lang)> (ns*, uri*)
    ; match(adapted-uris| uri'*)
    ; scope-uri* := <map(!(<id>, <lookup-uri(|uri'*)>))> ns*
    )
  ; add-annotation(|Scope(scope-uri*))
  
  nabl-new-scope-site(adapted-uris|lang, partition, unique*, uri*) =
    remove-annotations(?FixedScope(ns, uri))
  ; where (
      uri'* := <update-scope-uri(!uri|lang)> (ns, uri*)
    ; match(adapted-uris| uri'*)
    )
  ; add-annotation(|Scope([(ns, uri)]))
     
  nabl-scope(|ns1*) = 
     remove-annotations(?Scope(ns2*))
   ; add-annotation(|Scope(<union> (ns1*, ns2*)))
  <+ add-annotation(|Scope(ns1*))
   
rules // generic analysis of defs
      
  // call back to generic analysis
  nabl-def(child-uris, sibling-uris|lang, partition, unique*, child-uri*, sibl-uri*, ns, unique, defscope, scoped, nt-scoped):
    a@name{anno*} -> name''
    where
      // get URI for namespace of definition site
      current-uri := <lookup-uri(|lang, ns)> child-uri*
    with
      // generate a name if needed
      name' := <try(nabl-namegen(|lang, partition, unique*, child-uri*, anno*))> name
    where
      switch !defscope
        // in each case we 
        // 1. build URI of the definition site
        // 2. update URIs for children (vertical scope)
        // 3. update URIs for right siblings (horizontal scope)
       
        // 1st case: definition in current scope
        case Current(): 
    
        // 1. extend current URI with ID segment
        // 2. extend URIs of scoped name'spaces
        // 3. preserve
          def-uri         := <nabl-extend-uri(|unique*, partition, ns, <rm-annotations> name', unique)> current-uri
        ; nt-def-uri      := <nabl-uri-add-barriers(|nt-scoped)> def-uri
        ; new-child-uri*  := <replace-scope-uri(|def-uri)> (scoped, child-uri*)
        ; new-child-uri'* := <replace-scope-uri(|nt-def-uri)> (nt-scoped, new-child-uri*)
        ; match(child-uris|new-child-uri'*)
        ; match(sibling-uris|sibl-uri*)
       
        // 2nd case: definition in subsequent scope and maybe in external scopes
        case fetch-elem(?Subsequent()) => def-scope*:
           
        // 1. extend current URI with subsequent and ID segment
        // 2. preserve
        // 3. extend URI for name'space of definition site with Subsequent segment
          subs-uri := <nabl-extend-uri-subsequent(|unique*, partition)> current-uri
        ; def-uri  := <nabl-extend-uri(|unique*, partition, ns, <rm-annotations> name', unique)> subs-uri
        ; match(child-uris|child-uri*)
        ; match(sibling-uris|<replace-scope-uri(|subs-uri)> ([ns], sibl-uri*))
    
        // 3rd case: definition only in external scopes
        case is-list => def-scope*:
        
        // 1. extend base URI with anonymous and ID segment
        // 2. preserve
        // 3. preserve
          ano-uri := <nabl-base-uri; nabl-extend-uri-anonymous(|unique*, partition)> lang 
        ; def-uri := <nabl-extend-uri(|unique*, partition, ns, <rm-annotations> name', unique)> ano-uri
        ; match(child-uris|child-uri*)
        ; match(sibling-uris|sibl-uri*)
      end
    with
      // Add Def entry to the index. Strip barriers from URI so that barriers don't end up in the index.
      d      := <new-def(|partition, <nabl-uri-strip-barriers> def-uri)> a;
      name'' := <replace-annotation(?Def(_)|d)> name'
    with
      <try(nabl-duplicate-task(|partition, unique))> name''
  
  nabl-def-alias(|partition, def-uri):
    term{anno*} -> alias-uri
    where
      <fetch-elem(?Scope(scope*))> anno*
    ; ns        := <nabl-uri-namespace> def-uri
    ; base-uri  := <lookup> (ns, scope*)
    ; segment   := <nabl-uri-path; Hd> def-uri
    ; alias-uri := <nabl-extend-uri(|segment); nabl-nonunique-uri> base-uri
    where
      new-alias(|partition, alias-uri, def-uri)
      
rules // generic analysis of uses
  
  nabl-use(|lang, partition, unique*, uri*, candidate):
    name{anno*} -> result
    with
      candidate* := <is-list <+ MkSingleton> candidate;
      // generate a name if needed
      name' := <try(nabl-namegen(|lang, partition, unique*, uri*, anno*))> name
    where
      if inner-name := <not(is-string); nabl-get-name> name'; Use(inner-use-task) := <nabl-collect-use> inner-name then
        // Filter the inner use with properties instead of creating a new resolution task 
        subtask* := <map(nabl-filter-use-candidate(|lang, partition, uri*, inner-use-task))> candidate*;
        choice   := <task-create-choice(|partition)> subtask*;
        u        := <new-use(|partition, choice)>;
        <try(nabl-unresolved-task(|partition, choice))> inner-name; // TODO: this may result in multiple unresolved msgs.
        // TODO: what about completions?
        result := <nabl-name-apply(replace-annotations(?Use(_)|u))> name'
      else
        subtask* := <map(nabl-use-candidate(|lang, partition, uri*, <nabl-fix-name> name'))> candidate*;
        choice   := <task-create-choice(|partition)> subtask*;
        u        := <new-use(|partition, choice)>;
        <try(nabl-unresolved-task(|partition, choice))> name';
        if <is-completion-name> name' then
          completion-subtask* := <mapconcat(nabl-completion-candidate(|lang, partition, uri*))> candidate*;
          completion-concat   := <task-create-combine(|partition)> completion-subtask*;
          result              := <replace-annotations(?Use(_)|[u, Completion(completion-concat)])> name'
        else
          result := <replace-annotation(?Use(_)|u)> name'
        end
      end

  nabl-use-check-tasks(|ctx, ns) =
     try(nabl-collect-use; ?Use(<id>))
   ; nabl-create-checkdefs(|ctx, ns)

  // candidate in current scope
  nabl-use-candidate(|lang, ctx, uri*, name) =
    ?UseCandidate(ns, prop*, Current(), _, _)
  ; <lookup-uri(|lang, ns)> uri*
  ; ![<try(nabl-uri-strip-barriers)>|<nabl-uri-parents(|ns)>]
  ; nabl-insert-import-tasks(|ctx, ns)
  ; nabl-resolve-task(|ctx, ns, <nabl-fix-name> name, prop*)
      
  // candidate in another scope (result of another resolution)    
  nabl-use-candidate(|lang, ctx, uri*, name) =
    ?UseCandidate(ns, prop*, Context(ctx-ns, ctx-name, ctx-prop*, ctx-context), _, dep*)
  ; if Result(_) := ctx-name then // result exists
      !ctx-name
    else // result will be created here
      <nabl-use-candidate(|lang, ctx, uri*, ctx-name)> UseCandidate(ctx-ns, ctx-prop*, ctx-context, True(), dep*)
    end
  ; MkSingleton
  ; nabl-insert-import-tasks(|ctx, ns)
  ; nabl-resolve-task(|ctx, ns, <nabl-fix-name> name, prop*)
    // TODO: disambiguation
    // TODO: order of imported URI's is unclear
      
  // filtering candidate in current scope
  nabl-filter-use-candidate(|lang, partition, uri*, use-task):
    UseCandidate(ns, prop*, Current(), _, _) -> check-task
    where
      constraint-task := <nabl-use-propconstraint(|partition)> (use-task, prop*);
      check-task      := <nabl-use-check-tasks(|partition, ns)> 

  // filtering candidate in another scope: ignore existing resolution  
  nabl-filter-use-candidate(|lang, partition, uri*, name):
    UseCandidate(_, _, Context(_, _, _, _), _, _) -> <nabl-use-candidate(|lang, partition, uri*, name)>

      
  nabl-use-propconstraint(|ctx):
    (task, [p@Prop(kind, expected, dep*)|rest]) -> rec
    where
      pc  := <nabl-create-propconstraint(|ctx, dep*, kind, task)> expected;
      rec := <nabl-use-propconstraint(|ctx)> (pc, rest)
      
  nabl-use-propconstraint(|ctx):
    (task, []) -> task

rules // completion

  // candidate in current scope
  nabl-completion-candidate(|lang, partition, uri*):
    UseCandidate(ns, prop*, Current(), wci, _) -> subtask*
    where
      uri       := <lookup-uri(|lang, ns)> uri*;
      subtask*  := <nabl-resolve-all-tasks(|partition, ns, prop*)> [uri|<nabl-uri-parents> uri]

  // candidate in another scope (result of resolution)    
  nabl-completion-candidate(|lang, partition, uri*):
    UseCandidate(ns, prop*, c@Context(ctx-ns, ctx-name, ctx-prop*, ctx-context), _, _) -> subtask*
    where
      ctx-result := <nabl-use-candidate(|lang, partition, uri*, ctx-name)> UseCandidate(ctx-ns, ctx-prop*, ctx-context, True(), []);
      subtask*   := <nabl-resolve-all-tasks(|partition, ns, prop*)> [ctx-result]

rules // filtering
  
  nabl-filter(|lang, partition, uri*, ctx-string, ctx-terms):
    name -> result
    where
      defs-task   := <nabl-collect-use-task> name
    ; filter-task := <nabl-create-filter(|partition, uri*, ctx-terms, ctx-string)> defs-task
    ; result      := <replace-annotation(?Use(_)|Use(filter-task))> name
     
rules // disambiguation
  
  nabl-disambiguate(|lang, partition, uri*, ctx-string, ctx-terms):
    name -> result
    where
      defs-task   := <nabl-collect-use-task> name
    ; disamb-task := <nabl-create-disambiguate(|partition, uri*, ctx-terms, ctx-string)> defs-task
    ; result      := <replace-annotation(?Use(_)|Use(disamb-task))> name
     
rules // generic analysis of imports
  
  nabl-import(|lang, partition, unique*, uri*, imports) =
    where(<map(nabl-import-candidate(|lang, partition, unique*, uri*))> imports)
  
  nabl-import-candidate(|lang, partition, unique*, uri*) =
    ?Single(ns, term, scope*, dep)
  ; Use(uri) := <nabl-collect-use> term
  ; name     := <nabl-get-name; nabl-fix-name> term
  ; <try-make-list; map(nabl-import-alias(|lang, partition, unique*, uri*, uri, ns, name))> scope*
  
  nabl-import-alias(|lang, partition, unique*, uri*, target-uri, ns, name):
    scope -> <new-alias(|partition, alias-uri, target-uri)>
  where
    base-uri  := <nabl-scope-uri(|lang, uri*, ns)> scope
    // TODO: uniqueness should be a property of the import, assumes non-unique right now.
  ; alias-uri := <nabl-extend-uri(|unique*, partition, ns, name, NonUnique())> base-uri


  nabl-import-candidate(|lang, partition, unique*, uri*) =
    ?Wildcard(import*, from, into, dep)
  ; <map(nabl-import-prop(|lang, partition, uri*, from, into))> import*
    
  nabl-import-prop(|lang, partition, uri*, from, into):
    Import(lang, ns) -> <new-prop(|partition, into-uri, Import(ns), from-uri)>
  where
     <not(?Imported(_))> ns
  where
    from-uri := <nabl-scope-uri(|lang, uri*, ns)> from 
  ; into-uri := <nabl-scope-uri(|lang, uri*, ns)> into
    
  nabl-import-prop(|lang, ctx, uri*, from, into):
    Import(lang, Imported(ns)) -> <new-prop(|ctx, into-uri, Import(ns), proplookup)>
  where
    from-uri := <nabl-scope-uri(|lang, uri*, ns)> from 
  ; into-uri := <nabl-scope-uri(|lang, uri*, ns)> into
  ; proplookup := <prop-create-lookup(|ctx, Import(ns)); task-create-insert(|ctx); task-create-combine(|ctx)> from-uri


  nabl-scope-uri(|lang, uri*, ns):
    Current() -> <lookup-uri(|lang, ns); nabl-uri-strip-barriers> uri*
  
  nabl-scope-uri(|lang, uri*, ns):
    DefScope(term{anno*}) -> <lookup; nabl-uri-strip-barriers> (ns, scope*)
    where
      <fetch-elem(?Scope(scope*))> anno*
      
  nabl-scope-uri(|lang, uri*, ns):
    Context(_, name, _, _) -> uri
    where
      Use(uri) := <nabl-collect-use> name
              
rules // name retrieval

  nabl-get-name = is-string
  
  nabl-name-apply(s) = is-string; s
    
  nabl-fix-name = try(fix-completion-name); strip-annos
  
rules // URI retrieval
  
  nabl-collect-def =
    try(nabl-get-name);
    get-annos;
    collect-one(?Def(_))
    
  nabl-collect-all-def =
    try(nabl-get-name);
    get-annos;
    collect-all(?Def(_))
    
  nabl-collect-use =
    try(nabl-get-name);
    get-annos;
    collect-one(?Use(_))

  nabl-collect-use-task =
    nabl-collect-use;
    ?Use(<id>)
    
  nabl-collect-all-use =
    try(nabl-get-name);
    get-annos;
    collect-all(?Use(_))
    
  nabl-collect-completion =
    get-annos;
    collect-one(?Completion(_))
    
  nabl-collect-all-completion =
    get-annos;
    collect-all(?Completion(_))

rules // helpers
  
  replace-scope-uri(|path) = foldl(update-scope-uri(!path|<nabl-uri-language> path))
  extend-scope-uri(s|lang) = foldl(update-scope-uri(s|lang))
  
  update-scope-uri(update|lang):
    (key, uri*) -> result
    where
      result := <fetch((?key, update))> uri* 
    <+ 
      result := [(key, <nabl-base-uri; update> lang)|uri*]
        
  lookup-uri(|lang, ns) =
    <lookup> (ns, <id>) <+ <nabl-base-uri> lang
 
  lookup-uri(|uri*) =
    <lookup> (<id>, uri*)

"

  create-nabl-complete = 
    <output-text-file(|["lib", "runtime", "nabl"], "complete.str")>
"module runtime/nabl/complete

imports
  
  runtime/nabl/collect
  runtime/nabl/uri
  runtime/task/core
  
signature

  constructors
    
    COMPLETION : String -> COMPLETION
    
rules // Code completion

  nabl-propose-completions:
    ast -> proposal*
    with
        completion* := <collect-one(?COMPLETION(_)); nabl-collect-all-completion> ast;
        def*        := <mapconcat(\\Completion(result) -> result\\; task-get-solved)> completion*;
        proposal*   := <map(nabl-uri; nabl-uri-name)> def*
      <+
        proposal*   := []

"

  create-nabl-constraints = 
    <output-text-file(|["lib", "runtime", "nabl"], "constraints.str")>
"module runtime/nabl/constraints

imports
  runtime/nabl/uri
  runtime/nabl/collect
  runtime/nabl/entries
  runtime/nabl/tasks
  runtime/task/core
  runtime/task/tasks
  runtime/properties/tasks
  
rules
  
  nabl-lookup-local(|ctx) =
    nabl-uri => uri
  ; nabl-uri-all-local-scopes
  ; nabl-resolve-task(|ctx, <nabl-uri-namespace> uri, <nabl-uri-name> uri, [])
  
  nabl-lookup-local(|ctx, ns) =
    nabl-uri => uri
  ; nabl-uri-all-local-scopes
  ; nabl-resolve-task(|ctx, ns, <nabl-uri-name> uri, [])
    
 nabl-lookup-local(|ctx, ns, name) =
    nabl-uri-all-local-scopes
  ; nabl-resolve-task(|ctx, ns, name, [])

rules
  
  nabl-lookup-lexical(|ctx) =
    nabl-uri => uri
  ; nabl-uri-all-lexical-scopes
  ; nabl-resolve-task(|ctx, <nabl-uri-namespace> uri, <nabl-uri-name> uri, [])
  
  nabl-lookup-lexical(|ctx, ns) =
    nabl-uri => uri
  ; nabl-uri-all-lexical-scopes
  ; nabl-resolve-task(|ctx, ns, <nabl-uri-name> uri, [])
    
 nabl-lookup-lexical(|ctx, ns, name) =
    nabl-uri-all-lexical-scopes
  ; nabl-resolve-task(|ctx, ns, name, [])
  
  nabl-lookup-lexical-parent(|ctx) =
    nabl-uri => uri
  ; nabl-uri-all-lexical-parent-scopes
  ; nabl-resolve-task(|ctx, <nabl-uri-namespace> uri, <nabl-uri-name> uri, [])
  
  nabl-lookup-lexical-parent(|ctx, ns) =
    nabl-uri => uri
  ; nabl-uri-all-lexical-parent-scopes
  ; nabl-resolve-task(|ctx, ns, <nabl-uri-name> uri, [])
    
 nabl-lookup-lexical-parent(|ctx, ns, name) =
    nabl-uri-all-lexical-parent-scopes
  ; nabl-resolve-task(|ctx, ns, name, [])
    
rules
  
  nabl-lookup-local-import(|ctx) =
    nabl-uri
  ; nabl-lookup-local-import(|ctx, <nabl-uri-namespace>, <nabl-uri-name>)
  
  nabl-lookup-local-import(|ctx, ns) =
    nabl-uri
  ; nabl-lookup-local-import(|ctx, ns, <nabl-uri-name>)
  
  nabl-lookup-local-import(|ctx, ns, name) =
    nabl-uri-parent
  ; prop-create-lookup(|ctx, Import(ns)); task-create-insert(|ctx); task-create-combine(|ctx)
  ; nabl-create-resolvedefs(|ctx, ns, name, [])
  
rules
  
  nabl-lookup-lexical-import(|ctx) =
    nabl-uri
  ; nabl-lookup-lexical-import(|ctx, <nabl-uri-namespace>, <nabl-uri-name>)
  
  nabl-lookup-lexical-import(|ctx, ns) =
    nabl-uri
  ; nabl-lookup-lexical-import(|ctx, ns, <nabl-uri-name>)
  
  nabl-lookup-lexical-import(|ctx, ns, name) =
    nabl-uri-parents
  ; map(
      prop-create-lookup(|ctx, Import(ns)); task-create-insert(|ctx); task-create-combine(|ctx)
    ; nabl-create-resolvedefs(|ctx, ns, name, [])
    )
  ; task-create-choice(|ctx)
    
"

  create-nabl-entries = 
    <output-text-file(|["lib", "runtime", "nabl"], "entries.str")>
"module runtime/nabl/entries

imports
  
  runtime/nabl/collect
  runtime/nabl/utils
  runtime/nabl/uri
  runtime/nabl/resolve
  runtime/index/core
  runtime/editor/origins
  
signature

  constructors
    
    Def          : URI    -> Key
    Alias        : URI    -> Key
    InverseAlias : URI    -> Key
    Use          : Result -> Key

rules // Index entries to diff for incrementality
  
  nabl-diff-entry = ?Def(_)
  nabl-diff-entry = ?Alias(_)
 
rules
  
  new-def(|source, uri):
    x -> definition
    with
      definition := <origin-track-forced(!Def(uri))> x;
      <index-collect(|source)> definition;
      <new-alias(|source, <nabl-nonunique-uri> uri, uri)> x
      
  new-alias(|source, uri, alias-uri):
    _ -> alias
    with
      alias  := Alias(uri);
      ialias := InverseAlias(alias-uri);
      if <not(eq)> (uri, alias-uri) then
        <index-collect(|alias-uri, source)> alias;
        <index-collect(|uri, source)> ialias
      end

  new-use(|partition, uri):
    x -> use
    with
      use := <origin-track-forced(!Use(uri))> x

rules // index uri & value projections
  
  /** @internal */
  nabl-uri:
    Def(uri) -> uri

  /** @internal */
  nabl-uris:
    Def(uri) -> [uri]
    
  /** @internal */
  nabl-uri:
    Alias(uri) -> uri
    
  /** @internal */
  nabl-uris:
    Alias(uri) -> [uri]
    
  /** @internal */
  nabl-uri:
    InverseAlias(uri) -> uri
    
  /** @internal */
  nabl-uris:
    InverseAlias(uri) -> [uri]
    
  /** @internal */  
  nabl-uri:
    Use(uri) -> <nabl-collect-one-resolved-def; nabl-uri> uri
    
  /** @internal */  
  nabl-uris:
    Use(uri) -> <nabl-collect-all-resolved-defs; map(nabl-uri)> uri

"

  create-nabl-incremental = 
    <output-text-file(|["lib", "runtime", "nabl"], "incremental.str")>
"module nbl/incremental

imports
  
  runtime/nabl/uri
  runtime/nabl/interface
  runtime/task/core
  
rules // Read generation
  
  nabl-add-uri-read(|task-id):
    uri -> uri
    with
      <try(nabl-replace-uri-qualifier(|())); task-add-read(|task-id)> uri
      
  nabl-add-ns-read(|task-id, namespace):
    uri -> uri
    with
      <task-add-read(|task-id)> (uri, namespace)
      
  nabl-add-name-read(|task-id, namespace, name):
    uri -> uri
    with
      <nabl-extend-uri(|namespace, name, ()); task-add-read(|task-id)> uri
      
rules // Read processing
  
  nabl-get-changed-reads:
    changed-entry* -> [uri-read*, ns-read*]
    with
      uri*      := <filter(nabl-diff-entry; nabl-uri)> changed-entry*;
      uri-read* := <map(try(nabl-replace-uri-qualifier(|())))> uri*;
      ns-read*  := <filter(nabl-create-ns-read)> uri*
  
  nabl-create-ns-read:
    uri -> (uri', ns)
    where
      ns   := <nabl-uri-namespace> uri;
      uri' := <nabl-uri-parent> uri

"

  create-nabl-interface = 
    <output-text-file(|["lib", "runtime", "nabl"], "interface.str")>
"module runtime/nabl/interface

strategies // Collect
  
  nabl-collect-rewrite(|lang, partition, old-uri*, new-uri*) = fail
  
  nabl-scoping-site = fail
  
  nabl-new-scoping-site = fail
  
  nabl-def-site(
    child-uris, sibiling-uris, implicits
  | lang, partition, unique*, uri*, state*
  ) = fail
  
  nabl-external-def-site(|lang, partition, unique*, uri*, state*, implicit*) = fail

  nabl-state-site = fail
  
  nabl-use-site(|lang, partition, unique*, uri*, state*) = fail
  
  nabl-filtering-site(|lang, partition, unique*, uri*, state*) = fail
  
  nabl-disambiguation-site(|lang, partition, unique*, uri*, state*) = fail
  
  nabl-import-site(|lang, partition, unique*, uri*, state*) = fail
  
  nabl-prop-site(|lang, partition, uri*, state*, implicit*) = fail
  
strategies // Projections
  
  nabl-get-name = fail
  
  nabl-name-apply(s) = fail
  
strategies // Lookup hooks
    
  nabl-filter-def(|ctx, uri*, ctx-terms, ctx-string) = fail
  
  nabl-disambiguate-def(|ctx, uri*, ctx-terms, ctx-string) = fail

strategies // Name generation
  
  nabl-namegen-name(|lang, partition, uri, ns) = fail
  
strategies // Default error checks
  
  nabl-check-disable-unresolved = fail
  
  nabl-check-disable-duplicate(|uri, ns) = fail
  
  nabl-check-disable-hiding(|uri, ns) = fail
  
strategies // Incrementality
  
  nabl-diff-entry = fail
  
"

  create-nabl-lookup = 
    <output-text-file(|["lib", "runtime", "nabl"], "lookup.str")>
"module runtime/nabl/lookup

imports
  
  runtime/nabl/query
  runtime/nabl/uri
  runtime/nabl/collect
  runtime/properties/query
  runtime/task/core

rules // Lookup
  
  nabl-lookup(|ns, name):
    uri -> def*
    with
      uri' := <nabl-extend-uri(|ns, name, NonUnique())> uri;
      def* := <nabl-get-all-definitions> uri'

  nabl-lookup-all(|ns):
    uri -> def*
    with
      def*  := <nabl-get-child-definitions(|ns)> uri

"

  create-nabl-namegen = 
    <output-text-file(|["lib", "runtime", "nabl"], "namegen.str")>
"module nbl/namegen

imports
  
  runtime/nabl/collect
  runtime/nabl/query
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/nabl/interface
  runtime/editor/origins
  runtime/editor/annotations
  runtime/index/core
  runtime/index/query
  
signature

  constructors
    
    GenerateName : Namespace -> GenerateName
    GenerateNum  : URI -> Key
  
rules
  
  nabl-namegen-stem(|ns) = add-annotation(|GenerateName(ns))

rules // Name generation
  
  nabl-namegen(|lang, partition, unique*, uri*, anno*):
    name -> <origin-track-forced(!newname{anno'*})> name
    where
      <get-annotation(?GenerateName(ns))> name;
      uri      := <lookup-uri(|lang, ns)> uri*;
      newname  := <nabl-namegen-get(|lang, partition, ns, uri, unique*)> name;
      anno'*   := <remove-all(?GenerateName(_))> anno*
  
  nabl-namegen-get(|lang, partition, ns, uri, unique*):
    name -> result
    with
      name-key := (name, \"namegen\");
      if full-newname := <hashtable-get(|name-key)> unique* then
        result := full-newname
      else
        nextnum := <nabl-namegen-get-num(|uri) <+ !0>;
        numstr  := <int-to-string> nextnum;
        newname := <nabl-namegen-name-create(|lang, partition, uri, ns)> numstr;
        result  := $[[newname][numstr]];
        <hashtable-put(|name-key, result)> unique*;
        <inc; nabl-namegen-store-num(|partition, uri)> nextnum
      end

rules // Name generation strategies
      
  nabl-namegen-name-create(|lang, partition, uri, ns) = 
    nabl-namegen-name(|lang, partition, uri, ns) <+ nabl-namegen-name-generic(|lang, partition, uri, ns)
      
  nabl-namegen-name-generic(|lang, partition, uri, ns):
    name -> <nabl-namegen-name-generic-fix> 
      $[[<nabl-namegen-name-generic-str> lang-name][<nabl-namegen-name-generic-str> partition][ns-name][uri-name][name]]
    with
      Language(lang-name) := lang;
      ns-name             := <get-constructor; nabl-namegen-name-generic-str> ns;
      uri-name            := <nabl-uri-path; filter(nabl-segment-name; nabl-namegen-name-generic-str); concat-strings> uri
  
  nabl-namegen-name-generic-str = 
    explode-string; reverse; (take(|3) <+ take(|2) <+ take(|1) <+ ![]); reverse; implode-string
      
  nabl-namegen-name-generic-fix = 
    lower-case; string-replace(|\"/\", \"_\"); string-replace(|\"-\", \"_\"); string-replace(|\".\", \"_\")

rules // Storage & retrieval
  
  nabl-namegen-get-num(|uri)              = <index-get-all-values; !(<id>, 0); foldl(max)> GenerateNum(uri)
  nabl-namegen-store-num(|partition, uri):
    value -> <index-add(|value, <nabl-namegen-partition(|partition)>)> GenerateNum(uri)
  nabl-namegen-clear(|partition)          = nabl-namegen-partition(|partition); index-clear-source
  nabl-namegen-partition(|partition)      = !$[[partition]_namegen]
  nabl-uri                                : GenerateNum(uri) -> uri
  
"

  create-nabl-query = 
    <output-text-file(|["lib", "runtime", "nabl"], "query.str")>
"module runtime/nabl/query

imports
  
  runtime/nabl/uri
  runtime/nabl/entries
  runtime/index/query
  runtime/task/core
  runtime/task/insert
  
rules // Specific queries

  /**
   * Gets all unique and non-unique definition entries that match the given URI.
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Def(uri))
   */
  nabl-get-all-definitions:
    contains-uri* -> <mapconcat(nabl-get-unique-nonunique(!Def(<id>)))> uri*
    where
      uri* := <nabl-uris> contains-uri*
      
  /**
   * Gets all child definition entries in given URI that match given namespace.
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Def(uri))
   */
  nabl-get-child-definitions(|namespace):
    contains-uri* -> def*
    where
      uri* := <nabl-uris> contains-uri*;
      def* := <mapconcat(!Def(<id>); nabl-get-all-childs(|namespace)); mapconcat(nabl-uri; nabl-get-unique-nonunique(!Def(<id>)))> uri*

  /**
   * Gets all Alias entries that match the given URI.
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(aliasURI)
   */
  nabl-get-all-aliases:
    contains-uri* -> alias-uri*
    where
      uri*           := <nabl-uris> contains-uri*;
      nonunique-uri* := <filter(nabl-replace-uri-qualifier(|NonUnique()))> uri*;
      alias-uri*     := <mapconcat(!Alias(<id>); index-get-all-values)> nonunique-uri*
      
  /**
   * Gets all InverseAlias entries that match the given URI.
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(inverseAliasURI)
   */
  nabl-get-all-inverse-aliasses:
    contains-uri* -> inverse-alias*
    where
      uri*           := <nabl-uris> contains-uri*;
      inverse-alias* := <mapconcat(!InverseAlias(<id>); index-get-all-values)> uri*

rules // Generic queries
  
  nabl-get-all-childs:
    key -> entries
      with
        entries  := <index-get-all-childs> key

  nabl-get-all-childs(|namespace):
    key -> entries
      with
        children := <index-get-all-childs> key;
        entries  := <nabl-filter-entries(|namespace)> children
        
  nabl-get-all-childs(|namespace, prefix):
    key -> entries
      with
        children := <index-get-all-childs> key;
        entries  := <nabl-filter-entries(|namespace, prefix)> children

  nabl-get-unique-nonunique(create-key):
    uri -> [unique*, non-unique*]
    where
      if alias* := <nabl-get-all-aliases> uri then
        // HACK: handle Result terms on the resulting URI of an alias. this should be decomposed into a task?
        (alias-result*, alias-uri*) := <partition(?Result(_); insert-results-or-delay)> alias*;
        unique-uri*                 := <mapconcat(create-key; index-get-all-values)> alias-uri*;
        unique-result*              := <try(concat)> alias-result*;
        unique*                     := [unique-uri*, unique-result*]
      else
        unique* := []
      end;
      if non-unique-uri := <nabl-replace-uri-qualifier(|NonUnique())> uri then
        non-unique* := <create-key; index-get-all-values> non-unique-uri
      else
        non-unique* := []
      end

rules /** @internal Entry filtering */
  
  /** @internal */
  nabl-filter-entries(|namespace, prefix):
    entry* -> <filter(nabl-compare-prefix(|namespace, prefix))> entry*
  
  /** @internal */
  nabl-filter-entries(|namespace):
    entry* -> <filter(nabl-compare-namespace(|namespace))> entry*

rules /** @internal Helpers */
  
  /** @internal */
  nabl-compare-prefix(|namespace, prefix):
    entry -> <id>
    where
      uri := <nabl-uri> entry;
      <eq> (namespace, <nabl-uri-namespace> uri);
      <is-substring(!prefix)> <nabl-uri-name> uri
      
  /** @internal */
  nabl-compare-namespace(|namespace):
    entry -> <id>
    where
      uri := <nabl-uri> entry;
      <eq> (namespace, <nabl-uri-namespace> uri)

"

  create-nabl-resolve = 
    <output-text-file(|["lib", "runtime", "nabl"], "resolve.str")>
"module runtime/nabl/resolve

imports
  
  runtime/nabl/tasks
  runtime/nabl/entries
  runtime/task/core
  runtime/task/insert
  runtime/task/utils
  
rules // Reference resolution
  
  nabl-is-reference =
    ?Use(_)
    
  nabl-has-reference =
    collect-one(nabl-is-reference)
    
  nabl-has-reference =
    has-annos;
    get-annos;
    nabl-has-reference
  
  nabl-collect-all-resolved-defs:
    ast -> def*
    with
      if ast' := <insert-results-or-delay> ast then
        def* := <collect-all-annos(?Def(_), conc)> ast'
      else
        def* := []
      end

  nabl-collect-one-resolved-def =
    insert-results-or-delay;
    collect-one-annos(?Def(_))

"

  create-nabl-tasks = 
    <output-text-file(|["lib", "runtime", "nabl"], "tasks.str")>
"module runtime/nabl/tasks

imports 
  
  runtime/task/core
  runtime/task/create
  runtime/task/insert
  runtime/task/tasks
  runtime/task/utils
  runtime/nabl/lookup
  runtime/nabl/collect
  runtime/nabl/query
  runtime/nabl/incremental
  runtime/nabl/interface
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/nabl/entries
  runtime/properties/collect
  runtime/properties/entries
  runtime/properties/eq
  runtime/properties/query
  runtime/properties/tasks
  
signature
  
  constructors
    
    CollectDefs            : Term                                      -> Instruction
    ResolveDefs            : Scope * Namespace * Name * Prop           -> Instruction
    ResolveAllDefs         : Scope * Namespace                         -> Instruction
    ResolveAllDefs         : Scope * Namespace * Name * Prop           -> Instruction
    CheckDefs              : Namespace * URI                           -> Instruction
    PropConstraint         : Kind * Expected * Result                  -> Instruction
    SubURI                 : Namespace * URI                           -> Instruction
    
    FilterDefsHigherOrder        : List(Def) * List(Term) * List(Term) * String -> Instruction
    FilterDefs                   : List(DefTuple)                               -> Instruction
    
    DisambiguateDefsHigherOrder  : List(Def) * List(Term) * List(Term) * String -> Instruction
    DisambiguateDefs             : List(DefTuple)                               -> Instruction
    
rules // Collects all definitions in a term
  
  nabl-create-collectdefs(|ctx):
    term -> <new-task(|ctx)> CollectDefs(term)

  nabl-create-collectdefs(|ctx, dep*):
    term -> <new-task(|ctx, all-dep*)> CollectDefs(term)
    with 
      all-dep* := <merge-dependencies(|dep*)> term
      
  // todo: lift nabl-get-name to task creation, currently storing an AST in task (expensive storage!)
    
  perform-task(|nr): 
    CollectDefs(term) -> <?Def(_) <+ (try(nabl-get-name); get-annos; fetch(?Def(_) + ?Use(<id>)))> term 

rules // Resolve definitions in a scope of a certain namespace and name (stops when definitions are found in a scope)
  
  nabl-create-resolvedefs(|ctx, ns, name, prop*):
    scope -> <new-task(|ctx)> ResolveDefs(scope, ns, name, prop*)

  
  perform-task(|task-id):
    ResolveDefs(scope, ns, name, prop*) -> result
    where
      uri    := <nabl-uri> scope;
      name'  := <try-remove-list; strip-annos> name;
      <nabl-add-name-read(|task-id, ns, name')> uri;
      def*   := <nabl-lookup(|ns, name')> uri;
      result := <filter(filter-defs-props(|prop*)); not(?[])> def*
      
  task-short-circuit = ?ResolveDefs(_, _, _, _)

rules // Resolve all definitions in a scope of a certain namespace and name
  
  // TODO: This seems to be redundant, given the perform-task rule
  nabl-create-resolvealldefs(|ctx, ns, name, prop*):
    scope -> <new-task(|ctx)> ResolveAllDefs(scope, ns, name, prop*)
  
  
  perform-task(|nr):
    ResolveAllDefs(scope, ns, name, prop*) -> <perform-task(|nr)> ResolveDefs(scope, ns, name, prop*)

rules // Resolve all definitions in a scope of a certain namespace

  nabl-create-resolvealldefs(|ctx, ns):
    scope -> <new-task(|ctx)> ResolveAllDefs(scope, ns)
  
  perform-task(|nr):
    ResolveAllDefs(scope, ns) -> def*
    where
      uri  := <nabl-uri> scope;
      <nabl-add-ns-read(|nr, ns)> uri;
      def* := <nabl-lookup-all(|ns)> uri;
      not(?[])

  // inserts wildcard import resolution tasks into a list of scope URIs
  // each scope URI is wrapped in a list, 
  // followed by the result of a wildcard import resolution task for this URI
  nabl-insert-import-tasks(|ctx, ns) =
    map(try(nabl-uri-strip-barriers))
  ; mapconcat(
      ![ <try(nabl-is-uri; MkSingleton)>
       , <prop-create-lookup(|ctx, Import(ns)); task-create-insert(|ctx); task-create-combine(|ctx)>
       ]
    )
    // TODO: order of imported URI's is unclear
 
  // creates a short-circuit resolution task for a list of scope URIs
  nabl-resolve-task(|ctx, ns, name, prop*) =
    task-create-combine(|ctx) 
  ; nabl-create-resolvedefs(|ctx, ns, name, prop*)
    // TODO: disambiguation
 
  // creates a full resolution task for a list of scope URIs
  nabl-resolve-all-task(|ctx, ns, name, prop*) =
    task-create-combine(|ctx) 
  ; nabl-create-resolvealldefs(|ctx, ns, name, prop*)
    // TODO: disambiguation
  
  // TODO: implement in same style as named version
  nabl-resolve-all-tasks(|partition, ns, prop*) =
    map(
      <new-task(|partition)> ResolveAllDefs(<id>, ns)
    ; <nabl-use-propconstraint(|partition)> (<id>, prop*)
    )
      
rules // Check if a definition is in given namespace

  nabl-create-checkdefs(|ctx, ns):
    definition -> <new-task(|ctx)> CheckDefs(ns, definition)

    
  perform-task(|nr):
    CheckDefs(ns, d) -> d
    where
      <nabl-uri; nabl-uri-namespace; ?ns> d

rules // Filter definitions by properties
      
  filter-defs-props(|prop*):
    definition -> <map(filter-defs-prop(|definition)); !definition> prop*
    
  filter-defs-prop(|definition):
    Prop(kind, expected, _) -> definition
    where
      uri    := <nabl-uri> definition;
      value  := <get-index-property(|kind)> uri;
      value' := <insert-results-or-delay> value;
      <filter-defs-prop-eq(|expected, value')> kind

  filter-defs-prop-eq(|expected, value):
    kind -> <nabl-property-eq> (kind, Eq(), (expected, value))
    
  filter-defs-prop-eq(|expected, value):
    kind -> <nabl-property-eq> (kind, Eq(), (expected, <try-remove-list> value))
  
  
  nabl-create-propconstraint(|ctx, kind, definition):
    expected -> <new-task(|ctx)> PropConstraint(kind, expected, definition)
    
  nabl-create-propconstraint(|ctx, dep*, kind, definition):
    expected -> <new-task(|ctx, all-dep*)> PropConstraint(kind, expected, definition)
    with 
      all-dep* := <merge-dependencies(|dep*)> (kind, expected, definition)
  

  perform-task(|task-id):
    PropConstraint(kind, expected, definition) -> <filter-defs-prop(|definition)> Prop(kind, expected, [])

rules // URI manipulation
  
  nabl-create-suburi(|ctx, namespace):
    contains-uri -> <new-task(|ctx)> SubURI(namespace, contains-uri)
    
  perform-task(|task-id):
    SubURI(namespace, contains-uri) -> <nabl-sub-uri(|namespace)> uri
    where
      uri := <nabl-uri> contains-uri

rules // Filtering

  nabl-create-filter(|ctx, uri*, ctx-terms, ctx-string):
    defs -> <new-task(|ctx)> FilterDefsHigherOrder(defs, uri*, ctx-terms, ctx-string)
  
  task-is-combinator = ?FilterDefsHigherOrder(_, _, _, _)
  task-is-higherorder = ?FilterDefsHigherOrder(_, _, _, _)
  
  perform-task(|task-id):
    FilterDefsHigherOrder(def*, uri*, [ctx-terms], ctx-string) -> FilterDefs(def-tuple*)
    where
      def-tuple* := <filter(nabl-filter-def(|task-id, uri*, ctx-terms, ctx-string))> def*


  task-is-combinator = ?FilterDefs(_)
  
  perform-task(|task-id):
    FilterDefs(def-tuple*) -> <filter(not(?(_, [])))> def-tuple*
    
rules // Disambiguation

  nabl-create-disambiguate(|ctx, uri*, ctx-terms, ctx-string):
    defs -> <new-task(|ctx)> DisambiguateDefsHigherOrder(defs, uri*, ctx-terms, ctx-string)
  
  task-is-combinator = ?DisambiguateDefsHigherOrder(_, _, _, _)
  task-is-higherorder = ?DisambiguateDefsHigherOrder(_, _, _, _)
  
  perform-task(|task-id):
    DisambiguateDefsHigherOrder(def*, uri*, [ctx-terms], ctx-string) -> DisambiguateDefs(def-tuple*)
    where
      def-tuple* := <filter(nabl-disambiguate-def(|task-id, uri*, ctx-terms, ctx-string))> def*


  task-is-combinator = ?DisambiguateDefs(_)
  
  // TODO: this task is not generic enough yet, it currently assumes minimization.
  perform-task(|task-id):
    DisambiguateDefs(def-tuple*) -> def-sorted2*
    where
      def-sorted1* := <sort-list(LSort(\\((_, [x]), (_, [y])) -> <gt> (x, y)\\))> def-tuple*
    ; def-sorted2* := <take-while(?(_, x)); map(Fst)> def-sorted1* // Take all defs with the same distance.
    
"

  create-nabl-uri = 
    <output-text-file(|["lib", "runtime", "nabl"], "uri.str")>
"module runtime/nabl/uri

imports
  
  runtime/index/core
  runtime/editor/annotations
  runtime/nabl/interface
  runtime/nabl/query
  
signature

  sorts
  
    Language
    Segment
    Qualifier
    
  constructors
    
    Language    : String                       -> Language
    ID          : Namespace * Name * Qualifier -> Segment
    Subsequent  : String                       -> Segment
    Anonymous   : String                       -> Segment
    Unique      : String                       -> Qualifier
    NonUnique   :                                 Qualifier
    Unique      :                                 Qualifier
    URI         : Language * List(Segment)     -> URI
    Barrier     : List(Namespace)              -> Annotation
    
rules // Construction
  
  nabl-base-uri = 
    !URI(<id>, [])
     
  nabl-extend-uri(|segment) = 
    URI(id, ![segment|<id>])
    
  nabl-extend-uri(|namespace, name, qualifier) = 
    URI(id, ![ID(namespace, name, qualifier)|<id>])
    
  nabl-replace-uri(|segment) = 
    URI(id, [!segment|id])
    
  nabl-replace-uri(|namespace, name, qualifier) = 
    URI(id, [!ID(namespace, name, qualifier)|id])
    
  nabl-replace-uri-qualifier(|qualifier) =
    URI(id, [ID(id, id, !qualifier)|id])
      
  nabl-nonunique-uri =
    URI(id, [ID(id, id, !NonUnique())|id])
    
  nabl-uri-add-barriers(|namespace*):
    URI(lang, [seg|s]) -> URI(lang, [<replace-annotation(?Barrier(_)|new-barrier)> seg|s])
    where
      existing-namespace* := <get-annotation(?Barrier(<id>)) <+ ![]> seg;
      new-barrier         := Barrier([existing-namespace*, namespace*])
      
  nabl-uri-strip-barriers = 
    URI(id, map(remove-annotations(?Barrier(_))))
    
rules // Stable URI extensions
  
  nabl-extend-uri(|table, partition, ns, n, u):
    uri -> <nabl-extend-uri(|ns, n, qualifier)> uri
    where 
      if where(<?NonUnique()> u) then
        qualifier := NonUnique()
      else
        qualifier := Unique(<stable-uri-part(|table, partition)> (partition, uri, ns, n))
      end
    
  nabl-extend-uri-anonymous(|table, partition):
    uri -> <nabl-extend-uri(|Anonymous(unique))> uri
    where
      unique := <stable-uri-part(|table, partition)> (partition, uri, \"anonymous\")
      
  nabl-extend-uri-subsequent(|table, partition):
    uri -> <nabl-extend-uri(|Subsequent(unique))> uri
    where
      unique := <stable-uri-part(|table, partition)> (partition, uri, \"subsequent\")

  stable-uri-part(|table, partition):
    key -> $[[partition]/[unique]]
    where
      if value := <hashtable-get(|key)> table then
        unique    := <int-to-string> value;
        new-value := <inc> value
      else
        unique    := \"0\";
        new-value := 1
      end;
      <hashtable-put(|key, new-value)> table
      
rules // Projections
  
  nabl-uri = fail
  nabl-uris = fail
  
  nabl-uri-language:
    URI(language, _) -> language
    
  nabl-uri-language-name:
    URI(Language(name), _) -> name
    
  nabl-uri-path:
    URI(_, path) -> path
        
  nabl-uri-name:
    uri -> <nabl-uri-path; Hd; nabl-segment-name> uri
    
  nabl-uri-namespace:
    uri -> <nabl-uri-path; Hd; nabl-segment-namespace> uri    

  nabl-uri-qualifier:
    uri -> <nabl-uri-path; Hd; nabl-segment-qualifier> uri
    
  nabl-uri-barriers:
    uri -> <nabl-uri-path; Hd; nabl-segment-barriers> uri
      
  nabl-segment-namespace:
    ID(namespace, _, _) -> namespace
    
  nabl-segment-name:
    ID(_, name, _) -> name
    
  nabl-segment-name:
    Subsequent(name) -> name
  
  nabl-segment-name:
    Anonymous(name) -> name
    
  nabl-segment-qualifier:
    ID(_, _, qualifier) -> qualifier
    
  nabl-segment-barriers:
    segment -> namespace*
    where
      Barrier(namespace*) := <get-annotation(?Barrier(_))> segment 
   
  nabl-closure(s) = 
      s 
    < ![<id>|<nabl-closure(s)>] 
    + ![]

rules // query scope URIs
  
  // TODO: where should we strip barriers here?
  nabl-uri-parent  = URI(id, Tl)
  nabl-uri-parents = nabl-closure(nabl-uri-parent)
      
  nabl-uri-parents(|target-ns):
    uri -> parent*
    where
      barrier-ns* := <nabl-uri-barriers <+ ![]> uri;
      if <not(elem)> (target-ns, barrier-ns*); parent := <nabl-uri-parent> uri then
        // Strip barriers from parent because URI's in the index also do not have barriers (matching would fail).
        parent* := [<nabl-uri-strip-barriers> parent|<nabl-uri-parents(|target-ns)> parent]
      else
        parent* := [] 
      end
  
  //  maps a list of definition URIs to a list of local scope URIs
  nabl-uri-local-scopes =
    ![<nabl-uri-parent>]
  
  // maps a list of definition URIs to a list of lexical scope URIs (including local scope)
  nabl-uri-lexical-scopes =
    nabl-uri-parents
    
  // maps a list of definition URIs to a list of lexical scope URIs (excluding local scope)
  nabl-uri-lexical-parent-scopes =
    nabl-uri-parent; nabl-uri-parents
  
  // maps a list of external definition URIs to a list of local scope URIs
  nabl-uri-external-scopes =
    nabl-get-all-inverse-aliasses
  ; map(nabl-uri-parent)
  
  // maps a list of external definition URIs to a list of lexical scope URIs (including local scope)
  nabl-uri-external-lexical-scopes =
    nabl-get-all-inverse-aliasses
  ; mapconcat(nabl-uri-lexical-scopes)
  
  // maps a list of external definition URIs to a list of lexical scope URIs (excluding local scope)
  nabl-uri-external-lexical-parent-scopes =
    nabl-get-all-inverse-aliasses
  ; mapconcat(nabl-uri-lexical-parent-scopes)
  
  nabl-uri-all-local-scopes =
    <conc> (<nabl-uri-local-scopes>, <nabl-uri-external-scopes>)
    
  nabl-uri-all-lexical-scopes =
    <conc> (<nabl-uri-lexical-scopes>, <nabl-uri-external-lexical-scopes>)
  
  nabl-uri-all-lexical-parent-scopes =
    <conc> (<nabl-uri-lexical-parent-scopes>, <nabl-uri-external-lexical-parent-scopes>)
    
  nabl-sub-uri(|namespace):
    uri -> <nabl-uri-strip-barriers> uri
    where
      nabl-uri-namespace => namespace
    
  nabl-sub-uri(|namespace):
    uri -> <nabl-uri-parent; nabl-sub-uri(|namespace); nabl-uri-strip-barriers> uri
    where
      not(nabl-uri-namespace => namespace)
    
rules // Conditions
  
  nabl-is-uri =
    ?URI(_, _)
  
  nabl-is-unique =
    nabl-uri-qualifier;
    ?Unique(_)
    
  nabl-is-nonunique =
    nabl-uri-qualifier;
    ?NonUnique()
    
  nabl-segment-is-id =
    ?ID(_, _, _)

rules // Equality
  
  nabl-uri-eq = 
    ?(URI(lang1, segs1), URI(lang2, segs2));
    <eq> (lang1, lang2);
    <zip(nabl-uri-segment-eq)> (segs1, segs2)
    
  nabl-uri-segment-eq =
    ?(ID(ns1, name1, _), ID(ns2, name2, _));
    <eq> (ns1, ns2);
    <eq> (name1, name2)
     
  nabl-uri-segment-eq =
    ?(Subsequent(_), Subsequent(_))
    
  nabl-uri-segment-eq =
    ?(Anonymous(_), Anonymous(_))
    
  nabl-uri-namespace-eq(|namespace) =
    nabl-uri-namespace; ?namespace
    
rules // Printing
  
  nabl-print-uri:
    uri -> $[[ns] [names]]
    where
      ns#(_) := <nabl-uri-namespace> uri;
      names  := <nabl-uri-path; filter(nabl-segment-name); separate-by(|\".\"); concat-strings> uri
        
rules /** @internal Projections */

  /** @internal */
  nabl-uri:
    URI(_, _) -> <id>
 
  /** @internal */
  nabl-uris:
    URI(_, _) -> [<id>]

  /** @internal */  
  nabl-uri =
    has-annos;
    get-annos;
    fetch-elem(nabl-uri)

  /** @internal */  
  nabl-uris =
    has-annos;
    get-annos;
    filter(nabl-uri)

"

  create-nabl-utils = 
    <output-text-file(|["lib", "runtime", "nabl"], "utils.str")>
"module runtime/nabl/utils

imports
  
  libstratego-lib
  libstratego-aterm
  libstratego-gpp
  runtime/task/core
  runtime/editor/annotations

rules 
  
  match(m|val) = where (!val; m)
  
  vdebug(s) = where(verbose < debug(s) + id)
  verbose   = fail

  is-completion-name = ?\"completion123\"
  fix-completion-name = is-completion-name; !\"\"
    
  try-make-list = is-list <+ ![<id>]
    
  try-remove-list = is-list < Hd + id
  
  // @deprecated use runtime/editor/annotations get-annotation(s)
  has-annotation(s) = get-annotation(s)
  
rules // multimap simulation
  
  hash-multimap-put(|key, value):
    hashtable -> hashtable
    where
      values := <hash-multimap-getorcreate(|key)> hashtable;
      <hashtable-put(|key, [value|values])> hashtable 
      
  hash-multimap-putlist(|key, put-value*):
    hashtable -> hashtable
    where
      value* := <hash-multimap-getorcreate(|key)> hashtable;
      <hashtable-put(|key, [value*, put-value*])> hashtable 
      
  hash-multimap-getorcreate(|key) =
    hashtable-get(|key) <+ hashtable-put(|key, []); ![]
  
  hash-multimap-copy(|from):
    to -> to
    where
      // wtf is this I don't even.. hashtable-fold needs term arguments instead of current term arguments.
      <hashtable-fold(hash-multimap-copy-fold|to)> from
      
  hash-multimap-copy-fold(|key, value*):
    to -> <hash-multimap-putlist(|key, value*)> to

rules // Debugging
  
  debug(|t) = where(write-to-string; debug(!t))
  
  debug0 = debug(|\"0 \")
  debug1 = debug(|\"1 \")
  debug2 = debug(|\"2 \")
  debug3 = debug(|\"3 \")
  debug4 = debug(|\"4 \")
  debug5 = debug(|\"5 \")
  debug6 = debug(|\"6 \")
  debug7 = debug(|\"7 \")
  debug8 = debug(|\"8 \")
  debug9 = debug(|\"9 \")

  debuga = debug(|\"a \")
  debugb = debug(|\"b \")
  debugc = debug(|\"c \")
  debugd = debug(|\"d \")
  debuge = debug(|\"e \")
  debugf = debug(|\"f \")
  debugg = debug(|\"g \")
  debugh = debug(|\"h \")
  debugi = debug(|\"i \")
  debugj = debug(|\"j \")
  debugk = debug(|\"k \")
  debugl = debug(|\"l \")
  debugm = debug(|\"m \")
  debugn = debug(|\"n \")
  debugo = debug(|\"o \")
  debugp = debug(|\"p \")
  debugq = debug(|\"q \")
  debugr = debug(|\"r \")
  debugs = debug(|\"s \")
  debugt = debug(|\"t \")
  debugu = debug(|\"u \")
  debugv = debug(|\"v \")
  debugw = debug(|\"w \")
  debugx = debug(|\"x \")
  debugy = debug(|\"y \")
  debugz = debug(|\"z \")

  
  pp-aterm = pp-aterm-box; box2text-string(|80)
  ppdebug(|t) = where(pp-aterm; debug(!t))

  ppdebug0 = ppdebug(|\"0 \")
  ppdebug1 = ppdebug(|\"1 \")
  ppdebug2 = ppdebug(|\"2 \")
  ppdebug3 = ppdebug(|\"3 \")
  ppdebug4 = ppdebug(|\"4 \")
  ppdebug5 = ppdebug(|\"5 \")
  ppdebug6 = ppdebug(|\"6 \")
  ppdebug7 = ppdebug(|\"7 \")
  ppdebug8 = ppdebug(|\"8 \")
  ppdebug9 = ppdebug(|\"9 \")
  
  ppdebuga = ppdebug(|\"a \")
  ppdebugb = ppdebug(|\"b \")
  ppdebugc = ppdebug(|\"c \")
  ppdebugd = ppdebug(|\"d \")
  ppdebuge = ppdebug(|\"e \")
  ppdebugf = ppdebug(|\"f \")
  ppdebugg = ppdebug(|\"g \")
  ppdebugh = ppdebug(|\"h \")
  ppdebugi = ppdebug(|\"i \")
  ppdebugj = ppdebug(|\"j \")
  ppdebugk = ppdebug(|\"k \")
  ppdebugl = ppdebug(|\"l \")
  ppdebugm = ppdebug(|\"m \")
  ppdebugn = ppdebug(|\"n \")
  ppdebugo = ppdebug(|\"o \")
  ppdebugp = ppdebug(|\"p \")
  ppdebugq = ppdebug(|\"q \")
  ppdebugr = ppdebug(|\"r \")
  ppdebugs = ppdebug(|\"s \")
  ppdebugt = ppdebug(|\"t \")
  ppdebugu = ppdebug(|\"u \")
  ppdebugv = ppdebug(|\"v \")
  ppdebugw = ppdebug(|\"w \")
  ppdebugx = ppdebug(|\"x \")
  ppdebugy = ppdebug(|\"y \")
  ppdebugz = ppdebug(|\"z \")
  
  
  ppdebugna(|t) = where(strip-annos; pp-aterm; debug(!t))

  ppdebugna0 = ppdebugna(|\"0 \")
  ppdebugna1 = ppdebugna(|\"1 \")
  ppdebugna2 = ppdebugna(|\"2 \")
  ppdebugna3 = ppdebugna(|\"3 \")
  ppdebugna4 = ppdebugna(|\"4 \")
  ppdebugna5 = ppdebugna(|\"5 \")
  ppdebugna6 = ppdebugna(|\"6 \")
  ppdebugna7 = ppdebugna(|\"7 \")
  ppdebugna8 = ppdebugna(|\"8 \")
  ppdebugna9 = ppdebugna(|\"9 \")
  
  ppdebugnaa = ppdebugna(|\"a \")
  ppdebugnab = ppdebugna(|\"b \")
  ppdebugnac = ppdebugna(|\"c \")
  ppdebugnad = ppdebugna(|\"d \")
  ppdebugnae = ppdebugna(|\"e \")
  ppdebugnaf = ppdebugna(|\"f \")
  ppdebugnag = ppdebugna(|\"g \")
  ppdebugnah = ppdebugna(|\"h \")
  ppdebugnai = ppdebugna(|\"i \")
  ppdebugnaj = ppdebugna(|\"j \")
  ppdebugnak = ppdebugna(|\"k \")
  ppdebugnal = ppdebugna(|\"l \")
  ppdebugnam = ppdebugna(|\"m \")
  ppdebugnan = ppdebugna(|\"n \")
  ppdebugnao = ppdebugna(|\"o \")
  ppdebugnap = ppdebugna(|\"p \")
  ppdebugnaq = ppdebugna(|\"q \")
  ppdebugnar = ppdebugna(|\"r \")
  ppdebugnas = ppdebugna(|\"s \")
  ppdebugnat = ppdebugna(|\"t \")
  ppdebugnau = ppdebugna(|\"u \")
  ppdebugnav = ppdebugna(|\"v \")
  ppdebugnaw = ppdebugna(|\"w \")
  ppdebugnax = ppdebugna(|\"x \")
  ppdebugnay = ppdebugna(|\"y \")
  ppdebugnaz = ppdebugna(|\"z \")

"

  create-properties-collect = 
    <output-text-file(|["lib", "runtime", "properties"], "collect.str")>
"module runtime/properties/collect

imports 
  
  runtime/properties/entries
  runtime/properties/tasks
  runtime/properties/interface
  runtime/properties/query
  runtime/properties/debug
  runtime/task/core
  runtime/task/create
  runtime/task/messages
  runtime/task/tasks
  runtime/nabl/collect
  runtime/nabl/uri
  runtime/nabl/tasks
  runtime/nabl/utils
  runtime/editor/origins
  runtime/editor/annotations
  runtime/types/collect
  
signature
  
  sorts
  
    Property
    
  constructors
    
    Prop : Property * Value * List(Dependency) -> Prop

rules // generic analysis of properties
  
  // call back to generic analysis
  nabl-store-props(|partition, prop*):
    name -> name
    where
      uri := <nabl-collect-def; nabl-uri> name
    ; <map(nabl-store-prop(|partition, uri, name))> prop*
  
  nabl-store-prop(|partition, prop):
    name -> name
    where
      uri := <nabl-collect-def; nabl-uri> name
    ; <nabl-store-prop(|partition, uri, name)> prop
      
  nabl-store-prop(|partition, uri, name):
    Prop(kind, prop, dep*) -> <new-prop(|partition, uri, kind, task)> name
    where
      task := <task-create-make-set(|partition, <dependent-tasks> dep*)> prop
      
rules
        
  nabl-collect-custom-properties =
    iset := <new-iset>
  ; try(nabl-custom-properties(\\p* -> <iset-addlist(|p*); fail> iset\\))
  ; <iset-elements> iset
    
  nabl-get-all-properties = ![Type()|<nabl-collect-custom-properties>]
  
  // generic collection of property tasks
  nabl-annotate-properties(|lang, partition, old-uri*, new-uri*):
    term -> term'
    where
      kind* := <nabl-get-all-properties>
    ; term' := <foldl(nabl-annotate-property(|lang, partition, old-uri*, new-uri*) <+ Snd)> (kind*, term)
    ; try(nabl-constraint(|lang, partition, old-uri*, new-uri*))
  
  nabl-annotate-property(|lang, partition, old-uri*, new-uri*):
    (kind, term{a*}) -> term{(kind, prop), a*}
    where
      not(<get-property-task(|kind)> term)
    ; prop := <create-property-task(|partition, kind, old-uri*, new-uri*) <+ create-property-task(|partition, kind, new-uri*) <+ create-property-task(|partition, kind)> term
      
strategies
  
  nabl-prop-calc(|partition, dep*):
    term -> <task-create-id(|partition, dep*)> term
  
  nabl-prop-list(|partition, dep*):
    term -> <task-create-combine(|partition, dep*)> term
  
  nabl-prop-lookup(|kind, partition, dep*):
    term -> result
    with
      result := <get-annos; fetch-elem(?(kind, <id>))> term
      <+ 
      result := <nabl-create-collectdefs(|partition, dep*); prop-create-lookup(|partition, kind)> term
  
  nabl-prop-match(|kind, partition, relation, expected):
    actual -> <task-create-choice(|partition)> check*
    with 
      expected* := <try-make-list> expected
    ; check*    := <map(prop-create-check(|partition, kind, relation, actual))> expected*

rules
  
  get-or-create-property-task(|ctx, kind, old-uri*, new-uri*):
    term -> task
    where
      (
         get-property-task(|kind)
      <+ create-property-task(|ctx, kind, old-uri*, new-uri*)
      <+ create-property-task(|ctx, kind, new-uri*)
      <+ create-property-task(|ctx, kind)
      <+ cannot-create-property-task(|ctx, kind)
      ) => task
  
  get-or-create-property-task(|ctx, kind):
    term -> task
    where
      ( 
          get-property-task(|kind)
      <+ (create-property-task(|ctx, kind, [], []); uris-not-passed(|ctx, kind))  
      <+ (create-property-task(|ctx, kind, []);     uris-not-passed(|ctx, kind))
      <+  create-property-task(|ctx, kind)
      <+  cannot-create-property-task(|ctx, kind)
      ) => task
      
  uris-not-passed(|ctx, kind):
    term -> <properties-warning-task(|ctx, msg); properties-console-msg(|msg)> term
    where
      msg := $[Called create-property-task for property [<get-constructor> kind] on term [<write-to-string> term] that accepts uris with empty lists instead, because uris were not passed!]
      
  cannot-create-property-task(|ctx, kind):
    term -> <properties-warning-task(|ctx, msg); properties-console-msg(|msg)> term
    where
      msg := $[Could not create task for property [<get-constructor> kind] on term [<write-to-string> term].]
      
  create-property-task(|ctx, kind):
    r@Result(_) -> <prop-create-extract(|ctx, kind)> r
    
  create-property-task(|ctx, kind) :
    term -> <nabl-prop-calc(|ctx, type*)> type*
    where 
      type* := <map(get-property-task(|kind) <+ create-property-task(|ctx, kind))> term
    
rules
  
  remove-property-annotations(|kind*):
    term -> <foldl(remove-property-annotation)> (kind*, term)
    
  remove-property-annotation:
    (kind, term) -> <remove-annotations(?(kind, _))> term

"

  create-properties-debug = 
    <output-text-file(|["lib", "runtime", "properties"], "debug.str")>
"module runtime/properties/debug

imports
  
  runtime/task/messages
  runtime/task/tasks
  runtime/nabl/utils
  
rules
  
  properties-console-msg-enable = fail
  properties-console-msg(|msg) = where(try(properties-console-msg-enable; err-msg(|msg)))
  
  properties-warning-task-disable = fail
  properties-warning-task(|ctx, msg):
    term -> <task-create-fail(|ctx)>
    where
      <properties-warning-task-disable <+ task-create-warning(|ctx, msg)> term

"

  create-properties-entries = 
    <output-text-file(|["lib", "runtime", "properties"], "entries.str")>
"module runtime/properties/entries

imports
  
  runtime/nabl/collect
  runtime/nabl/utils
  runtime/nabl/uri
  runtime/index/core
  runtime/editor/origins
  
signature

  constructors
    
    Prop  : URI * Property -> Key

rules // Index entries to diff for incrementality
  
  nabl-diff-entry = ?Prop(_, _)

rules
  
  new-prop(|source, uri, kind, val):
    x -> prop
    with
      prop := Prop(uri, kind);
      <index-collect(|<origin-track-forced(!val)> x, source)> Prop(uri, kind)
        
rules // index uri & value projections
  
  /** @internal */  
  nabl-uri:
    Prop(uri, _) -> uri
    
  /** @internal */  
  nabl-uris:
    Prop(uri, _) -> [uri]

"

  create-properties-eq = 
    <output-text-file(|["lib", "runtime", "properties"], "eq.str")>
"module runtime/properties/eq

signature constructors
  
  Eq: Relation
  
strategies
  
  nabl-reflexive = ?Eq()
  
  nabl-property-eq:
    (_, rel, p) -> <where(strip-annos; eq); Fst> p
    where
      <nabl-reflexive> rel
  
  nabl-property-eq(|kind, rel, expected):
    actual -> <nabl-property-eq> (kind, rel, (actual, expected))

"

  create-properties-interface = 
    <output-text-file(|["lib", "runtime", "properties"], "interface.str")>
"module runtime/properties/interface

strategies // implementations generated from NaBL
  
  nabl-custom-properties(add-properties) = fail
  
  create-property-task(|ctx, kind) = fail
  
  create-property-task(|ctx, kind, uri*) = fail

  create-property-task(|ctx, kind, old-uri*, new-uri*) = fail

strategies // user-defined implementations
  
  nabl-constraint(|lang, partition, old-uri*, new-uri*) = nabl-constraint(|lang, partition, new-uri*)

  nabl-constraint(|lang, partition, uri*) = nabl-constraint(|partition)

  nabl-constraint(|partition) = fail

  nabl-property-eq = fail
  
"

  create-properties-query = 
    <output-text-file(|["lib", "runtime", "properties"], "query.str")>
"module runtime/properties/query

imports
  
  runtime/index/query
  runtime/nabl/uri
  runtime/task/core
  runtime/properties/entries
  runtime/properties/tasks
  runtime/properties/interface
  runtime/nabl/interface
  runtime/editor/annotations

rules

  get-property-task(|kind) =
     map(get-property-task(|kind))
  <+ get-annos
   ; fetch-elem(?(kind, <id>))
    
rules
  
  get-property(|kind) =
    (get-property-task(|kind) <+ try(nabl-get-name); get-index-property(|kind))
  ; try(task-result-combinations-single; Hd) // Try because results may already be inserted? 
  
  get-properties(|kind) =
    (get-property-task(|kind) <+ try(nabl-get-name); get-index-properties(|kind))
  ; try(task-result-combinations-single; concat)
  
  get-index-property(|kind) =
    nabl-uris // TODO: how to handle multiple values?
  ; fetch-elem(!Prop(<id>, kind); index-get-one-value)
   
  get-index-properties(|kind) =
    nabl-uris // TODO: how to handle multiple values?
  ; mapconcat(!Prop(<id>, kind); index-get-all-values)

rules
  
  property-remove-all = topdown(try(remove-annotations(?(_, _))))

"

  create-properties-tasks = 
    <output-text-file(|["lib", "runtime", "properties"], "tasks.str")>
"module runtime/properties/tasks

imports 
  
  runtime/nabl/incremental
  runtime/nabl/uri
  runtime/properties/query
  runtime/properties/eq
  runtime/task/core
  runtime/task/create
  runtime/editor/annotations

signature
  
  constructors

    PropsLookup : Property * URI                    -> Instruction
    PropCheck   : Property * Relation * Term * Term -> Instruction
    PropExtract : Property * Term                   -> Instruction
    
rules

  prop-create-lookup(|ctx, kind):
    contains-uri -> <new-task(|ctx)> PropsLookup(kind, contains-uri)

  perform-task(|n):
    PropsLookup(kind, contains-uri) -> res
    where
      uri := <nabl-uri> contains-uri
    ; <nabl-add-uri-read(|n)> uri
    ; val := <get-index-properties(|kind)> uri
    ; res := <try(concat)> val
      // TODO: why try concat?
    
  perform-cyclic-task(|n):
    PropsLookup(kind, contains-uri) -> res
    where
      uri := <nabl-uri> contains-uri
    ; <nabl-add-uri-read(|n)> uri
    ; val := <get-index-properties(|kind)> uri
    ; res := <try(concat); make-set> val
      // TODO: why try concat?

rules
  
  prop-create-check(|ctx, kind, rel, actual):
    expected -> <new-task(|ctx)> PropCheck(kind, rel, actual, expected)
  
  perform-task(|n): 
    PropCheck(kind, rel, actual, expected) -> [<nabl-property-eq> (kind, rel, (actual, expected))]

rules

  prop-create-extract(|ctx, kind):
    term -> <new-task(|ctx)> PropExtract(kind, term)

  perform-task(|n):
    PropExtract(kind, term) -> result
    where
      result := <get-annotation(?(kind, <id>))> term
      // TODO: This can be avoided in the generator. 1) Create a choice. 2) Generate right task based on variable types (URI or term)
    <+ result := <perform-task(|n)> PropsLookup(kind, term)
    
"

  create-refactoring-construct-initial-list-structure = 
    <output-text-file(|["lib", "runtime", "refactoring"], "construct-initial-list-structure.str")>
"module runtime/refactoring/construct-initial-list-structure

imports
  runtime/editor/origins

rules
  
  origin-separation(pp|some-elem) = construct-initial-list-structure(pp|some-elem); ?(_, <id>)
  
  whitespace-at-start(pp|some-elem) = construct-initial-list-structure(pp|some-elem); ?(<id>, _)  

  /**
   * Given either
   *   - a list with zero or one element(s)
   *   - an element of a list with one element
   * finds both the whitespace that the pretty-printer puts in front of
   * the first element, as well as the separation that the pretty-printer
   * puts in between elements.
   *
   * Constructing this information relies on pretty-printing of dummy nodes.
   * @some-elem can be any element that may occur in the list that we want
   * to find the separation of.
   */  
  construct-initial-list-structure(pp|some-elem):
  elemOrList -> (whitespace-at-start'', sep'')
    where
      list := <?[] + ?[e]; !e; get-parent + get-parent> elemOrList;
      <leq> (<length> list, 1)
    with
      elem-text := <pp> some-elem;
      parent := <get-parent> list;
      dummy1 := <oncetd(origin-equal(|list); ![some-elem, some-elem]); pp> parent;
      dummy2 := <oncetd(origin-equal(|list); ![some-elem]); pp> parent
    with
      zipped := <zipPad(id, !0)> (<explode-string> dummy1, <explode-string> dummy2);
      index := <get-index0(not(eq))> zipped;
      (before, after) := <explode-string; split-at(|index); ?(b, a); !(<implode-string> b, <implode-string> a)> dummy1;
      whitespace-at-start := <
          !(<id>, elem-text); split-before-last-occurrence; ?(<id>, _);
          string-as-chars(reverse; take-while(is-whitespace + test('\\n')); reverse)
        > before;
      sep := <conc-strings> (
        <split-after-last-occurrence; ?(_, <id>)> (before, elem-text),
        <split-before; ?(<id>, _)> (after, elem-text)
      )
    with
      dummy-indent := <get-parent; origin-indent> list;
      whitespace-at-start' := <prefix-lines(|dummy-indent)> whitespace-at-start;
      sep' := <prefix-lines(|dummy-indent)>  sep;
      whitespace-at-start'' := <split-after; ?(_, <id>)> (whitespace-at-start', dummy-indent);
      sep'' := <split-after; ?(_, <id>)> (sep', dummy-indent)
  
  split-after-last-occurrence = 
    ?(l, sub); split-after; ?(before, after);
    try(!after; is-substring(!sub); !(after, sub); split-after-last-occurrence)
  split-before-last-occurrence =
    ?(_, sub); split-after-last-occurrence; ?(before, _);
    !(before, sub); split-before
  
rules  
  
  get-parent = prim(\"SSL_EXT_get_parent\", <id>)

"

  create-refactoring-construct-text = 
    <output-text-file(|["lib", "runtime", "refactoring"], "construct-text.str")>
"module runtime/refactoring/construct-text

imports
  libstratego-lib 
  libstratego-gpp
  runtime/editor/origins
  runtime/refactoring/layout-adaption

signature constructors
  Parenthetical : Unknown -> Unknown

rules
  
  DEFAULT-INDENT = !\"\\t\" //HACK: this is used in case multiline subterm texts are pretty-printed

rules //Parenthetical

  origin-indent = ?Parenthetical(<origin-indent>)

rules //pp rules for default nodes 
    
  pp-default(pp):
    Parenthetical(node) -> <concat-strings> [\"(\", <pp> node, \")\"]
  
  pp-default(pp):
    None() -> \"\"

  pp-default(pp):
    Some(x) -> <pp> x

  //pp-default(pp): amb([h|tail])

  pp-default(pp) = is-string

  pp-default(pp) = int-to-string
  
rules //interface

construct-text-from-source(pp, parenthesize, override-reconstruction, resugar):
  t@(oldnode, newnode) -> newText
  where
    <is-tuple> t;
    <has-origin-term> oldnode 
  with
    parenthesized-node := <try(parenthesize)> newnode;
    reconstructed-text := <topdown(try(strip-annos)); construct-text-from-old(pp, override-reconstruction, resugar)> (oldnode, parenthesized-node); 
    newText := <origin-set-relation>(parenthesized-node, reconstructed-text)

/*
 * Constructs the textual change associated with 
 * the transformation that replaces a (sub)term 'oldnode' with a new (sub)term 'newnode'.
 * @param custom pp strategy used to construct the text fragment for nodes that miss origin information T -> String
 * pp strategy is assumed to be homomorphic (except for lists separators that require parent node information)
 * @parenthesize strategy to resolve parse ambiguities that possible invalidate homomorpism T -> T
 * @prevents application of homomorphism assumption (or-node, node) -> _ 
 * @resugars when desugaring is non local or 1:n, thereby preventing incorrect reconstruction 
 * @type (original-node, new-node) -> (Int,Int, String)
 */ 
construct-textual-change(pp, parenthesize, override-reconstruction, resugar):
  (oldnode, newnode) -> (start-offset, end-offset, newText)
  where
    r-text := <construct-text-from-source(pp, parenthesize, override-reconstruction, resugar)>(oldnode, newnode);
    (start-offset, end-offset, newText) := <ast-change-to-text-change(pp, override-reconstruction, resugar)> REPLACEMENT(oldnode, r-text)
    
rules
  
construct-textual-change(pp, parenthesize, override-reconstruction, resugar):
  t@(oldnode, newnode) -> (0, 0, \"\")
  where
    <is-tuple> t;
    <equal> (oldnode, newnode)

construct-textual-change(pp, parenthesize, override-reconstruction, resugar)=
  map(construct-textual-change(pp, parenthesize, override-reconstruction, resugar))

//treat olnode as a candidate origin term to protect against loss of origin (and to preserve sugar in first diff)
construct-text-from-old(pp, override-reconstruction, resugar):
  (oldnode, newnode) -> reconstructed-text
  where
    reconstructed-text := <construct-text-from-origin(pp, override-reconstruction, resugar)> (oldnode, newnode) <+ //possible desugared
    reconstructed-text := <construct-text-from-origin(pp, override-reconstruction, resugar)> (<where(not(is-origin-term)); origin-term> oldnode, newnode) <+
    reconstructed-text := <construct-text(pp, override-reconstruction, resugar)> newnode

rules // backwards compatibility

construct-textual-change(pp) = construct-textual-change(pp, id, fail, fail)

construct-textual-change(pp|pp-table)=
  construct-textual-change(pp <+ (ast2abox(|[pp-table]); box2text-string(|100)))

rules //text-reconstruction

construct-text(pp, override-reconstruction, resugar) = 
  pp-default(construct-text(pp, override-reconstruction, resugar)) <+ //Parenthesis, None, ...
  construct-text-from-origin-desugared(pp, override-reconstruction, resugar) <+ 
  construct-text-from-origin(pp, override-reconstruction, resugar) <+
  construct-text-by-pp(pp, override-reconstruction, resugar) <+
  pp

construct-text-from-origin-desugared(pp, override-reconstruction, resugar):
  node -> <construct-text-from-origin(pp, override-reconstruction, resugar)> (origin-desugared-node, node)
  where 
    origin-desugared-node := <origin-term-desugared; topdown(try(strip-annos))> node

construct-text-from-origin(pp, override-reconstruction, resugar):
  node -> <construct-text-from-origin(pp, override-reconstruction, resugar)> (origin-node, node)
  where
    origin-node := <origin-term> node
 
//list must be constructed with comments that preceed the first element or succeed the last element
//(otherwise insert-at-end gives problems)
construct-text-from-origin(pp, override-reconstruction, resugar):
  lst -> <construct-text-with-comments(pp, override-reconstruction, resugar|\"\")> (origin-lst, lst)
  where
    origin-lst := <find-origin-sublist> lst

construct-text-from-origin(pp, override-reconstruction, resugar):
  t@(origin-node, node) -> <correct-indentation(|origin-node)> text
  where //guarantees that node can be formatted from the origin node, preventing non-termination
    <is-tuple> t;
    <has-origin-term> origin-node;
    ast-changes := <collect-ast-changes(override-reconstruction, resugar)> (origin-node, node); 
    <is-terminating-diff(|node)> ast-changes //prevent non termination
  with
    text-changes := <map(ast-change-to-text-change(pp, override-reconstruction, resugar))> ast-changes;
    text := <apply-text-changes>(text-changes, <origin-text> origin-node, <origin-start-offset> origin-node)

construct-text-by-pp(pp, override-reconstruction, resugar):
  node -> text
  where 
    text := <
      all(alltd(is-string <+ construct-text-with-comments(pp, override-reconstruction, resugar|<DEFAULT-INDENT>))); 
      topdown(try(pp-default(pp))); //handle brackets
      pp
    > node

construct-text-with-comments(pp, override-reconstruction, resugar|default-indent) = 
  construct-text-with-comments-desugared(pp, override-reconstruction, resugar|default-indent) <+
  construct-text-with-comments-origin(pp, override-reconstruction, resugar|default-indent)

construct-text-with-comments-desugared(pp, override-reconstruction, resugar|default-indent):
  node -> <construct-text-with-comments(pp, override-reconstruction, resugar|default-indent)> (origin-desugared-node, node)
  where 
    origin-desugared-node := <origin-term-desugared; topdown(try(strip-annos))> node; 
    <same-signature> (origin-desugared-node, node)

construct-text-with-comments-origin(pp, override-reconstruction, resugar|default-indent):
  node -> <construct-text-with-comments(pp, override-reconstruction, resugar|default-indent)> (origin-node, node)
  where
    origin-node := <origin-term <+ find-origin-sublist> node

//construct-text-with-comments(pp|default-indent): Parentetical(node) -> ...
// on this moment the parenthesis will be placed on the layouted text, 
// which is awful. It should be: {indent + comments before}{(}{node-text}{)}{comments after} 

construct-text-with-comments(pp, override-reconstruction, resugar|default-indent):
  t@(origin-node, node) -> node-text
  where 
    <is-tuple> t;
    <has-origin-term> origin-node
  with //termination check is not needed (we need to Replace to keep comments), since it is called on a subterm in construct-text-by-pp
    ast-changes := <collect-ast-changes(override-reconstruction, resugar)> (origin-node, node);
    text-changes := <map(ast-change-to-text-change(pp, override-reconstruction, resugar))> ast-changes;
    full-text := <origin-text-with-layout> origin-node; 
    full-text-start-offset := <origin-layout-prefix-start-offset> origin-node; 
    modified-full-text := <apply-text-changes>(text-changes, full-text, full-text-start-offset); 
    node-text := <replace-indentation(|default-indent, <origin-indent <+ !\"\"> origin-node)> modified-full-text

signature constructors //signatures for AST changes
  DELETION      : OldList -> AST_CHANGE
  REPLACEMENT   : OldNode * NewNode -> AST_CHANGE //TODO: REPLACEMENT_IN_LIST, REPLACEMENT + bracket insertion for REPLACEMENT
  INSERT_BEFORE : OldNode * NewList -> AST_CHANGE
  INSERT_AT_END : OldNode * NewList -> AST_CHANGE

rules //ast-diff

collect-ast-changes(override-reconstruction, resugar) = 
  where(is-tuple); 
  try(remove-superfluous-parentethical);
  (collect-ast-changes-eq <+
  collect-ast-changes-not-homomorphic(override-reconstruction) <+
  collect-ast-changes-resugared(override-reconstruction, resugar) <+
  collect-ast-changes-rec-node(override-reconstruction, resugar) <+
  collect-ast-changes-rec-list(override-reconstruction, resugar) <+
  collect-ast-changes-sugared(override-reconstruction, resugar) <+
  collect-ast-changes-replace)

//1: helps to keep syntactic sugar
//2: prevent incorrect reconstruction in case local and global information gets mixed
collect-ast-changes-resugared(override-reconstruction, resugar):
  (origin-node, node) -> ast-changes
  where 
    <not(is-origin-term)> origin-node; //otherwise resugaring does not make sense
    origin-resugared := <origin-track-forced(resugar)> origin-node;
    <not(equal)>(origin-node, origin-resugared);
    ast-changes := <collect-ast-changes(override-reconstruction, resugar)> (origin-resugared, <try(resugar)> node)

collect-ast-changes-not-homomorphic(override-reconstruction):
  (origin-node, node) -> [REPLACEMENT(origin-node, <origin-set-relation>(node, custom-node))]
  where
    custom-node := <override-reconstruction> (origin-node, node); //typical the node itself or a textual representation
    <check-change-origin> REPLACEMENT(origin-node, node)

remove-superfluous-parentethical:
  (origin-node, Parenthetical(node)) -> (origin-node, node)
  where //apparently, parenthesis already in source
    <same-signature> (origin-node, node)

collect-ast-changes-eq:
  (origin-node, node) -> []
  where
    <equal> (origin-node, node)

collect-ast-changes-rec-node(override-reconstruction, resugar):
  (origin-node, node) -> ast-changes
  where
    <same-signature <+ ?([_],[_])> (origin-node, node); //TODO: not injection?
    <is-related-to(|origin-node) <+ (is-related-to-fuzzy(|origin-node))> node;
    arg-tuples := <zip>(<get-arguments> origin-node, <get-arguments> node); 
    ast-changes := <map(collect-ast-changes(override-reconstruction, resugar)); flatten-list> arg-tuples 
 
collect-ast-changes-rec-list(override-reconstruction, resugar):
  (origin-lst, lst) -> ast-changes
  where
    <not(violates-homomorphism-list)> (origin-lst, lst)
  where
    ast-changes := <
      list-diff(override-reconstruction, resugar|origin-lst); 
      filter(not(?INSERT_BEFORE(_, [])));
      filter(not(?INSERT_AT_END(_, [])))
    > (origin-lst, lst); 
    <map(check-change-origin)> ast-changes 

check-change-origin:
  r@REPLACEMENT(or, _) -> r
  where
    <has-origin-term> or

check-change-origin:
  d@DELETION(or) -> d
  where
    <has-origin-term> or

check-change-origin:
  ins@INSERT_AT_END(or, trm) -> ins
  where
    <has-origin-term> or <+ <?[]> trm

check-change-origin:
  ins@INSERT_BEFORE(or, trm) -> ins
  where
    <has-origin-term> or <+ <?[]> trm
    
collect-ast-changes-sugared(override-reconstruction, resugar):
  (origin-node, node) -> ast-changes
  where
    <is-origin-term-desugared> node;
    <not(is-origin-term)> node
  where
    ast-changes := <collect-ast-changes-rec-node(override-reconstruction, resugar)> (<origin-term> origin-node, <origin-term> node)
      
collect-ast-changes-replace:
  (origin-node, node) -> [REPLACEMENT(origin-node, node)]
  where
    <check-change-origin> REPLACEMENT(origin-node, node);
    <not(is-list) <+ ?[] <+ ?[_] <+ has-origin-sublist> node 
    //list-text with more then one element can only be constructed in a context 
    // or from origin 

rules //validity

/*
//desugaring: changes must fall inside region of original text
//issue: is it correct if we simply filter context sensitive changes?
in-parent-context(|origin-parent):
  ast-change -> ast-change
  where 
    start-offset-node := <origin-deletion-start-offset> origin-parent; 
    end-offset-node := <origin-deletion-end-offset> origin-parent; 
    start-offset-change := <get-arguments; Hd; origin-start-offset> ast-change; 
    end-offset-change := <get-arguments; Hd; origin-end-offset> ast-change
  where 
    <leq> (start-offset-node, start-offset-change); 
    <leq> (end-offset-change, end-offset-node) 
*/
  
rules //list diff

list-diff(override-reconstruction, resugar|origin-lst) = 
  (list-diff-fuzzy(override-reconstruction, resugar|origin-lst) <+
  list-diff-origin-related(override-reconstruction, resugar|origin-lst)) 
  
list-diff-fuzzy(override-reconstruction, resugar|origin-lst):
  ([origin-elem|origin-rest], [new-elem|new-rest]) -> ast-changes
  where
    <is-deletion(|new-rest)> origin-elem;
    <is-insertion(|origin-rest)> new-elem;
    //<is-related-to-fuzzy(|origin-elem)> new-elem //fuzzy to prevent deletion + insertion
    ast-changes := <flatten-list>[
      <collect-ast-changes(override-reconstruction, resugar)>(origin-elem, new-elem)|
      <list-diff(override-reconstruction, resugar|origin-lst)> (origin-rest, new-rest)
    ]

list-diff-origin-related(override-reconstruction, resugar|origin-lst): 
  (origin-elems, new-elems) -> ast-changes
  where 
    deleted-elems := <take-while(is-deletion(|new-elems))> origin-elems;  
    origin-rest := <drop-while(is-deletion(|new-elems))> origin-elems;
    <not(?[])> deleted-elems;
    <check-change-origin> DELETION(deleted-elems);
    ast-changes := <flatten-list>[DELETION(deleted-elems)|<list-diff(override-reconstruction, resugar|origin-lst)> (origin-rest, new-elems)]

list-diff-origin-related(override-reconstruction, resugar|origin-lst):
  ([origin-elem|origin-rest], new-elems) -> ast-changes
  where
    (inserted, elem, rest) := <split-fetch-keep(is-related-to(|origin-elem))> new-elems;
    <check-change-origin> INSERT_BEFORE(origin-elem, inserted);
    ast-changes := <flatten-list>[
      INSERT_BEFORE(origin-elem, inserted), 
      <collect-ast-changes(override-reconstruction, resugar)>(origin-elem, elem)|
      <list-diff(override-reconstruction, resugar|origin-lst)> (origin-rest, rest)
    ]

list-diff-origin-related(override-reconstruction, resugar|origin-lst):
  ([], new-elems) -> [INSERT_AT_END(origin-lst, new-elems)]
  where
    <check-change-origin> INSERT_AT_END(origin-lst, new-elems)
    
list-diff-origin-related(override-reconstruction, resugar|origin-lst):
  ([], new-elems) -> [INSERT_AT_END(<last> origin-lst, new-elems)]
  where
    <check-change-origin> INSERT_AT_END(<last> origin-lst, new-elems)


rules //helper rules text construction

find-origin-sublist:
  lst -> sublst
  where
    at-suffix(sublst := <origin-sublist-term; ?[_,_|_]>) <+
    sublst := <init; find-origin-sublist> lst

has-origin-sublist =
  where(find-origin-sublist)

is-terminating-diff(|newnode):
  ast-changes -> ast-changes
  where
    <not(fetch(?REPLACEMENT(_, newnode)))> ast-changes 
    //lists are constructed from their elements, so non-termination is not a problem for insertion

rules //helper rules diff
  
same-signature:
  t@(trm1, trm2) -> (trm1, trm2)
  where(
    <is-tuple> t;
    <eq>(<get-constructor> trm1, <get-constructor> trm2);
    <eq>(<get-arguments; length> trm1, <get-arguments; length> trm2);
    <not(is-list)> trm1
  )

same-signature(|t1):
  t -> t
  where
    <same-signature> (t1,t)

violates-homomorphism-list =  (?([ortrm],[newtrm]); where(not(<is-related-to-fuzzy(|ortrm)> newtrm)))  //insertion constructs list with 2 elements from list with one element 

is-insertion(|origin-elems):
  new-elem -> new-elem
  where
    <?[or-elem|tail]> origin-elems;
    <not(is-related-to(|or-elem))> new-elem;
    <is-insertion(|tail)> new-elem

is-insertion(|origin-elems) =
  <?[]> origin-elems

is-deletion(|new-elems) = 
  ?origin-elem;
  <not(fetch(is-related-to(|origin-elem)))> new-elems

is-related-to(|origin-node):
  node -> node
  where
    <equal> (origin-node, node) <+
    <equal> (<origin-term> origin-node, node) <+
    <equal>(<origin-term> origin-node, <origin-term> node)

is-related-to:
  (origin-node, node) -> (origin-node, node)
  where
    <is-related-to(|origin-node)> node

//related via subterms
is-related-to-fuzzy(|origin-node):
  node -> node
  where 
    <oncetd(origin-subfragment(|origin-node)) <+ topdown(not(has-origin-term))> node

origin-subfragment(|origin-node):
  node -> node
  where
    start-offset := <origin-start-offset> node;
    end-offset := <origin-end-offset> node;
    <leq> (<origin-leftmost-offset> origin-node, start-offset);
    <leq> (end-offset, <origin-rightmost-offset> origin-node)

origin-leftmost-offset = 
  origin-start-offset <+
  get-arguments; 
  fetch-elem(origin-leftmost-offset)
  

origin-rightmost-offset = 
  origin-end-offset <+
  get-arguments;
  reverse; 
  fetch-elem(origin-rightmost-offset)
"

  create-refactoring-interface = 
    <output-text-file(|["lib", "runtime", "refactoring"], "interface.str")>
"module runtime/refactoring/interface

rules

  resugar                 = fail
  parenthesize            = fail
  override-reconstruction = fail
"

  create-refactoring-layout-adaption = 
    <output-text-file(|["lib", "runtime", "refactoring"], "layout-adaption.str")>
"module runtime/refactoring/layout-adaption

imports
  runtime/editor/origins
  runtime/refactoring/construct-text
  runtime/refactoring/construct-initial-list-structure

rules
  
  TABSIZE = !4  
  
rules //rules that translate AST-changes to Textual changes

ast-change-to-text-change(pp, override-reconstruction, resugar):
  DELETION(origin-lst) -> tc-deletion
  with 
    tc-deletion := <create-textchange-delete> origin-lst

ast-change-to-text-change(pp, override-reconstruction, resugar):
  REPLACEMENT(origin-node, new-node) ->  tc-replacement 
  with 
    tc-replacement := <create-textchange-replace(pp, override-reconstruction, resugar)> (origin-node, new-node) 

ast-change-to-text-change(pp, override-reconstruction, resugar):
  INSERT_BEFORE(origin-elem, new-elems) -> tc-insert-before
  with
    tc-insert-before := <create-textchange-insert-before(pp, override-reconstruction, resugar)> (origin-elem, new-elems)

ast-change-to-text-change(pp, override-reconstruction, resugar):
  INSERT_AT_END(origin-elem, new-elems) -> tc-insert-at-end
  with
    tc-insert-at-end := <create-textchange-insert-at-end(pp, override-reconstruction, resugar)> (origin-elem, new-elems)
  
create-textchange-delete:
  origin-elems -> (start-offset, end-offset, \"\")
  where
    start-offset := <origin-deletion-start-offset> origin-elems; 
    end-offset   := <origin-deletion-end-offset> origin-elems
    
create-textchange-replace(pp, override-reconstruction, resugar):
  (origin-node, new-node) -> (start-offset, end-offset, indented-text)
  where  
    start-offset := <origin-start-offset> origin-node;
    end-offset   := <origin-end-offset> origin-node;
    text  := <construct-text(pp, override-reconstruction, resugar)> new-node;
    indented-text := <adapt-indentation(|origin-node)> text

create-textchange-insert-before(pp, override-reconstruction, resugar):
  (origin-node, new-elems) -> (offset, offset, insert-text)
  where 
    offset := <origin-insert-before-offset> origin-node;
    new-elems-text := <map(construct-text-list-element(pp, override-reconstruction, resugar|origin-node))> new-elems;
    insert-text := <concat-strings> new-elems-text

create-textchange-insert-at-end(pp, override-reconstruction, resugar):
  (origin-node, new-elems) -> (offset, offset, insert-text)
  where 
    offset := <origin-insert-at-end-offset> origin-node;
    new-elems-text := <at-init(
      construct-text-list-element(pp, override-reconstruction, resugar|origin-node), 
      construct-text-list-element-last(pp, override-reconstruction, resugar|origin-node))
    > new-elems;
    if [] := origin-node
    then insert-text := <conc-strings> (<whitespace-at-start(pp|<Hd> new-elems)> origin-node, <concat-strings> new-elems-text)
    else insert-text := <add-separation-before(pp|new-elems)> (origin-node, <concat-strings> new-elems-text)
    end

rules //helper rules layout

construct-text-list-element(pp, override-reconstruction, resugar|origin-node):
  elem -> elem-text
  where
    text := <construct-text(pp, override-reconstruction, resugar)> elem; 
    layout-before := <layout-prefix; correct-indentation(|elem)> elem;
    indented-prefix-text := <conc-strings; adapt-indentation(|origin-node)> (layout-before, text); 
    comments-after := <comments-after; correct-indentation(|elem); adapt-indentation(|origin-node)> elem;
    separation := <origin-separation + origin-separation(pp|elem)> origin-node;
    layout-after := <create-separation-after> (separation, comments-after);
    elem-text := <conc-strings> (indented-prefix-text, layout-after)

construct-text-list-element-last(pp, override-reconstruction, resugar|origin-node):
  elem -> elem-text
  where
    text := <construct-text(pp, override-reconstruction, resugar)> elem;
    layout-before := <layout-prefix; correct-indentation(|elem)> elem;
    indented-prefix-text := <conc-strings; adapt-indentation(|origin-node)> (layout-before, text);
    comments-after := <comments-after; correct-indentation(|elem); adapt-indentation(|origin-node)> elem;
    elem-text := <concat-strings; trim-trailing-whitespace> [indented-prefix-text, \" \", comments-after]


rules //helper rules indentation

/*
 * replaces indent of the new constructed text (retrieved from new-node)
 * with indent appropriate for insertion position (retrieved from origin-node) 
 */
adapt-indentation(|origin-node):
  text -> indented-text
  where
    indent-string-new := <origin-indent> origin-node; 
    indented-text := <replace-indentation(|indent-string-new, \"\")> text

correct-indentation(|origin-node):
  txt -> indent-corrected-text
  where
    indent-string := <origin-indent <+ !\"\"> origin-node;
    indent-corrected-text := <replace-indentation(|\"\", indent-string)> txt

    
replace-indentation(|new-indent, old-indent):
  text -> indented-text
  where
    indent-value-old := <indent-value> old-indent;
    indented-text := <
      remove-indentation(|indent-value-old); 
      prefix-lines(|new-indent);
      ltrim-chars(?' ' <+ ?'\\t' <+ ?'\\n') //first line is not indented
    > text

/**
 * Returns the value of the indentation of the startline 
 * @type ATerm -> Int
 */
indent-value:
  indent-string -> indent-value
  where
    indent-value := <explode-string;
    take-while(?' '<+?'\\t');
    foldr(!0, add, (?' ';!1) <+ (?'\\t'; TABSIZE))> indent-string
  
remove-indentation(|n):
  txt -> dedented-txt
  where
    dedented-txt := <all-lines(string-as-chars(dedent-line-chars(|n)))> txt
    
dedent-line-chars(|n):
  chars -> dedented-chars
  where
    (
      <lt> (n,0); 
      indent := <copy-char; explode-string> (<abs>n, ' '); 
      dedented-chars := <conc>(indent,chars)
    )<+
    (
      <gt> (n,0);
      <?[' '|tail]> chars;
      dedented-chars := <dedent-line-chars(|<dec> n)> tail
    )<+
    (
      <gt> (n,0);
      <?['\\t'|tail]> chars; 
      dedented-chars := <dedent-line-chars(|<subt> (n, <TABSIZE>))> tail        
    )<+
    dedented-chars := chars


rules // helper rules separation  

add-separation-before(pp|new-elems) =
  add-separation-before-1(pp|new-elems) <+ //correct line comment
  add-separation-before-2(pp|new-elems)
  
add-separation-before-1(pp|new-elems): //corrects for newline in case the text is inserted after a line comment
  (origin-node, text-inserted-after) -> txt-with-separation
  where
    <origin-text-with-layout; string-ends-with(|\"\\n\")> origin-node;
    (start-separation, end-separation) := <split-before>(<origin-separation + origin-separation(pp|<Hd> new-elems)> origin-node, \"\\n\");
    <string-as-chars(map(is-whitespace))> start-separation;
    txt-with-separation := <concat-strings> [<string-as-chars(Tl)> end-separation, text-inserted-after, \"\\n\"]

add-separation-before-2(pp|new-elems):
  (origin-node, text-inserted-after) -> txt-with-separation
  where
    txt-with-separation := <conc-strings> (<origin-separation + origin-separation(pp|<Hd> new-elems)> origin-node, text-inserted-after)

//(\"/n  ,  \", \"//bla /n\") -> \" //bla /n  ,  \"
//(\",/n  \", \"//bla /n\") -> \" , //bla /n  \"
//(\"/n  \", \"//bla /n\") -> \" //bla /n  \"
create-separation-after:
  (separation, comments-after) -> txt-between
  where 
    <string-ends-with(|\"\\n\")> comments-after;
    (start-separation, end-separation) := <split-before>(separation, \"\\n\");
    txt-between := <concat-strings> [start-separation, \" \", comments-after, <string-as-chars(Tl)> end-separation]
    

//(\"/n  ,  \", \"/*bla*/\") -> \" /*bla*/ /n  ,  \"
//(\",/n  \", \"/*bla*/\") -> \" , /*bla*/ /n  \"
//(\"/n  \", \"/*bla*/\") -> \" /*bla*/ /n  \"
create-separation-after:
  (separation, comments-after) -> txt-between
  where
    <not(string-ends-with(|\"\\n\"))> comments-after;
    (start-separation, end-separation) := <split-before>(separation, \"\\n\");
    comments-after-separated := <?\"\" <+ <conc-strings>(\" \", <id>)> comments-after;
    txt-between := <concat-strings> [start-separation, comments-after-separated, end-separation]

//(\"  \", \"/*bla*/\") -> \" /*bla*/  \"
//(\",  \", \"/*bla*/\") -> \" /*bla*/,  \"
//(\"  \", \"//bla /n\") -> \" //bla /n  \"
//(\",  \", \"//bla /n\") -> \" //bla /n,  \"
create-separation-after:
  (separation, comments-after) -> txt-between
  where 
    <not(is-substring(!\"\\n\"))> separation;
    comments-after-separated := <?\"\" <+ <conc-strings>(\" \", <id>)> comments-after;
    txt-between := <conc-strings> (comments-after-separated, separation)

rules //Applying the textual modifications

/*
 * Applies textchanges (src-offset, text) to a textfragment with a given src-offset  
 * @type (List(((Int,Int), String)), String, Int) -> String
 */
apply-text-changes:
  (text-changes, text, start-offset) -> changed-text
  where 
    ordered-text-changes := <make-set; filter(is-modification); qsort(has-smaller-offset)> text-changes;
    <assert-valid-textual-changes> ordered-text-changes;
    changed-text := <foldr(!(start-offset, text), apply-textual-change); Snd> ordered-text-changes

apply-textual-change:
  (change, text-info) -> (char-pos, result-text)
  where 
    <?(char-pos, text-fragment)> text-info; 
    <?(change-start, change-end, change-text)> change; 
    pos-start := <subt>(change-start, char-pos);
    pos-end := <subt>(change-end, char-pos); <string-length> text-fragment;
    result-text:=<replace-in-text>
      (text-fragment, change-text, pos-start, pos-end) 

replace-in-text:
  (old-text, text-change, pos-start, pos-end) -> result-text
  where 
    old-chars := <explode-string> old-text; 
    (prefix, _) := <split-at(|pos-start)> old-chars; 
    (_, suffix) := <split-at(|pos-end)> old-chars; 
    result-text := <conc-strings> (<implode-string> prefix, text-change, <implode-string> suffix) 
    
has-smaller-offset = 
    ?((start-x, end-x, x), (start-y, end-y, y));
    where(
      <lt> (start-x, start-y) <+ 
      <eq> (start-x, start-y); <lt> (end-x, end-y)
    )

is-modification =
  not(?(t, t,\"\"))

rules //assert wellformedness of textual change list (unwellformed lists lead to unexpected text modifications)

assert-valid-textual-changes =
  assert-no-overlap;
  assert-valid-offset
  
assert-no-overlap:
  txt-changes@[(start-offset, end-offset, _), (start-offset', _, _)|_] -> txt-changes
  with
    <leq> (start-offset, start-offset');
    <leq> (end-offset, start-offset');
    <at-tail(assert-no-overlap)> txt-changes
    
assert-no-overlap =
  ?[(_, _, _)] <+ ?[]

assert-valid-offset =
  map(assert-valid-offset)

assert-valid-offset =
  ?(s,e,_);
  with(<leq>(s,e))
"

  create-relations-entries = 
    <output-text-file(|["lib", "runtime", "relations"], "entries.str")>
"module runtime/relations/entries

imports
  
  runtime/relations/entries
  runtime/relations/interface
  runtime/relations/tasks
  runtime/index/core
  runtime/properties/query
  runtime/nabl/resolve
  runtime/nabl/entries
  runtime/nabl/utils
  runtime/task/core
  runtime/task/insert
  runtime/task/utils
  runtime/editor/origins
  
signature

  constructors
    
    RelTuple   : Term * Relation -> Key
    Inverse    : Relation -> Relation
    Transitive : Relation -> Relation 
 
rules
  
  new-rel-tuple(|source, rel, t2):
    t1 -> tuple
    with
      relation-ensure-no-task-reference
    ; t1' := <relation-try-term-to-uri> t1
    with
      tuple := RelTuple(t1', rel)
    ; <index-collect(|<origin-track-forced(!t2)> t1, source)> tuple
    ; if <relation-is-transitive> rel then
        task := <relation-create-lookup(|source, rel)> t2
      ; <index-collect(|<origin-track-forced(!task)> t1, source)> RelTuple(t1', Transitive(rel))
    end

rules
  
  relation-ensure-no-task-reference = 
    with(
      not(collect-one-annos(relation-is-unresolved-use))
    | $[Cannot create a relation tuple with a reference to a resolution task on the left hand side.]
    ) 

  relation-try-term-to-uri:
    term -> result
    where
      if use := <collect-one-annos(relation-is-unresolved-use)> term then
        result := <relation-resolve-use> use
      else
        result := <try(collect-one-annos(relation-get-uri))> term
      end
    
  relation-get-uri:
    Def(uri) -> uri
    
  relation-get-uri:
    Use(Def(uri)) -> uri
    
  relation-is-unresolved-use =
    ?Use(Result(_))
    
  relation-resolve-use:
    Use(r@Result(_)) -> <insert-results-or-delay; Hd; nabl-uri> r
    
rules
  
  relation-tuple-key:
    RelTuple(key, _) -> key

"

  create-relations-incremental = 
    <output-text-file(|["lib", "runtime", "relations"], "incremental.str")>
"module runtime/relations/incremental

imports
  
  runtime/relations/entries
  runtime/nabl/uri
  runtime/nabl/incremental
  runtime/task/core
  
rules
  
  relation-add-read(|task-id) = (nabl-is-uri; nabl-add-uri-read(|task-id)) <+ task-add-read(|task-id) 

rules
  
  relation-get-changed-reads:
    changed-entry* -> read-term*
    with
      read-term* := <filter(relation-tuple-key); map(try(nabl-replace-uri-qualifier(|())))> changed-entry*

"

  create-relations-interface = 
    <output-text-file(|["lib", "runtime", "relations"], "interface.str")>
"module runtime/relations/interface

strategies
  
  /** 
   * Interface for static relation tuples, e.g. 
   * relation-store-value(store): (SubType(), IntTy()) -> <store> FloatTy()
   */
  relation-store-value(store) = fail
  /** 
   * Interface for static relation tuples, e.g. 
   * relation-match-tuple = ?(SubType(), IntTy(), FloatTy())
   */
  relation-match-tuple = fail
  /** 
   * Interface for custom relations, e.g.
   * relation-match-custom(|ctx): (SubType(), IntTy(), FloatTy()) -> task
   */
  relation-match-custom(|ctx) = fail
  
  relation-is-transitive = fail
  relation-is-reflexive  = fail
  relation-is-symmetric  = fail
  
"

  create-relations-query = 
    <output-text-file(|["lib", "runtime", "relations"], "query.str")>
"module runtime/relations/query

imports
  
  runtime/relations/entries
  runtime/relations/interface
  runtime/index/query
  runtime/task/insert
  
rules // Lookup relation values for given term
  
  relation-lookup(|rel):
    term -> <map(relation-try-term-to-uri)> [refl-val*, val*]
    where
      refl-val* := <(relation-is-reflexive; ![term]) <+ ![]> rel;
      (
        val* := <relation-lookup-internal(|rel); where(Hd)> term <+
        val* := <relation-try-term-to-uri; relation-lookup-internal(|rel)> term
      )

  relation-lookup-internal(|rel):
    term -> [stat-val*, val*, trans-val*]
    where
      stat-val*  := <get-static-relations(|rel)> term
    ; val*       := <get-index-relations(|rel)> term
    ; trans-val* := <(relation-is-transitive; <get-index-relations-transitive(|rel)> term) <+ ![]> rel
    // TODO: what about symmetric relations?
    
rules // Check if relation exists between two terms
  
  relation-match(|rel, expected):
    actual -> expected
    where
      <zip(relation-match-internal(|rel)) <+ relation-match-internal(|rel)> (actual, expected)
  
  relation-match-internal(|rel):
    (actual, expected) -> expected
    where
      <relation-match-internal-match(|rel)> (actual, expected) <+
      <where(<relation-is-symmetric> rel); relation-match-internal-match(|rel)> (expected, actual) <+
      (
        actual'   := <relation-try-term-to-uri> actual
      ; expected' := <relation-try-term-to-uri> expected
      ; (
          <relation-match-internal-match(|rel)> (actual', expected') <+
          <where(<relation-is-symmetric> rel); relation-match-internal-match(|rel)> (expected', actual')
        )
      )
      
  relation-match-internal-match(|rel):
    (actual, expected) -> <relation-match-tuple> (rel, actual, expected)
    // TODO: can this be transtive?
    
  relation-match-internal-match(|rel):
    (actual, expected) -> <id>
    where
      <get-index-relations(|rel); fetch(relation-try-term-to-uri; ?expected)> actual <+ 
      <where(<relation-is-transitive> rel); get-index-relations-transitive(|rel); fetch(relation-try-term-to-uri; ?expected)> actual

rules /** @internal */
  
  get-index-relations(|rel):
    term -> <index-get-all-values; relation-get-all-values> RelTuple(term, rel)
      
  get-index-relations-transitive(|rel):
    term -> <index-get-all-values; relation-get-all-values> RelTuple(term, Transitive(rel)) 
    
  relation-get-all-values = mapconcat(insert-results-or-delay; (is-list <+ MkSingleton))

rules /** @internal */

  get-static-relations(|rel):
    t -> val*
    with
      stat-set := <new-iset>
    ; <try(relation-store-value(store-tuple(|stat-set)))> (rel, t)
    ; val* := <iset-elements> stat-set
      
  store-tuple(|set): elem -> <fail> with <iset-add(|elem)> set

"

  create-relations-tasks = 
    <output-text-file(|["lib", "runtime", "relations"], "tasks.str")>
"module runtime/relations/tasks

imports
  
  runtime/relations/entries
  runtime/relations/query
  runtime/relations/incremental
  runtime/relations/interface
  runtime/task/create
  runtime/task/tasks
  runtime/nabl/uri
  runtime/nabl/incremental
  runtime/nabl/utils
  
signature
  
  constructors

    RelationTerm     : Term -> Instruction
    RelationLookup   : Relation * Term -> Instruction
    RelationMatch    : List(Term) * Term -> Instruction
    RelationDistance : Relation * Term * Term -> Instruction

rules // URI conversion
  
  relation-create-term(|ctx):
    term -> <new-task(|ctx)> RelationTerm(term)
    
  perform-task(|task-id):
    RelationTerm(term) -> (term, term')
    where
      term' := <relation-try-term-to-uri> term
    ; <relation-add-read(|task-id)> term'
    
rules // Lookup (customised in Java to store its result in a hash set, for fast lookups)

  relation-create-lookup(|ctx, rel):
    // IN4303 2014: Don't combine because this filters out empty lists, which are valid results
    term -> <task-create-insert(|ctx)/*; task-create-combine(|ctx)*/> lookup-task
    with
      term-task   := <relation-create-term(|ctx)> term
    ; lookup-task := <new-task(|ctx)> RelationLookup(rel, term-task)

  perform-task(|task-id):
    RelationLookup(rel, (term, term')) -> result*
    where
      result* := <relation-lookup(|rel)> term
      // TODO: remove redundant relation-try-term-to-uri calls in relation-lookup, term' is already the correct term.
      
  task-get-storage-type:
    RelationLookup(_, _) -> <task-set-storage>
  
rules // Match (custom implementation in Java that uses the hash set from a lookup task for fast lookups)
  
  relation-create-match(|ctx):
    (rel, actual, expected) -> <relation-create-match(|ctx, rel, expected)> actual

  relation-create-match(|ctx, rel, expected) = 
    relation-create-match(|ctx, rel, expected, [])

  relation-create-match(|ctx, rel, expected, dep*):
    actual -> result
    with 
      lookup-task := <relation-create-lookup(|ctx, rel)> actual
    ; term-task   := <relation-create-term(|ctx)> expected
    ; all-dep*    := <merge-dependencies(|dep*)> (rel, actual, expected, lookup-task, term-task)
    ; match-task  := <new-task(|ctx, all-dep*)> RelationMatch(lookup-task, term-task)
    ; if custom-task := <relation-match-custom(|ctx)> (rel, actual, expected) then
        result := <task-create-choice(|ctx)> [custom-task, match-task]
      else
        result := match-task
      end
  
  task-get-type:
    RelationMatch(_, _) -> <task-raw-type>
      
  task-get-storage-type:
    RelationMatch(_, _) -> <task-set-storage>
      
rules // Distance
  
  relation-create-distance(|ctx, rel, values):
    actual -> <new-task(|ctx)> RelationDistance(rel, actual, values)
  
  // Task needs to be a combinator because `expected*` needs to be queried like a list to find the distance.
  task-is-combinator = ?RelationDistance(_, _, _)
  
  perform-task(|task-id): 
    RelationDistance(rel, actual, value*) -> [<get-index> (<try-remove-list; relation-try-term-to-uri> actual, <map(relation-try-term-to-uri)> value*)]
    // Remove list on `actual` because this task is a combinator and `actual` may only contain one element.

"

  create-task-core = 
    <output-text-file(|["lib", "runtime", "task"], "core.str")>
"module runtime/task/core

imports 
  
  runtime/task/create
  runtime/task/insert
  runtime/task/utils
  runtime/task/primitives
  runtime/task/interface
  runtime/nabl/entries
  runtime/nabl/utils
  
signature

  sorts
  
    Result Instruction
  
  constructors
    
    Result : TaskID -> Result
    
    HigherOrder     : Instruction * List(TaskID) -> EvaluationReturn
    HigherOrderFail : List(TaskID)               -> EvaluationReturn

rules // API
  
  // todo: add API documentation for each of these including types
  
  task-add-message(|taskID, message)                         = task-api-add-message(|taskID, message)
  task-add-task(|partition, dependencies, instruction, 
                 type, storage-type, short-circuit)          = task-api-add-task(|partition, dependencies, instruction, type, storage-type, short-circuit)
  task-add-read(|task-id)                                    = task-api-add-read(|task-id, <id>)
  task-clear-partition                                       = task-api-clear-partition(|<id>)
  task-delay                                                 = task-api-delay(|<id>)
  task-debug-info(|partition)                                = task-api-debug-info(|partition)
  task-evaluate-now                                          = task-api-evaluate-now(task-collect-result-ids-2, insert-results-hashmap, task-perform-task|<id>)
  task-evaluate-scheduled                                    = task-api-evaluate-scheduled(task-collect-result-ids-2, insert-results-hashmap, task-perform-task)
  task-get-dependencies                                      = task-api-get-dependencies(|<id>)
  task-get-messages(|partition)                              = task-api-get-messages(|partition)
  task-get-readers                                           = task-api-get-readers(|<id>)
  task-invalidate-task-reads(|changedRead*)                  = task-api-invalidate-task-reads(|changedRead*)
  task-merge                                                 = task-api-merge
  task-sources-of(|task-id-or-task-id*)                      = task-api-sources-of(|task-id-or-task-id*)
  task-persist                                               = task-api-persist
  task-pop                                                   = task-api-pop
  task-push                                                  = task-api-push
  task-recover                                               = task-api-recover
  task-reset                                                 = task-api-reset
  task-result-combinations                                   = task-api-result-combinations(task-collect-result-ids-2, insert-results-hashmap|<id>, 0)
  task-result-combinations-single                            = task-api-result-combinations(task-collect-result-ids-2, insert-results-hashmap|<id>, 1)
  task-setup(|project-path)                                  = task-api-setup(|project-path)
  task-setup                                                 = task-api-setup(|<id>)
  task-start-collection(|partition)                          = task-api-start-collection(|partition)
  task-stop-collection(|partition)                           = task-api-stop-collection(|partition)
  task-unload                                                = task-unload(|<id>)
  task-unload(|project-path)                                 = task-api-unload(|project-path)
  
  // Deprecated, use task-get-results
  task-get-result = task-get-results
  
  task-get-results =
    switch id
      case ?Result(taskID) : task-api-get-results(|taskID)
      otherwise            : task-api-get-results(|<id>)
    end
  
  task-has-failed =
    switch id
      case ?Result(taskID) : task-api-has-failed(|taskID)
      otherwise            : task-api-has-failed(|<id>)
    end
    
  task-get-solved =
    switch id
      case ?Result(taskID) : task-api-get-results(|taskID) <+ (task-api-has-failed(|taskID); ![])
      otherwise            : task-api-has-failed(|<id>) <+ (task-api-has-failed(|<id>); ![])
    end

rules // Projections
  
  task-result-id:
    Result(taskID) -> taskID

  task-collect-result-ids =
    collect-all-annos(task-result-id, union)
  
  task-use-result-id:
    Use(Result(taskID)) -> taskID
    
  task-collect-result-ids-2 =
    collect-all-annos-2(task-result-id, task-use-result-id, union)

rules // Execution
  
  task-perform-task(|task-id):
    instruction -> result
    where
      if <task-is-higherorder> instruction then
        task-start-collection(|task-id)
      ; if new-instruction := <perform-task(|task-id)> instruction then
          (_, added*) := <task-stop-collection(|task-id)>
        ; result := HigherOrder(new-instruction, added*)
        else
          (_, added*) := <task-stop-collection(|task-id)>
        ; result := HigherOrderFail(added*)
        end
      else
        result := <perform-task(|task-id)> instruction
      end

"

  create-task-create = 
    <output-text-file(|["lib", "runtime", "task"], "create.str")>
"module runtime/task/create

imports
  
  runtime/task/core
  runtime/task/interface

rules
  
  /**
   * @type Partition * Instruction -> Result
   */
  new-task(|partition) = new-task(|partition, <dependent-tasks>)

  /**
   * @type Partition * List(TaskID) * Instruction -> Result
   */  
  new-task(|partition, type, storage-type) = new-task(|partition, <dependent-tasks>, type, storage-type)

  /**
   * @type Partition * List(TaskID) * Instruction -> Result
   */  
  new-task(|partition, dependencies):
    instruction -> result
    with
      type          := <determine-task-type> instruction;
      storage-type  := <determine-task-storage-type> instruction;
      result        := <new-task(|partition, dependencies, type, storage-type)> instruction
      
  new-task(|partition, dependencies, type, storage-type):
    instruction -> result
    with
      short-circuit := <task-short-circuit; !1 <+ !0> instruction;
      result        := <task-add-task(|partition, dependencies, instruction, type, storage-type, short-circuit)> instruction
  
  task-regular-type = !0
  task-combinator-type = !1
  task-raw-type = !2
  
  task-auto-storage = !0
  task-list-storage = !1
  task-set-storage = !2
      
  determine-task-type = task-get-type <+ (task-is-combinator; task-combinator-type) <+ task-regular-type // Default to regular task
  determine-task-storage-type = task-get-storage-type <+ task-list-storage // Default to list storage
      
  new-task-fixdeps(|partition, dependencies) = new-task(|partition, <dependent-tasks> dependencies)
      
  dependent-tasks = collect-all(dependent-task, union); flatten-list; make-set
  dependent-task = ?Result(<id>) 
  dependent-task =
    has-annos; get-annos; dependent-tasks
    
  merge-dependencies(|dep*):
    term -> <union> (<dependent-tasks> dep*, <dependent-tasks> term)
    
  task-create-execute-ctx = !\"\"
  task-create-execute(create-task):
    term -> result
    with
      ctx := <task-create-execute-ctx>
    ; task-push
    ; task-start-collection(|ctx)
    ; Result(taskID) := <create-task> term
    ; task-stop-collection(|ctx)
    ; <task-evaluate-now> taskID
    ; result := <task-get-results> taskID
    ; task-pop

"

  create-task-debug = 
    <output-text-file(|["lib", "runtime", "task"], "debug.str")>
"module runtime/task/debug

imports
  
  runtime/task/core
  runtime/task/create
  runtime/task/insert

signature

  constructors
    
    Debug : Term * Term -> Instruction

rules
  
  task-transitive-dependencies = task-transitive-dependencies(|[])
  
  task-transitive-dependencies(|seen):
    taskID -> [dep*, trans-dep*]
    where
      not(<elem> (taskID, seen));
      dep*       := <task-get-dependencies> taskID;
      trans-dep* := <mapconcat(task-transitive-dependencies(|[taskID|seen]))> dep*
      
  task-transitive-dependencies(|seen):
    taskID -> []
    where
      <elem> (taskID, seen)
      
rules
  
  task-debug-ast:
    ast -> debug*
    with
      resultID* := <task-collect-result-ids> ast;
      dep*      := <mapconcat(task-transitive-dependencies)> resultID*;
      debug*    := <make-set; map(task-debug-info(|<id>))> [resultID*, dep*]

rules
  
  task-debug(|ctx):
    term -> <new-task(|ctx)> Debug(\"\", term)
    
  task-debug(|ctx, prefix):
    term -> <new-task(|ctx)> Debug(prefix, term)
    
  task-is-combinator = ?Debug(_, _)

  perform-task(|task-id):
    Debug(prefix, term) -> term
    where
      switch !term
        case ?[]                            : <task-debug-msg(|task-id, prefix); fail> \"__FAIL__\"
        otherwise                           : <task-debug-msg(|task-id, prefix)> term
      end

  task-debug-msg(|task-id, prefix):
    msg -> <debug(!$[[task-id] - [prefix] ])> msg

"

  create-task-insert = 
    <output-text-file(|["lib", "runtime", "task"], "insert.str")>
"module runtime/task/insert

imports
  
  runtime/task/core

rules
  
  replace-results(list, result, fail-result, no-result) =
    switch id
      case has-annos  : ?t; !(<replace-results-noannos(list, result, fail-result, no-result)> t, <get-annos; replace-results(list, result, fail-result, no-result)> t); set-annos
      otherwise       : replace-results-noannos(list, result, fail-result, no-result)
    end   

  replace-results-noannos(list, result, fail-result, no-result) =
    switch id
      case is-list    : list
      case ?Result(n) : result <+ (task-has-failed; fail-result) <+ no-result 
      otherwise       : all(replace-results(list, result, fail-result, no-result))
    end
    
    
  insert-results-hashmap(|results-hashmap) =
    replace-results(
      filter(insert-results-hashmap(|results-hashmap))
    , \\Result(n) -> <try(<hashtable-get(|n)> results-hashmap)>\\
    , id
    , id
    )

  insert-results(fail-result, no-result) =
    replace-results(
      map(insert-results(fail-result, no-result)) 
    , \\Result(n) -> <task-get-results>\\
    , fail-result
    , no-result 
    )
  
  // Inserts task results into given term.
  // Fails when dereferencing a task that has failed.
  // Delays the current evaluating task when dereferencing a task that has not been evaluated yet.
  insert-results-or-delay:
    term -> inserted
    where
      deps     := <new-iset>;
      inserted := <insert-results(![], \\Result(n) -> <iset-add(|n)> deps\\)> term;
      dep*     := <iset-elements> deps;
      if <gt> (<length> dep*, 0) then
        <task-delay> dep*
      end

"

  create-task-interface = 
    <output-text-file(|["lib", "runtime", "task"], "interface.str")>
"module runtime/task/interface

strategies
  
  perform-task(|task-id) = fail
  avoid-task(|dep*)      = fail
  
  task-get-type          = fail
  task-get-storage-type  = fail
  task-is-combinator     = fail // Deprecated, use task-get-type = task-combinator-type
  task-short-circuit     = fail
  task-is-higherorder    = fail
  
  task-rewrite           = fail
  task-match             = fail 
"

  create-task-messages = 
    <output-text-file(|["lib", "runtime", "task"], "messages.str")>
"module runtime/task/messages

imports
  
  runtime/task/core
  runtime/task/create
  runtime/editor/origins
  
signature

  sorts
  
    Message
    MessageTrigger
    
  constructors
    
    Error   : Origin * Term * Msg -> Message
    Warning : Origin * Term * Msg -> Message
    Note    : Origin * Term * Msg -> Message
    
    Always   : MessageTrigger // Always
    Failure  : MessageTrigger // No results
    Success  : MessageTrigger // At least one result
    Multiple : MessageTrigger // More than one result

    Message  : Result * List(Result) * MessageTrigger * Term -> Instruction

overlays
  
  MISSING_ORIGIN = \"MISSING ORIGIN INFORMATION\"

rules // message creation
  
  task-error-message(|message):
    term -> Error(<task-message-origin-location-offset> term, term, message)
    
  task-warning-message(|message):
    term -> Warning(<task-message-origin-location-offset> term, term, message)
    
  task-note-message(|message):
    term -> Note(<task-message-origin-location-offset> term, term, message)

rules // querying
  
  task-message:
    Error(_, _, message) -> message

  task-message:
    Warning(_, _, message) -> message
    
  task-message:
    Note(_, _, message) -> message


  task-message-term:
    Error(_, term, _) -> term

  task-message-term:
    Warning(_, term, _) -> term
    
  task-message-term:
    Note(_, term, _) -> term
    

  task-message-origin:
    Error(origin, _, _) -> origin

  task-message-origin:
    Warning(origin, _, _) -> origin
    
  task-message-origin:
    Note(origin, _, _) -> origin
  
rules // task creation
  
  task-create-message(|partition, exclude*):
    message -> <new-task(|partition)> Message((), exclude*, Always(), message)
  
  task-create-error(|partition, exclude*, message) = 
    task-error-message(|message); task-create-message(|partition, exclude*)
  task-create-error(|partition, message) = 
    task-create-error(|partition, [], message)
      
  task-create-warning(|partition, exclude*, message) =
    task-warning-message(|message); task-create-message(|partition, exclude*)
  task-create-warning(|partition, message) =
    task-create-warning(|partition, [], message)
    
  task-create-note(|partition, exclude*, message) =
    task-note-message(|message); task-create-message(|partition, exclude*)
  task-create-note(|partition, message) =
    task-create-note(|partition, [], message) 
  
  
  task-create-message-on-failure(|partition, task, exclude*):
    message -> <new-task(|partition)> Message(task, exclude*, Failure(), message)
  
  task-create-error-on-failure(|partition, task, exclude*, message) = 
    task-error-message(|message); task-create-message-on-failure(|partition, task, exclude*)
  task-create-error-on-failure(|partition, task, message) = 
    task-create-error-on-failure(|partition, task, [], message)
      
  task-create-warning-on-failure(|partition, task, exclude*, message) =
    task-warning-message(|message); task-create-message-on-failure(|partition, task, exclude*)
  task-create-warning-on-failure(|partition, task, message) =
    task-create-warning-on-failure(|partition, task, [], message)
    
  task-create-note-on-failure(|partition, task, exclude*, message) =
    task-note-message(|message); task-create-message-on-failure(|partition, task, exclude*)
  task-create-note-on-failure(|partition, task, message) =
    task-create-note-on-failure(|partition, task, [], message)    
      
      
  task-create-message-on-success(|partition, task, exclude*):
    message -> <new-task(|partition)> Message(task, exclude*, Success(), message)
  
  task-create-error-on-success(|partition, task, exclude*, message) = 
    task-error-message(|message); task-create-message-on-success(|partition, task, exclude*)
  task-create-error-on-success(|partition, task, message) = 
    task-create-error-on-success(|partition, task, [], message)
    
  task-create-warning-on-success(|partition, task, exclude*, message) =
    task-warning-message(|message); task-create-message-on-success(|partition, task, exclude*)
  task-create-warning-on-success(|partition, task, message) =
    task-create-warning-on-success(|partition, task, [], message)
    
  task-create-note-on-success(|partition, task, exclude*, message) =
    task-note-message(|message); task-create-message-on-success(|partition, task, exclude*)
  task-create-note-on-success(|partition, task, message) =
    task-create-note-on-success(|partition, task, [], message)
    
    
  task-create-message-on-multiple(|partition, task, exclude*):
    message -> <new-task(|partition)> Message(task, exclude*, Multiple(), message)
  
  task-create-error-on-multiple(|partition, task, exclude*, message) = 
    task-error-message(|message); task-create-message-on-multiple(|partition, task, exclude*)
  task-create-error-on-multiple(|partition, task, message) =
    task-create-error-on-multiple(|partition, task, [], message)
    
  task-create-warning-on-multiple(|partition, task, exclude*, message) =
    task-warning-message(|message); task-create-message-on-multiple(|partition, task, exclude*)
  task-create-warning-on-multiple(|partition, task, message) =
    task-create-warning-on-multiple(|partition, task, [], message)
    
  task-create-note-on-multiple(|partition, task, exclude*, message) =
    task-note-message(|message); task-create-message-on-multiple(|partition, task, exclude*)
  task-create-note-on-multiple(|partition, task, message) =
    task-create-note-on-multiple(|partition, task, [], message)

rules // task execution
  
  task-is-combinator = ?Message(_, _, _, _)

  perform-task(|n):
    Message(task, exclude*, trigger, message) -> ()
    where
       // Use task-result-combinations to recursively insert into exclude tasks, to find out if they fail.
      <map(not(?[]); task-result-combinations)> exclude*;
      switch !trigger
        case ?Always()   : task-add-message(|n, message)
        case ?Failure()  : not(<Hd> task); task-add-message(|n, message)
        case ?Success()  : <Hd> task; task-add-message(|n, message)
        case ?Multiple() : <Tl; Hd> task; task-add-message(|n, message)
      end

rules
  
  task-message-origin-location-offset:
    term -> <origin-location-offset <+ MISSING_ORIGIN()> term
    where
      not(<is-list> term)
    
  task-message-origin-location-offset:
    list -> location-offset
    where
      <is-list> list;
      (
        (partition, line, column, start-offset, _) := <Hd; origin-location-offset> list;
        (_, _, _, _, end-offset)                   := <last; origin-location-offset> list;
        location-offset := (partition, line, column, start-offset, end-offset)
      ) <+
        location-offset := MISSING_ORIGIN()

"

  create-task-new-messages = 
    <output-text-file(|["lib", "runtime", "task"], "new-messages.str")>
"module runtime/task/new-messages

imports
  
  runtime/task/core
  runtime/task/create
  runtime/editor/origins
  runtime/task/messages
  
signature

  sorts
  
    Message
    MessageTrigger
    
  constructors
    
    Error   : Origin * Term * Msg -> Message
    Warning : Origin * Term * Msg -> Message
    Note    : Origin * Term * Msg -> Message
    
    Failure  : List(Result) -> MessageTrigger // No results
    Success  : List(Result) -> MessageTrigger // At least one result
    Multiple : List(Result) -> MessageTrigger // More than one result

    Message  : MessageTrigger * Term -> Instruction

rules // task creation
  
  task-create-message-on-triggers(|partition, triggers):
    message -> <new-task(|partition)> Message(triggers, message)
  
  task-create-error-on-triggers(|partition, triggers, message) = 
    task-error-message(|message); task-create-message-on-triggers(|partition, triggers)
    
  task-create-warning-on-triggers(|partition, triggers, message) =
    task-warning-message(|message); task-create-message-on-triggers(|partition, triggers)
    
  task-create-note-on-triggers(|partition, triggers, message) =
    task-note-message(|message); task-create-message-on-triggers(|partition, triggers)
  
rules // task execution
  
  task-is-combinator = ?Message(_, _)

  perform-task(|n):
    Message(trigger*, message) -> []
    where
      <map(?Failure([]) + ?Success([_|_]) + ?Multiple([_, _|_]))> trigger*
    where
      task-add-message(|n, message)

"

  create-task-primitives = 
    <output-text-file(|["lib", "runtime", "task"], "primitives.str")>
"module runtime/task/primitives

rules /** @internal API primitives */

  task-api-add-message(|taskID, message) = prim(\"task_api_add_message\", taskID, message)
  task-api-add-read(|taskID, read) = prim(\"task_api_add_read\", taskID, read)
  task-api-add-task(|partition, dependencies, instruction, type, storage-type, short-circuit) = prim(\"task_api_add_task\", partition, dependencies, instruction, type, storage-type, short-circuit)
  task-api-clear-partition(|partition) = prim(\"task_api_clear_partition\", partition)
  task-api-delay(|dependencies) = prim(\"task_api_delay\", dependencies)
  task-api-debug-info(|partition) = prim(\"task_api_debug_info\", partition)
  task-api-evaluate-now(collect, insert, perform|taskIDs) = prim(\"task_api_evaluate_now\", collect, insert, perform|taskIDs)
  task-api-evaluate-scheduled(collect, insert, perform|) = prim(\"task_api_evaluate_scheduled\", collect, insert, perform|)
  task-api-get-dependencies(|taskID) = prim(\"task_api_get_dependencies\", taskID)
  task-api-get-messages(|partition) = prim(\"task_api_get_messages\", partition)
  task-api-get-readers(|uri) = prim(\"task_api_get_readers\", uri)
  task-api-get-results(|taskID) = prim(\"task_api_get_results\", taskID)
  task-api-has-failed(|taskID) = prim(\"task_api_has_failed\", taskID)
  task-api-invalidate-task-reads(|changedReads) = prim(\"task_api_invalidate_task_reads\", changedReads)
  task-api-merge = prim(\"task_api_merge\")
  task-api-sources-of(|task-id-or-task-ids) = prim(\"task_api_sources_of\", task-id-or-task-ids)
  task-api-persist = prim(\"task_api_persist\")
  task-api-pop = prim(\"task_api_pop\")
  task-api-push = prim(\"task_api_push\")
  task-api-recover = prim(\"task_api_recover\")
  task-api-reset = prim(\"task_api_reset\")
  task-api-result-combinations(collect-results, insert-results|term, single-level) = prim(\"task_api_result_combinations\", collect-results, insert-results|term, single-level)
  task-api-setup(|project-path) = prim(\"task_api_setup\", project-path)
  task-api-start-collection(|partition) = prim(\"task_api_start_collection\", partition)
  task-api-stop-collection(|partition) = prim(\"task_api_stop_collection\", partition)
  task-api-unload(|project-path) = prim(\"task_api_unload\", project-path)

"

  create-task-tasks = 
    <output-text-file(|["lib", "runtime", "task"], "tasks.str")>
"module runtime/task/tasks

imports
  
  runtime/task/core
  runtime/task/create
  runtime/task/insert
  runtime/task/messages
  runtime/task/interface
  
signature

  constructors
    
    Id       : Term                -> Instruction
    Fail     :                        Instruction
    Choice   : List(Result)        -> Instruction
    Sequence : List(Result)        -> Instruction
    Combine  : List(Result)        -> Instruction
    Singleton: Result              -> Instruction
    Diff     : Result * Result     -> Instruction
    Collect  : List(Result)        -> Instruction
    Not      : Result              -> Instruction
    Index    : Int * List(Result)  -> Instruction
    Length   : List(Result)        -> Instruction
    Sum      : List(Result)        -> Instruction
    Fetch    : Term * List(Result) -> Instruction
    Eq       : Term * Term         -> Instruction
    Insert   : Term                -> Instruction
    Rewrite  : ID * Result         -> Instruction
    MakeSet  : Term                -> Instruction 

rules
  
  /**
   * Create a task that produces its input term.
   *
   * @type Term -> Result
   */
  task-create-id(|ctx) =
    ?Result(_) <+ <new-task(|ctx)> Id(<id>)

  /**
   * Create a task that produces its input term, where results are stored in a set.
   *
   * @type Term -> Result
   */   
  task-create-set-id(|ctx) =
    ?Result(_) <+ <new-task(|ctx, <task-regular-type>, <task-set-storage>)> Id(<id>)
  
  /**
   * Create a task that produces its input term, with extra static dependencies.
   *
   * @type Term -> Result
   */
  task-create-id(|ctx, dep*):
    term -> <new-task(|ctx, all-dep*)> Id(term)
    with 
      all-dep* := <merge-dependencies(|dep*)> term
      
  /**
   * Create a task that produces its input term, with extra dependencies, where results are stored in a set.
   *
   * @type Term -> Result
   */
  task-create-set-id(|ctx, dep*):
    term -> <new-task(|ctx, all-dep*, <task-regular-type>, <task-set-storage>)> Id(term)
    with 
      all-dep* := <merge-dependencies(|dep*)> term
  
  
  /** @internal */
  perform-task(|task-id) = ?Id(<MkSingleton>)
  
rules
  
  /**
   * Create a task that always fails.
   *
   * @type _ -> Result
   */
  task-create-fail(|ctx):
    _ -> <new-task(|ctx)> Fail()
  
  
  /** @internal */  
  perform-task(|task-id):
    Fail() -> <fail>

rules
  
  /**
   * Create a task that produces the results of the first subtask that succeeds.
   *
   * @type List(Result) -> Result
   */
  task-create-choice(|ctx) =
     ?[<?Result(_)>] <+ <new-task(|ctx)> Choice(<id>)
  
  /**
   * Create a choice task between two tasks, where t1 and t2 take a ctx and produce a task.
   *
   * @type Term -> Result
   */
  task-create-choice(t1, t2|ctx):
    term -> <task-create-choice(|ctx)> [<t1(|ctx)> term, <t2(|ctx)> term]
  
  
  /** @internal */
  task-get-type: Choice(_) -> <task-combinator-type>
  /** @internal */
  task-get-storage-type: Choice(_) -> <task-auto-storage>
  /** @internal */
  perform-task(|task-id) = ?Choice(<fetch-elem(not(?[]))>)
  
rules
  
  /**
   * Create a task that only succeeds when all subtasks succeed, and produces the result of the last subtask.
   *
   * @type List(Result) -> Result
   */
  task-create-sequence(|ctx) =
    ?[<?Result(_)>] <+ <new-task(|ctx)> Sequence(<id>)

  /**
   * Create a sequence task between two tasks, where t1 and t2 take a ctx and produce a task.
   * @type (Result * Partition -> Result) * (Result * Partition -> Result) * Partition -> Result
   */
  task-create-sequence(t1, t2|ctx):
    term -> <task-create-sequence(|ctx)> [<t1(|ctx)> term, <t2(|ctx)> term]
  
  
  /** @internal */
  task-get-type: Sequence(_) -> <task-combinator-type>
  /** @internal */
  task-get-storage-type: Sequence(_) -> <task-auto-storage>
  /** @internal */
  perform-task(|task-id)  = ?Sequence(<not(fetch-elem(?[])); last>)

rules
       
  /**
   * Create a task that combines the results of all subtasks.
   * 
   * @type List(Result) -> Result
   */
  task-create-combine(|ctx) =
    ?[<?Result(_)>] <+ <new-task(|ctx)> Combine(<id>)
  
  /**
   * Create a task that combines the results of all subtasks, with extra static dependencies.
   * 
   * @type List(Result) -> Result
   */ 
  task-create-combine(|ctx, dep*):
    task* -> <new-task(|ctx, all-dep*)> Combine(task*)
    with 
      all-dep* := <merge-dependencies(|dep*)> task*


  /** @internal */
  task-get-type: Combine(_) -> <task-combinator-type>
  /** @internal */
  task-get-storage-type: Combine(_) -> <task-auto-storage>
  /** @internal */
  perform-task(|task-id)  = ?Combine(<mapconcat(is-list <+ MkSingleton)>)

rules
       
  /**
   * Creates a task that collects all results from its subtasks, and produces a single list with all collected results.
   *
   * @type List(Result) -> Result
   */
  task-create-collect(|ctx) = <new-task(|ctx)> Collect(<id>)


  /** @internal */
  task-get-type: Collect(_) -> <task-combinator-type>
  /** @internal */
  perform-task(|task-id)  = ?Collect(<mapconcat(is-list <+ MkSingleton)>); MkSingleton

rules
  
  /**
   * Creates a task that inserts task results into given term.
   *
   * @type Term -> Result
   */
  task-create-insert(|ctx):
    term -> <new-task(|ctx)> Insert(term)
  
  
  /** @internal */
  task-get-type: Insert(_) -> <task-combinator-type>
  /** @internal */
  task-get-storage-type: Insert(_) -> <task-auto-storage>
  /** @internal */
  perform-task(|task-id): Insert(term) -> <insert-results-or-delay> term

rules
  
  /**
   * Creates a task that only succeeds if its subtask produces exactly one result, and produces that result.
   *
   * @type Result -> Result
   */  
  task-create-singleton(|ctx) =
    <new-task(|ctx)> Singleton(<id>)
  
  
  /** @internal */
  task-get-type: Singleton(_) -> <task-combinator-type>
  /** @internal */
  perform-task(|task-id): Singleton(r@[_]) -> r
    
rules
  
  /**
   * Creates a task that takes the difference between two lists.
   *
   * @type List(Term) * List(Term) -> Result
   */
  task-create-diff(|ctx):
    (l1, l2) -> <new-task(|ctx)> Diff(l1, l2)
  
  /**
   * Creates a task that takes the difference between two lists, where the second list is passed as a term argument.
   *
   * @type List(Term) -> Result
   */
  task-create-diff(|ctx, l2):
    l1 -> <new-task(|ctx)> Diff(l1, l2)


  /** @internal */
  task-get-type: Diff(_, _) -> <task-combinator-type>
  /** @internal */
  perform-task(|task-id): Diff(l1, l2) -> <diff> (l1, <is-list <+ MkSingleton> l2)

rules
  
  // TODO: what does this do?
  task-create-where(s|ctx):
    term -> <task-create-sequence(|ctx)> <try(flatten-list)> [<s> term, term]

rules
  
  /**
   * Creates a negation task, that succeeds if it subtask fails, and vice versa.
   *
   * @type Result -> Result
   */
  task-create-not(|ctx) = <new-task(|ctx)> Not(<id>)
  
  /**
   * Create negation task, where t takes a ctx argument and produces the task to be negated 
   */
  task-create-not(t|ctx) = t(|ctx); task-create-not(|ctx)
  
  
  /** @internal */
  task-get-type: Not(_) -> <task-combinator-type>
  /** @internal */
  perform-task(|task-id): Not([]) -> ()
  
rules
  
  /**
   * Creates a task that produces the term at given index in a list.
   *
   * @type List(Term) -> Result
   */
  task-create-index(|ctx, i):
    list -> <new-task(|ctx)> Index(i, list)
  
  
  /** @internal */
  perform-task(|task-id) = ?Index(i, <index(|i)>); MkSingleton
  
rules
  
  /**
   * Creates a task that produces the length of a list.
   *
   * @type List(Term) -> Result
   */
  task-create-length(|ctx):
    list -> <new-task(|ctx)> Length(list)
  
  
  /** @internal */
  perform-task(|task-id) = ?Length(<length>); MkSingleton

rules
  
  /**
   * Creates a task that produces the sum of the numbers in a list.
   *
   * @type List(INT <+ REAL) -> Result
   */
  task-create-sum(|ctx):
    list -> <new-task(|ctx)> Sum(list)
  
  
  /** @internal */
  perform-task(|task-id):
    Sum(list) -> <sum> list
    
rules
  
  /**
   * Creates a task that succeeds if the list contains the term.
   *
   * @type Term -> Result
   */
  task-create-fetch(|ctx, list):
    term -> <new-task(|ctx)> Fetch(term, list)
  
  
  /** @internal */
  perform-task(|task-id):
    Fetch(term, list) -> <fetch-elem(?term)> list
    
rules
  
  /**
   * Creates a task that succeeds if given terms are equal.
   *
   * @type Term -> Result
   */
  task-create-eq(|ctx, expected):
    actual -> <new-task(|ctx)> Eq(expected, actual)
    
    
  /** @internal */
  perform-task(|task-id):
    Eq(expected, actual) -> <eq; !actual> (expected, actual)

rules

  /**
   * Creates a task that converts the results of its subtask into set, removing all duplicates.
   *
   * @type Result -> Result
   */ 
  task-create-make-set(|ctx):
    term -> <new-task(|ctx)> MakeSet(term)
    
  /**
   * Creates a task that converts the results of its subtask into set, removing all duplicates.
   *
   * @type Result -> Result
   */ 
  task-create-make-set(|ctx, dep*):
    term -> <new-task(|ctx, all-dep*)> MakeSet(term)
    with
      all-dep* := <merge-dependencies(|dep*)> term
    
  /** @internal */
  task-get-storage-type: MakeSet(_) -> <task-set-storage>
  /** @internal */
  perform-task(|task-id): MakeSet(term) -> term // Do nothing, task storage type takes care of conversion into set.   
  
rules
        
  /**
   * Create task that performs a rewrite on its input term. It will perform the task-rewrite strategy with input
   * term (key, term), where the key is given as a strategy argument to this strategy.
   *
   * @type Term -> Result
   */
  task-create-rewrite(|ctx, key) = <new-task(|ctx)> Rewrite(key, <id>)
  
  
  /** @internal */      
  perform-task(|nr) = ?Rewrite(key, term); <task-rewrite; MkSingleton> (key, term)
  
rules /** @internal Cyclic task evaluation */
  
  perform-cyclic-task(|nr) = fail
  
  perform-task(|nr):
    (instruction, \"cyclic\") -> <perform-cyclic-task(|nr) <+ perform-task(|nr)> instruction

"

  create-task-utils = 
    <output-text-file(|["lib", "runtime", "task"], "utils.str")>
"module runtime/task/utils

rules

  oncetd-annos(s) = s <+ has-annos; get-annos; one(oncetd-annos(s)) <+ one(oncetd-annos(s))
  
  collect-one-annos(s) = oncetd-annos(s; ?t); !t
  
  crush-annos(nul, sum, s) :
    _#(xs){a*} -> r2
    where
     r1 := <foldr(nul, sum, s)> xs;
     r2 := <foldr(!r1, sum, s)> a*

  collect-all-annos(s, un) =
    ![<s> | <crush-annos(![], un, collect-all-annos(s, un))>]
  <+ crush-annos(![], un, collect-all-annos(s, un))





  crush-annos-2(nul, un, s, sa) :
    _#(xs){a*} -> r2
    where
     r1 := <foldr(nul, un, collect-all-annos-2(s, un))> xs;
     r2 := <foldr(!r1, un, collect-all-annos-2(sa, un))> a*
     
  crush-annos-2(nul, un, s) :
    _#(xs){a*} -> r2
    where
     r1 := <foldr(nul, un, collect-all-annos-2(s, un))> xs;
     r2 := <foldr(!r1, un, collect-all-annos-2(s, un))> a*

  collect-all-annos-2(s, sa, un) =
    ![<s> | <crush-annos-2(![], un, s, sa)>]
  <+ crush-annos-2(![], un, s)

  collect-all-annos-2(s, un) =
    ![<s> | <crush-annos-2(![], un, s)>]
  <+ crush-annos-2(![], un, s)
  
rules
  
  topdown-annos(s) =
    switch id
      case has-annos => t : !(<s; all(topdown-annos(s))> t, <get-annos; s; all(topdown-annos(s))> t); set-annos
      otherwise           : s; all(topdown-annos(s))
    end

"

  create-tmpl-pp = 
    <output-text-file(|["lib", "runtime", "tmpl"], "pp.str")>
"module runtime/tmpl/pp

imports
  
  libstratego-lib
  libstratego-gpp

signature constructors

  Parenthetical : Unknown -> Unknown

strategies

  // Unwrap Parenthetical/1 if pp fails, in case the user is using
  // parenthesize, but grammar does not contain {bracket} production.
  pp-one(pp) = (pp <+ ?Parenthetical(<pp>)); filter(gpp-is-real-vbox)

  pp-one-V(pp) = pp-one(pp); (?[] <+ !V([], <id>))
  pp-one-Z(pp) = pp-one(pp); (?[] <+ !Z([], <id>))

  pp-option(pp) = \\None() -> []\\ + ?Some(<pp>)

  pp-V-list(pp)    = ?[] <+ !V([], <map(pp-one-V(pp))>)
  pp-V-list(pp|vs) = ?[] <+ !V([SOpt(VS(), vs)], <map(pp-one-V(pp))>)
  pp-V-list(pp|vs, sep) = ?[] <+ !V([SOpt(VS(), vs)], <map(pp-one-V(pp)); at-init(add-sep(|sep), id)>)

  pp-indent(|is) = filter(gpp-is-real-vbox); (?[] <+ !I([SOpt(IS(), is)], H([SOpt(HS(), \"0\")], <id>)))

  pp-H-list(pp)     = ?[] <+ !H([], <map(pp-one-Z(pp))>)
  pp-H-list(pp|sep) = ?[] <+ !H([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

  pp-HV-list(pp)     = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
  pp-HV-list(pp|sep) = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

  pp-HZ-list(pp)     = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
  pp-HZ-list(pp|sep) = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

rules
  
 add-sep(|sep):
    V(vs, boxes) -> V(vs, result)
    where
      if [h] := boxes
      then
        (c, [cs, inner-boxes]) := <explode-term> h;
        box-with-sep := <mkterm> (c, [cs, <conc> (inner-boxes, [S(sep)])]);
        result := [box-with-sep]
        else
        result' := [<last; add-sep(|sep)> boxes];
        result  := <at-last(!result')> boxes 
        end
        
 add-sep(|sep):
  H(options, boxes) -> H(options, result)
  where
      result := <conc> (boxes, [S(sep)])
      
 add-sep(|sep):
  I(is, H(hs, boxes)) -> I(is, H(hs, result))
  where
      result := <conc> (boxes, [S(sep)])
      
 add-sep(|sep):
  HV(hs, boxes) -> HV(hs, result)
  where
      result := <conc> (boxes, [S(sep)])
      
 add-sep(|sep):
  HZ(hs, boxes) -> HV(hs, result)
  where
      result := <conc> (boxes, [S(sep)])

 add-sep(|sep):
  Z(hs, boxes) -> HV(hs, result)
  where
      result := <conc> (boxes, [S(sep)])      
"

  create-types-collect = 
    <output-text-file(|["lib", "runtime", "types"], "collect.str")>
"module runtime/types/collect

imports 
  
  runtime/types/interface
  runtime/properties/collect
  runtime/properties/eq
  
signature

  constructors
    
    Type : Property
    
rules
  
  create-property-task(|ctx, kind, uri*) =
    where(Type() := kind)
  ; (create-type-task(|ctx, uri*) <+ create-type-task(|ctx))
       
  type-is(|partition)           = nabl-prop-calc(|partition, [])
  type-is(|partition, dep*)     = nabl-prop-calc(|partition, dep*)
  
  type-list(|partition)         = nabl-prop-list(|partition, [])
  type-list(|partition, dep*)   = nabl-prop-list(|partition, dep*)
  
  type-lookup(|partition)       = nabl-prop-lookup(|Type(), partition, [])
  type-lookup(|partition, dep*) = nabl-prop-lookup(|Type(), partition, dep*)

  type-match(|partition, expected)           = nabl-prop-match(|Type(), partition, Eq(), expected)
  type-match(|partition, relation, expected) = nabl-prop-match(|Type(), partition, relation, expected)
   
  store-type(|partition, type) = nabl-store-prop(|partition, Prop(Type(), type, []))
    
"

  create-types-interface = 
    <output-text-file(|["lib", "runtime", "types"], "interface.str")>
"module runtime/types/interface

imports
  
  runtime/types/collect
  
strategies // user-defined implementations
  
  create-type-task(|ctx) = fail
  
  create-type-task(|ctx, uri*) = fail

"

  create-types-query = 
    <output-text-file(|["lib", "runtime", "types"], "query.str")>
"module runtime/types/query

imports
  
  runtime/types/collect
  runtime/properties/collect
  runtime/properties/query
  
rules // during analysis
  
  type-task(|ctx) = get-or-create-property-task(|ctx, Type())
  type-task(|ctx, kind, old-uri*, new-uri*) = get-or-create-property-task(|ctx, Type(), old-uri*, new-uri*)
  get-type-task   = get-property-task(|Type())
  
rules // post analysis
  
  get-type = get-property(|Type())

"

create-all-runtime-libraries = 
  create-analysis-analysis
;   create-analysis-builtins
;   create-analysis-complete
;   create-analysis-core
;   create-analysis-debug
;   create-analysis-defaults
;   create-analysis-interface
;   create-analysis-legacy
;   create-analysis-multiple
;   create-analysis-reanalysis
;   create-analysis-resolve
;   create-analysis-save
;   create-analysis-single
;   create-analysis-singleast
;   create-editor-annotations
;   create-editor-dynrule
;   create-editor-eclipse
;   create-editor-editor
;   create-editor-interop
;   create-editor-origins
;   create-editor-outline-library
;   create-editor-positions
;   create-editor-properties
;   create-editor-queue
;   create-editor-time
;   create-index-core
;   create-index-globals
;   create-index-legacy
;   create-index-query
;   create-modelware-model2tree
;   create-modelware-modelware
;   create-modelware-signatures
;   create-modelware-tree2model
;   create-nabl-check
;   create-nabl-collect
;   create-nabl-complete
;   create-nabl-constraints
;   create-nabl-entries
;   create-nabl-incremental
;   create-nabl-interface
;   create-nabl-lookup
;   create-nabl-namegen
;   create-nabl-query
;   create-nabl-resolve
;   create-nabl-tasks
;   create-nabl-uri
;   create-nabl-utils
;   create-properties-collect
;   create-properties-debug
;   create-properties-entries
;   create-properties-eq
;   create-properties-interface
;   create-properties-query
;   create-properties-tasks
;   create-refactoring-construct-initial-list-structure
;   create-refactoring-construct-text
;   create-refactoring-interface
;   create-refactoring-layout-adaption
;   create-relations-entries
;   create-relations-incremental
;   create-relations-interface
;   create-relations-query
;   create-relations-tasks
;   create-task-core
;   create-task-create
;   create-task-debug
;   create-task-insert
;   create-task-interface
;   create-task-messages
;   create-task-new-messages
;   create-task-primitives
;   create-task-tasks
;   create-task-utils
;   create-tmpl-pp
;   create-types-collect
;   create-types-interface
;   create-types-query
