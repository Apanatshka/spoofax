module sdf2imp/project/create-runtime-libraries

imports
  sdf2imp/util/-

strategies
  
	create-analysis-complete = 
		<output-text-file(|["lib", "runtime", "analysis"], "complete.str")>
"module runtime/analysis/complete

imports
	
	runtime/nbl/complete
	runtime/task/core
	runtime/index/core
	
rules
	
	analysis-propose-completions(|language, project-path, path):
		ast -> <nabl-propose-completions> ast
		with
    	task-setup(|project-path);
    	index-setup(|language, project-path, $[[project-path]/[path]])

"

	create-analysis-core = 
		<output-text-file(|["lib", "runtime", "analysis"], "core.str")>
"module runtime/analysis/core

imports
	
  runtime/nbl/collect
  runtime/nbl/entries
  runtime/nbl/uri
  runtime/nbl/utils
  runtime/index/core
  runtime/task/core
  runtime/task/messages
  
signature

  constructors
  
    File : Path * AST -> File
    Result : Partition * AST * AST * List(URI) * List(Term) * List(Term) * List(Term) -> Result
    // Result(partition, initial-ast, analyzed-ast, changed-read*, error*, warning*, note*)
    
rules // Analysis
	
	analyze-collect(|language, project-path):
    File(partition, initial-ast) -> Result(partition, initial-ast, analyzed-ast, changed-read*, [], [], [])
    with
    	measure-time(
	    	measure-time(
	    		index-setup(|language, [project-path], partition);
			    index-start-collection(|partition);
	    		task-setup(|project-path);
	    		task-start-collection(|partition)
	      	, id | \"analyze-collect-setup\"
	      ); measure-time(
	      	analyzed-ast := <nabl-collect(|partition, Language(language))> initial-ast
	    	  , id | \"analyze-collect-collect\" 
	  	  ); measure-time(
	  	  	index-stop-collection => (removed-entry*, added-entry*);
	      	task-stop-collection(|partition);
	      	changed-read* := <filter(analyze-diff-entry; nabl-uri; try(nabl-replace-uri-qualifier(|())))> [removed-entry*, added-entry*]
	      	, id | \"analyze-collect-diff\" 
	  	  )
  	  , id | \"analyze-collect-total\")
	
	analyze-perform-all:
		result* -> (result'*, unevaluated-task*, evaluated-count)
		with
			measure-time(
				measure-time(
					mapconcat(analyze-result-reads); make-set => changed-read*
					, id | \"analyze-task-evaluate-concat-reads\"
			  ); measure-time(
	      	task-evaluate(|changed-read*) => (unevaluated-task*, evaluated-count)
	      	, id | \"analyze-task-evaluate\"
	      ); measure-time(
	  	  	result'* := <map(analyze-messages)> result*
	  	  	, id | \"analyze-task-messages\"
	  	  )
  	, id | \"analyze-task-total\")
  	  
  // TODO: origin tracking    
  analyze-messages:
  	Result(partition, initial-ast, analyzed-ast, changed-read*, _, _, _) -> Result(partition, initial-ast, analyzed-ast, changed-read*, error*, warning*, note*)
  	with
  		message* := <task-get-messages(|partition)>;
  		error*   := <filter(?Error(_, _); analyze-message-to-tuple)> message*;
  		warning* := <filter(?Warning(_, _); analyze-message-to-tuple)> message*;
  		note*    := <filter(?Note(_, _); analyze-message-to-tuple)> message*
  		
	analyze-message-to-tuple:
		message -> (message, <task-message> message)

rules // Index entries to diff
	
  analyze-diff-entry =
    ?Def(_)
    
  analyze-diff-entry =
    ?Prop(_, _, _)
      
rules // Projections
	
	analyze-result-reads:
		Result(_, _, _, changed-read*, _, _, _) -> changed-read*
		
	analyze-result-analyzed-ast:
		Result(_, _, analyzed-ast, _, _, _, _) -> analyzed-ast
"

	create-analysis-debug = 
		<output-text-file(|["lib", "runtime", "analysis"], "debug.str")>
"module runtime/analysis/debug

imports
	
	runtime/index/core
	runtime/index/query
	runtime/task/core
	runtime/task/debug

rules
	
  analysis-debug-show-current-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
    	partition := $[[project-path]/[path]];
      index-setup(|language, [project-path], partition);
      filename := <guarantee-extension(|\"index.current.aterm\")> path;
      result   := <index-get-all-in-partition> partition
      
  analysis-debug-show-all-partitions(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
    	partition := $[[project-path]/[path]];
      index-setup(|language, [project-path], partition);
      filename := <guarantee-extension(|\"index.all.aterm\")> path;
      result   := <index-get-all-partitions; map(\\filename -> (filename, <index-get-all-in-partition> filename)\\)>
      
  analysis-debug-show-tasks(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
    	partition := $[[project-path]/[path]];
      task-setup(|project-path);
      filename := <guarantee-extension(|\"task.current.aterm\")> path;
      result   := <task-debug-info(|partition)>
      
  analysis-debug-show-tasks-selection(|language):
    (selected, _, _, path, project-path) -> (filename, result)
    with
    	partition := $[[project-path]/[path]];
      task-setup(|project-path);
      filename := <guarantee-extension(|\"task.selected.aterm\")> path;
      result   := <task-debug-ast> selected
      
  analysis-debug-reset-index(|language):
    (_, _, _, path, project-path) -> None()
    with
    	partition := $[[project-path]/[path]];
      index-setup(|language, [project-path], partition);
      index-clear
      
  analysis-debug-reset-task(|language):
    (_, _, _, path, project-path) -> None()
    with
      task-setup(|project-path);
      task-reset

  analysis-debug-reanalyze(|language):
    (_, _, _, path, project-path) -> None()
    with
    	partition := $[[project-path]/[path]];
    	task-setup(|project-path);
    	task-reset;
      index-setup(|language, [project-path], partition);
      index-reload

"

	create-analysis-defaults = 
		<output-text-file(|["lib", "runtime", "analysis"], "defaults.str")>
"module runtime/analysis/defaults

imports
	
	runtime/analysis/core
	runtime/analysis/single
	runtime/analysis/multiple
	runtime/nbl/utils
	runtime/index/core
	runtime/task/core
	runtime/editor/editor
	runtime/editor/queue

rules // Analysis
	
	analysis-default-editor = analysis-single-default-interface <+ (where(not(is-tuple)); analysis-multiple-default-queue)
	analysis-default-cmd = analysis-single-default-interface <+ (where(not(is-tuple)); analysis-multiple-default-interface)

rules // Single finle analysis
	
	analysis-single-default-interface = fail
	
  analysis-single-default(desugar-before, desugar-after, pp-message|language):
    (ast, path, project-path) -> (ast', error*, warning*, note*)
    with
      editor-init;
      <debug(!\"Analyzing file: \")> path;
      (ast', unevaluated-task*, evaluated-count, (analysis-error*, analysis-warning*, analysis-note*)) := <desugar-before; analyze-one(|language, path, project-path); desugar-after> ast;
      (error*, warning*, note*) := <analysis-message-collect(pp-message|analysis-error*, analysis-warning*, analysis-note*)> ast';
      <debug> $[[evaluated-count] task evaluated, [<length> unevaluated-task*] task unevaluated.];
      <map(task-debug-info(|<id>); debug(!\"Unevaluated: \"))> unevaluated-task* 
      // TODO: Update markers for partitions that have had a task executed.
      
rules // Multi-file analysis
      
  analysis-multiple-default-interface = fail    
      
	analysis-multiple-default-queue:
    path* -> None()
    with
      queue-strategy(|\"analysis-multiple-default-interface\", \"Analyzing files\")
      
  analysis-multiple-default(parse, desugar-before, desugar-after, pp-message|language, project-path):
    path* -> (result'*, unevaluated-task*, evaluated-count)
    with
    	debug(!\"Analyzing files: \");
      analysis-multiple-default-work-units; set-total-work-units;
      measure-time(
	      measure-time(
	      	path'* := <map(\\p -> $[[project-path]/[p]]\\)> path*;
	        (result*, unevaluated-task*, evaluated-count) := <analyze-multiple(parse, complete-work-unit|language, project-path)> path'*;
	        result'* := <filter(analysis-message-update-editor(desugar-after, pp-message))> result*
	      , id | \"analysis-multiple-full-analysis\"
	      );
	    	measure-time(
		      index-commit
	      	, id | \"analysis-multiple-index-commit\"
	      );
	    	measure-time(
		      task-persist
	      	, id | \"analysis-multiple-task-commit\"
	      )
	    , id | \"analysis-multiple-total\");
      <debug> $[[evaluated-count] task evaluated, [<length> unevaluated-task*] task unevaluated.];
      <map(task-debug-info(|<id>); debug(!\"Unevaluated: \"))> unevaluated-task*

  analysis-multiple-default-work-units = 
    length; !(<id>, 3); mul	
	    
rules // Message collection and updating.
	
	constraint-error = fail
	constraint-warning = fail
	constraint-note = fail
	
  analysis-message-collect(pp-message|analysis-error*, analysis-warning*, analysis-note*):
    ast -> ([<map(pp-message)> analysis-error*, error*], [<map(pp-message)> analysis-warning*, warning*], 
    	[<map(pp-message)> analysis-note*, note*])
    with
      error*   := <collect-all(constraint-error, conc)> ast;
      warning* := <collect-all(constraint-warning, conc)> ast;
      note*    := <collect-all(constraint-note, conc)> ast

  analysis-message-update-editor(desugar-after, pp-message):
    Result(partition, initial-ast, analyzed-ast, changed-read*, error* , warning* , note*) -> 
    Result(partition, initial-ast, <desugar-after> analyzed-ast, changed-read*, error'*, warning'*, note'*)
    where
      not(() := initial-ast)
    with
      (error'*, warning'*, note'*) := <analysis-message-collect(pp-message|error*, warning*, note*)> analyzed-ast;
      <set-markers(|initial-ast)> (analyzed-ast, error'*, warning'*, note'*)
      
rules // On-save handler
	
  analysis-save-default(|language):
  	(_, _, _, path, project-path) -> None()
  	with
  		index-setup(|language, [project-path], $[[project-path]/[path]]);
  		index-commit;
  		task-setup(|project-path);
  		task-persist
		
"

	create-analysis-multiple = 
		<output-text-file(|["lib", "runtime", "analysis"], "multiple.str")>
"module runtime/analysis/multiple

imports

  runtime/analysis/core
  runtime/task/core
  runtime/nbl/utils

rules // Multi file analysis
  
  analyze-multiple(parse-file, complete-work-unit|language, project-path):
    path* -> result*
    with
    	measure-time(
      	file* := <map(analyze-parse-file(parse-file); where(complete-work-unit))> path*
    	, id | \"analyze-parse\");
      result* := <analyze-multiple-files(complete-work-unit|language, project-path)> file*

  analyze-parse-file(parse-file):
    path -> File(path, ast)
    with
      if not(ast := <file-exists; parse-file> path) then
        ast := ()
      end

  analyze-multiple-files(complete-work-unit|language, project-path):
    file* -> (result'*, unevaluated-task*, evaluated-count)
    with
      result* := <map(analyze-collect(|language, project-path); where(complete-work-unit))> file*;
    	(result'*, unevaluated-task*, evaluated-count) := <analyze-perform-all> result*
      
"

	create-analysis-resolve = 
		<output-text-file(|["lib", "runtime", "analysis"], "resolve.str")>
"module runtime/analysis/resolve

imports
	
	runtime/nbl/resolve
	runtime/task/core
	runtime/index/core
	runtime/index/query
	
rules
	
	analysis-resolve(|language, project-path, path):
		node -> definition
		where
			task-setup(|project-path);
    	index-setup(|language, project-path, $[[project-path]/[path]]);
    	<nabl-has-reference> node;
    	definition := <nabl-collect-one-resolved-def; index-get-all; Hd> node
"

	create-analysis-single = 
		<output-text-file(|["lib", "runtime", "analysis"], "single.str")>
"module runtime/analysis/single

imports
	
  runtime/analysis/core
    
rules // Single file analysis
  
  analyze-one(|language, path, project-path):
    ast -> (analyzed-ast, unevaluated-task*, evaluated-count, (error*, warning*, note*))
    with // Setup index
      partition := $[[project-path]/[path]];
      r@Result(_, _, analyzed-ast, _, _, _, _) := <analyze-collect(|language, project-path)> File(partition, ast);
    	(result*, unevaluated-task*, evaluated-count) := <analyze-perform-all> [r];
    	Result(_, _, _, _, error*, warning*, note*) := <Hd> result*
"

	create-editor-editor = 
		<output-text-file(|["lib", "runtime", "editor"], "editor.str")>
"module runtime/editor/editor

rules
	
  project-path = prim(\"SSL_EXT_projectpath\")
  
  plugin-path = prim(\"SSL_EXT_pluginpath\")
    
  refresh-workspace-file:
    path -> <prim(\"SSL_EXT_refreshresource\", path)>
    
  editor-init =
    // Ensure all dynamic rules are properly scoped
    try(dr-scope-all-end);
    dr-scope-all-start
"

	create-editor-origins = 
		<output-text-file(|["lib", "runtime", "editor"], "origins.str")>
"module runtime/editor/origins

imports
	
	runtime/editor/editor

strategies
  
  origin-term      = prim(\"SSL_EXT_origin_term\", <id>)
  origin-text      = prim(\"SSL_EXT_origin_text\", <id>)
  origin-offset    = prim(\"SSL_EXT_origin_offset\", <id>)
  origin-location  = prim(\"SSL_EXT_origin_location\", <id>)
  origin-line      = origin-location => (<id>, _, _, _)
  origin-column    = origin-location => (_, <id>, _, _)
  origin-file      = prim(\"SSL_EXT_origin_file\", <id>)
  origin-strip     = prim(\"SSL_EXT_origin_strip\", <id>)
  origin-equal(|t) = prim(\"SSL_EXT_origin_equal\", <id>, t)

  origin-language-description =
    prim(\"SSL_EXT_languagedescription\", <id>)

  origin-language =
    origin-file; 
    origin-language-description;
    Fst
  
  origin-surrounding-comments =
    prim(\"SSL_EXT_origin_surrounding_comments\", <origin-language>, <id>)
    
  origin-documentation-comment =
    origin-surrounding-comments;
    filter(string-as-chars(documentation-comment-chars));
    concat-strings
  
  documentation-comment-chars:
    ['*' | c*] -> <ltrim(' ' + '\\t' + '\\n' + '\\r')> c*

  origin-track-forced(s) =
    ![<id>]; all(s); ?[<id>]

  origin-relative-path:
    trm -> rel-path
    where
      full-path := <origin-file> trm;
      len-project-prefix := <project-path; string-length; inc>;
      rel-path := <string-as-chars(drop(|len-project-prefix))> full-path

"

	create-editor-positions = 
		<output-text-file(|["lib", "runtime", "editor"], "positions.str")>
"module runtime/editor/positions

signature constructors

  MARKER: Term
  
strategies

  desugar-position(desugar|ast):
    position -> position'
    where
      ast'  := <at-position(!<id>{MARKER()}|position)> ast;
      ast'' := <topdown(repeat(preserve-annos({?x; desugar; not(?x)})))> ast';
      position' := <position-of-term({?_{a*}; <one(?MARKER())> a*})> ast''
   
  at-position(s|position):
    c#(t*) -> t'
    where
      !position => [i | position']
    where
      t' := c#(<at-index(at-position(s|position'))> (i, t*))

  at-position(s|position):
    t -> t'
    where
      !position => [];
      t' := <s> t

  position-of-term(is-term):
    t -> []
    where
      is-term
  
  position-of-term(is-term):
    _#(t*) -> <position-of-term(is-term|0)> t*
  
  position-of-term(is-term|start-index):
    [t | t*] -> position
    where
      if i* := <position-of-term(is-term)> t then
        position := [start-index | i*]
      else
        position := <position-of-term(is-term | <inc> start-index)> t*
      end

  term-at-position(|position):
    t -> t'
    where
      at-position(?t'|position) 

  parent-at-position(|position):
    t -> t'
    where
      !position => [i, _];
      t' := <subterm-at(|i)> t
  
  parent-at-position(|position):
    t -> <parent-at-position(|position')> t'
    where
      !position => [i | position' @ [_, _ | _]];
      t' := <subterm-at(|i)> t

  subterm-at(|index):
    _#(t*) -> <index(|<inc> index)> t*

"

	create-editor-queue = 
		<output-text-file(|["lib", "runtime", "editor"], "queue.str")>
"module runtime/editor/queue

rules
	
  // Set markers for a given file. Use when checking files from a queued strategy.
  // Current term: (ast-desugared, errors, warnings, notes) tuple
  // ast: the root node of the file to set markers on 
  set-markers(|ast) = prim(\"SSL_EXT_set_markers\", ast)

  // Indicate that one or more files need analysis. 
  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
  queue-analysis = 
       (is-list; list-loop(queue-analysis))
    <+ prim(\"SSL_EXT_queue_analysis\")
    
  // Gets the number of background analyses for currenct project and language.
  // Current term: ignored
  analysis-count = prim(\"SSL_EXT_queue_analysis_count\")

  // Set the total number of work units to complete. Can be called multiple times. 
  // Current term: number of work units (int).
  set-total-work-units = prim(\"SSL_EXT_set_total_work_units\")
  
  // Complete one work unit and update progress monitors.
  // Current term: ignored
  complete-work-unit = prim(\"SSL_EXT_complete_work_unit\")
  
  // Queue a strategy for background processing with a progress indicator.
  // Current term: the term to pass to the background strategy
  // s: the strategy, as string
  // description: name of the task (will be shown in progress view)
  queue-strategy(|s,description) = prim(\"SSL_EXT_queue_strategy\", s, description)
  
  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
  set-analysis-backgrounded = !\"BACKGROUNDED\"

"

	create-index-core = 
		<output-text-file(|["lib", "runtime", "index"], "core.str")>
"module runtime/index/core

signature

  sorts
  
    URI Entry
  
rules

  /**
   * Sets up the index library for given language, project paths and current file.
   * Must be called once before doing anything with the library.
   *
   * Example:
   *   <index-setup(|\"MiniJava\", [<project-path>], \"test/test.mjv\")
   *
   * @param language          The language to set the index up for.
   * @param project-path      The project paths that contain all source files to analyse and compile.
   * @param current-partition The current partition that is being analysed. Can be retrieved later using 
   *                          index-get-current-partition. Can also be changed later using index-set-current-partition.
   * @type x -> x
   */
  index-setup(|language, project-paths, current-partition) =
    prim(\"LANG_index_setup\", language, project-paths, current-partition)
    
  /**
   * Unloads the currently loaded index.
   *
   * Example:
   *   index-unload(|<project-path>)
   *
   * @param project-path The project path that contain all source files to analyse and compile.
   *
   * @type x -> x
   */
  index-unload(|project-path) =
    prim(\"LANG_index_unload\", project-path)
    
  /**
   * Sets the current file the index (analysis) is operating on to the given file.
   *
   * Example:
   *   <index-set-current-partition> \"fullpath/file.ext\"
   *   <index-set-current-partition> (\"fullpath/file.ext\", \"subfile\")
   *
   * @type x -> ?x
   */
  index-set-current-partition = 
    prim(\"LANG_index_set_current_file\", <id>)

	index-start-collection(|partition) =
		prim(\"LANG_index_start_collection\", partition)
		
	index-stop-collection =
		prim(\"LANG_index_stop_collection\")

  /**
   * Adds given element to the index.
   *
   * Example:
   *   <index-add(|\"fullpath/file.ext\")> Def([Entity(), \"Bar\"])
   *   <index-add(|(\"fullpath/file.ext\", \"subfile\"))> Def([Entity(), \"Bar\"])
   *
   * @param partition The partition to add the element to.
   * @type x -> ?x
   */
  index-add(|partition) =
    prim(\"LANG_index_add\", <id>, partition)

  /**
   * Adds all given elements to the index.
   *
   * Example:
   *   <index-add-all(|\"fullpath/file.ext\")> [Def([Entity(), \"Bar\"]), ...]
   *   <index-add-all(|(\"fullpath/file.ext\", \"subfile\"))> [Def([Entity(), \"Bar\"]), ...]
   *
   * @param partition The partition to add the elements to.
   * @type List(x) -> ?List(x)
   */
  index-add-all(|partition) =
    list-loop(with(index-add(|partition)))
    
  /**
   * Removes given entry from the index that is contained in given partition.
   *
   * Example:
   *   <index-remove(|\"fullpath/file.ext\")> Def([Entity(), \"Bar\"])
   *   <index-remove(|(\"fullpath/file.ext\", \"subfile\"))> Def([Entity(), \"Bar\"])
   * 
   * @param partition The partition to remove the element from.
   * @type x -> ?x
   */
  index-remove(|partition) =
    prim(\"LANG_index_remove\", <id>, partition)
    
  /**
   * Removes entries with given template from the index (from all partitions).
   *
   * Example:
   *   <index-remove-all> Def([Entity(), \"Bar\"])
   * 
   * @param partition The partition to remove the element from.
   * @type x -> ?x
   */
  index-remove-all =
    prim(\"LANG_index_remove_all\", <id>)
    
  /**
   * Removes given entry from the index (from all partitions).
   *
   * Example:
   *   <index-remove-all> DefData([Entity(), \"Bar\"], Type(), Type(\"Bar\"))
   * 
   * @param partition The partition to remove the element from.
   * @type x -> ?x
   */
  index-remove-one =
    prim(\"LANG_index_remove_one\", <id>)
    
  /**
   * Removes all elements from the index that are contained in given partition.
   *
   * Example:
   *   <index-clear-partition> \"fullpath/file.ext\"
   *   <index-clear-partition> (\"fullpath/file.ext\", \"subfile\")
   *
   * @type x -> ?x
   */
  index-clear-partition = 
    prim(\"LANG_index_clear_file\", <id>)
    
  /**
   * Removes all elements from the index.
   *
   * @type x -> x
   */
  index-clear = 
    prim(\"LANG_index_clear_all\")
    
  /**
   * Removes all elements from the index and re-analyzes all partitions in the project.
   *
   * @type x -> x
   */
  index-reload = 
    prim(\"LANG_index_reload\")
   
  /**
   * Serializes index to a cache on disk.
   *
   * @type x -> x
   */
  index-commit = 
    prim(\"LANG_index_commit\")

  /**
   * Starts a transaction on the index for the current partition. Additions to the index are not visible to other files 
   * until index-end-transaction is called. Operations on the index are only thread safe during a transaction.
   *
   * @type x -> x
   */
  index-start-transaction = 
    prim(\"LANG_index_start_transaction\")
  
  /**
   * Ends a transaction on the index for the current partition. Additions made to the index during the transaction are
   * added to the global index visible for other files. Operations on the index are not thread safe any more after 
   * this call.
   *
   * @type x -> x
   */
  index-end-transaction = 
    prim(\"LANG_index_end_transaction\")
  
  /**
   * Starts a transaction, applies given strategy and ends the transaction. All index operations used from the given
   * strategy are thread safe.
   * 
   * @param s The strategy to apply. Transaction will still properly end if strategy fails.
   * @type x -> x'
   *
   * @see index-start-transaction
   * @see index-end-transaction
   */
  index-transaction(s) = 
      prim(\"LANG_index_start_transaction\")
    ; try(s)
    ; prim(\"LANG_index_end_transaction\")

"

	create-index-globals = 
		<output-text-file(|["lib", "runtime", "index"], "globals.str")>
"module runtime/index/globals

imports

	runtime/index/core
	runtime/index/query
  
signature 

  constructors
    
    Global : URI               -> Entry
    Global : URI * List(Entry) -> Entry
    
rules
    
  /**
   * Gets the 'fake' path where globals are stored in the index.
   *
   * @internal
   */
  index-globals-path = 
    !\"/.internal/globals\"
    
  /**
   * Gets the URI where globals are stored in the index for given name or names.
   *
   * @internal
   * @type name or List(name) -> uri
   */
  index-globals-uri:
    names -> uri
    with
      if is-list then
        uri := <concat> [names, [\"globals\", \".internal\"]]
      else
        uri := [names, \"global\", \".internal\"]
      end
    
  /**
   * Gets the first value in global storage with given name, or fail.
   *
   * Example:
   *   index-get-global(|\"last-compile\") => Timestamp(1334322856)
   *   index-get-global(|[\"last-compile\", \"file.str\"]) => Timestamp(1334322856)
   * 
   * @param name  The name or list of names to identify the global value.
   * @type _ -> ?value
   */
  index-get-global(|name):
    _ -> value
    where
      Global(_, value) := <index-get-all; Hd> Global(<index-globals-uri> name, ())
    
  /**
   * Gets all values in global storage with given name.
   *
   * Example:
   *   index-get-global(|\"last-compile\") => [Timestamp(1334322856), ...]
   *   index-get-global(|[\"last-compile\", \"file.str\"]) => [Timestamp(1334322856), ...]
   *
   * @param name  The name or list of names to identify the global value.
   * @type _ -> List(value)
   */ 
  index-get-all-globals(|name):
    _ -> values'
    with
      values  := <index-get-all> Global(<index-globals-uri> name, ());
      values' := <filter(?Global(_, <id>))> values
    
  /**
   * Add value to global storage with given name.
   *
   * Example:
   *   <index-add-global(|\"last-compile\")> Timestamp(1334322856)
   *   <index-add-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-add-global(|name):
    value -> <id>
    with
      <index-add(|<index-globals-path>)> Global(<index-globals-uri> name, value)
      
  /**
   * Overwrites value in global storage with given value.
   *
   * Example:
   *   <index-set-global(|\"last-compile\")> Timestamp(1334322856)
   *   <index-set-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-set-global(|name):
    value -> <id>
    with
      index-clear-global(|name);
      <index-add-global(|name)> value
    
  /**
   * Removes all values from global storage with given name.
   *
   * Example:
   *   index-clear-global(|\"last-compile\")
   *   index-clear-global(|[\"last-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-clear-global(|name):
    _ -> <id>
    with
      <index-remove(|<index-globals-path>)> Global(<index-globals-uri> name, ())
      
  /**
   * Gets the URI where boolean globals are stored in the index for given name or names.
   *
   * @internal
   */
  index-boolean-globals-uri:
    names -> uri
    with
      if is-list then
        uri := <concat> [names, [\"boolean\", \"globals\", \".internal\"]]
      else
        uri := [names, \"boolean\", \"global\", \".internal\"]
      end
      
  /**
   * Sets boolean value true to global boolean storage with given name.
   *
   * Example:
   *   index-enable-global(|\"can-compile\")
   *   index-enable-global(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> x
   */   
  index-enable-global(|name):
    _ -> <id>
    with
      <index-add(|<index-globals-path>)> Global(<index-boolean-globals-uri> name)
      
  /**
   * Sets boolean value false to global boolean storage with given name.
   *
   * Example:
   *   index-disable-global(|\"can-compile\")
   *   index-disable-global(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> x
   */   
  index-disable-global(|name):
    _ -> <id>
    with
      <index-remove(|<index-globals-path>)> Global(<index-boolean-globals-uri> name)
      
  /**
   * Query for boolean value true in global boolean storage with given name.
   *
   * Example:
   *   index-is-global-enabled(|\"can-compile\")
   *   index-is-global-enabled(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> ?x
   */   
  index-is-global-enabled(|name):
    _ -> <id>
    where
      <index-get-all; Hd> Global(<index-boolean-globals-uri> name)

"

	create-index-partition = 
		<output-text-file(|["lib", "runtime", "index"], "partition.str")>
"module runtime/index/partition

rules // Construction
  
  index-create-partition(|file) =
    !file
    
  index-create-partition(|file, uri) =
    !(file, uri)

rules // Projections
	
	index-partition-file:
		(file, _) -> file
		
	index-partition-file:
		file -> file
		where
			<is-string> file
		
  index-partition-uri:
  	(_, uri) -> uri
"

	create-index-query = 
		<output-text-file(|["lib", "runtime", "index"], "query.str")>
"module runtime/index/query

rules

  /**
   * Get all index entries that match the given template.
   *
   * Example:
   *   <index-get-all> Def([Entity(), \"Bar\"]) => [Def([Entity(), \"Bar\"]), ...]
   *
   * @type template -> List(elem)
   */
  index-get-all:
    template -> <prim(\"LANG_index_get\", template)>
    
  /**
   * Get tuples of all index entries that match the given template with their partition
   *
   * Example:
   *   <index-get-all> Def([Entity(), \"Bar\"]) => [((\"fullpath/file.ext\", \"subfile\"), Def([Entity(), \"Bar\"])), ...]
   *
   * @type template -> List(elem)
   */
  index-get-all-with-partitions:
    template -> <prim(\"LANG_index_get_with_partitions\", template)>

  /**
   * Get all children entries of the given template.
   *
   * Example:
   *   <index-get-children> Def([Entity(), \"Bar\", \"Foo\"]) => [Def([Method(), \"Bar\"]), Def([Field(), \"Baz\"]), ...]
   *
   * @type template -> List(elem)
   */    
  index-get-children:
    template -> <prim(\"LANG_index_get_children\", template)>
  
  /**
   * Gets the partition that the analysis is currently in.
   *
   * @type x -> partition
   *
   * @see index-setup(|language, project-paths, current-partition)
   * @see index-set-current-partition
   */
  index-get-current-partition =
    prim(\"LANG_index_get_current_file\")
  
  /**
   * Gets a list of all partitions for current project.
   *
   * Example:
   *   <index-get-all-partitions> => [(\"fullpath/file.ext\", \"subfile\"), ...]
   *
   * @type x -> List(partition)
   */   
  index-get-all-partitions =
    prim(\"LANG_index_all_files\")
  
  /**
   * Gets all index entries for the given partition.
   *
   * Examples:
   *   <index-get-all-in-partition> \"fullpath/file.ext\" => [Def([Entity(), \"Bar\"]), ...]
   *   <index-get-all-in-partition> (\"fullpath/file.ext\", \"subfile\") => [Def([Entity(), \"Bar\"]), ...]
   *
   * @type partition -> List(elem)
   */  
  index-get-all-in-partition =
    prim(\"LANG_index_get_all_in_file\", <id>)
    
  /**
   * Gets the revision of a partition.
   *
   * Example:
   *   <index-get-partition-revision> \"fullpath/file.ext\" => 13
   *   <index-get-partition-revision> (\"fullpath/file.ext\", \"subfile\") => 37
   *
   * @type partition -> Int
   */
  index-get-partition-revision:
    file -> <prim(\"LANG_index_get_file_revision\", file)>
    
  /**
   * Gets the containing partitions of index entry with given template.
   *
   * Example:
   *   <index-get-partitions-of> Def([Entity(), \"Bar\"]) => [(\"fullpath/file.ext\", \"subfile\"), ...]
   *
   * @type template -> List(partition)
   */  
  index-get-partitions-of:
    template -> <prim(\"LANG_index_get_files_of\", template)>

"

	create-nbl-check = 
		<output-text-file(|["lib", "runtime", "nbl"], "check.str")>
"module runtime/nbl/check

imports
	
  runtime/nbl/resolve
  runtime/nbl/query
  runtime/nbl/uri
  runtime/nbl/entries
	
rules // Unresolved
 
  nabl-is-unresolved =
    ?node;
    has-annos;
    get-annos;
    where(nabl-has-reference);
    not(nabl-collect-one-resolved-def)

rules // Ambiguities
  
  nabl-get-ambiguities =
    nabl-collect-all-resolved-defs;
    mapconcat(nabl-get-all-aliases);
    filter(nabl-uri; nabl-uri-parent);
    make-set;
    where(<gt> (<length>, 1))

rules // Duplicate definitions
  
  nabl-get-duplicate-definitions =
    has-annos;
    get-annos;
    collect-one(?Def(_));
    nabl-get-all-definitions;
    make-set;
    where(<gt> (<length>, 1))

"

	create-nbl-collect = 
		<output-text-file(|["lib", "runtime", "nbl"], "collect.str")>
"module runtime/nbl/collect

imports
	
	runtime/task/core
	runtime/task/tasks
	runtime/nbl/tasks
	runtime/nbl/entries
	runtime/nbl/interface
	runtime/nbl/uri
	runtime/nbl/utils
	runtime/types/collect
	
signature 

	sorts
	
		State DefScope ImplicitDef Use RefScope Range

  constructors // state
  	
  	State : String * Term -> State

	constructors // def

		Current    :            	DefScope
		Subsequent :            	DefScope
		DefScope   : Term      -> DefScope
    Scope      : Namespace -> Scope
    
  constructors // use
      
		UseCandidate  : Namespace * List(Property) * RefScope * WildcardImport * List(Dependency) -> Use
		
		True  : WildcardImport
		False : WildcardImport
	
		Current     :                                     							RefScope
		Surrounding :                                  	 							  RefScope
		Context     : String * Namespace * List(Property) * RefScope -> RefScope
		RefScope    : Term                                           -> RefScope
		
    All : Range
    One : Range
    
    Completion : Result -> Completion
	
	constructors // import
	  
	  Wildcard : List(Import) * RefScope * DefScope * List(Dependency) -> ImportDesc
	  Single   : Term * DefScope * List(Dependency) -> ImportDesc
	  Imported : Namespace                   -> Namespace
	  Import   :                                Property
	  Import   : Language * Namespace        -> Property
	  Import   : Language * Namespace * Name -> Property
  	Type     : Property
  	
  constructors // property
    
    Prop : Property * Value * List(Dependency) -> Prop
    
  constructors // partition
  
  	CollectPartition : Partition
	
strategies // generic traversal
	
	/**
	 * Main strategy to collect all index elements and task* from an AST.
	 */
	nabl-collect(|partition, lang):
	  ast -> ast''
	  where
	    new-hashtable => unique*;
	    ast'  := <nabl-collect(id|lang, partition, unique*, [])> ast ;
	    ast'' := <alltd(message-task(|partition))> ast'
	  
	/**
	 * Performs the collection in a topdown traversal. 
	 * At each node, it tries various calls to generated strategies, which call back to generic strategies.
	 */
	nabl-collect(sibling-uris|lang, partition, unique*, uri*) =
		nabl-state-pop(?state*)
  ; try(nabl-scoping-site)
  ; (
		   nabl-scope-site(?uri'*|lang, partition, unique*, uri*)
		<+ match(?uri'*|uri*) 
		) 
  ; (
			 nabl-def-site(?child-uri*, sibling-uris, ?implicit*|lang, partition, unique*, uri'*, state*)
    <+ match(sibling-uris|uri*)
     ; match(?child-uri*|uri'*)
    )    
  ; try(nabl-state-site)
  // visit children from left to right  
  ; preserve-annos(force-origins(id#(nabl-siblings(|lang, partition, unique*, child-uri*))))
  ; try(nabl-use-site(|lang, partition, uri'*, state*))
  ; try(nabl-import-site(|lang, partition, child-uri*, state*))
  ; try(nabl-prop-site(|lang, partition, state*, implicit*))
  ; annotate-property-tasks(|partition)
    
	nabl-siblings(|lang, partition, unique*, uri*) = 
		[]  
	+ [ nabl-collect(?sibling-uri*|lang, partition, unique*, uri*)
		| nabl-siblings(|lang, partition, unique*, sibling-uri*) ]

rules // generic analysis of state
  
  nabl-state(pattern|state) =
    map(try(nabl-state-annotate(pattern|state)))
      
  nabl-state-annotate(pattern|state) =
    ?pattern; add-annotation(|state)
    
  nabl-state-pop(states'):
  	term{anno*} -> term'
  	where
  		state* := <collect-all(?State(_, _))> anno*;
  		term'  := <remove-annotations(?State(_, _))> term;
  		match(states'|state*)
  		
  nabl-get-state(|name) =
  	fetch-elem(?State(name, _))

rules // generic analysis of scopes
	
	nabl-scope-site(adapted-uris|lang, partition, unique*, uri*) =
	  remove-annotations(?Scope(ns*))
	; where (
	  	uri'* := <extend-scope-uri(nabl-extend-uri-anonymous(|unique*, partition)|lang)> (ns*, uri*)
	  ; match(adapted-uris| uri'*)
	  ; scope-uri* := <map(!(<id>, <lookup-uri(|uri'*)>))> ns*
	  )
	; add-annotation(|Scope(scope-uri*))
	  
	nabl-scope(|ns1*) = 
	   remove-annotations(?Scope(ns2*))
	 ; add-annotation(|Scope(<union> (ns1*, ns2*)))
	<+ add-annotation(|Scope(ns1*))
	 
rules // generic analysis of defs
    	
	// call back to generic analysis
	nabl-def(child-uris, sibling-uris|lang, partition, unique*, child-uri*, sibl-uri*, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d,anno*}
		where
			// get URI for namespace of definition site
			current-uri := <lookup-uri(|lang, ns)> child-uri*
		where
			switch !defscope
			  // in each case we 
			  // 1. build URI of the definition site
			  // 2. update URIs for children (vertical scope)
			  // 3. update URIs for right siblings (horizontal scope)
			 
			  // 1st case: definition in current scope
			  case Current(): 
		
			  // 1. extend current URI with ID segment
			  // 2. extend URIs of scoped namespaces
		 	  // 3. preserve
			    def-uri := <nabl-extend-uri(|unique*, partition, ns, name, unique)> current-uri
			  ; match(child-uris|<replace-scope-uri(|def-uri)> (scoped, child-uri*))
			  ; match(sibling-uris|sibl-uri*)
		   
		    // 2nd case: definition in subsequent scope and maybe in external scopes
		    case fetch-elem(?Subsequent()) => def-scope*:
		       
			  // 1. extend current URI with subsequent and ID segment
			  // 2. preserve
			  // 3. extend URI for namespace of definition site with Subsequent segment
			    subs-uri := <nabl-extend-uri-subsequent(|unique*, partition)> current-uri
			  ; def-uri  := <nabl-extend-uri(|unique*, partition, ns, name, unique)> subs-uri
		    ; match(child-uris|child-uri*)
			  ; match(sibling-uris|<replace-scope-uri(|subs-uri)> ([ns], sibl-uri*))
		
		    // 3rd case: definition only in external scopes
		    case is-list => def-scope*:
			  
		    // 1. extend base URI with anonymous and ID segment
		    // 2. preserve
		    // 3. preserve
		      ano-uri := <nabl-base-uri; nabl-extend-uri-anonymous(|unique*, partition)> lang 
		    ; def-uri := <nabl-extend-uri(|unique*, partition, ns, name, unique)> ano-uri
			  ; match(child-uris|child-uri*)
			  ; match(sibling-uris|sibl-uri*)
		  end
    where
      //introduce aliases
	    try(<filter(nabl-def-alias(|partition, def-uri))> def-scope*)
    with
			// add Def entry to the index
			d := <new-def(|partition, def-uri)> a
	
	nabl-def-alias(|partition, def-uri):
	  DefScope(term{anno*}) -> <new-alias(|partition, def-uri, alias-uri)>
	  where
	    <fetch-elem(?Scope(scope*))> anno*
	  ; ns        := <nabl-uri-namespace> def-uri
	  ; base-uri  := <lookup> (ns, scope*)
	  ; segment   := <nabl-uri-path; Hd> base-uri
	  ; alias-uri := <nabl-extend-uri(|segment)> base-uri
      
rules // generic analysis of uses
	
	// single candidate
	nabl-use(|lang, partition, uri*, candidate) =
		where (<not(is-list)> candidate);
		nabl-use(|lang, partition, uri*, [candidate])
	
	// list of candidates
	nabl-use(|lang, partition, uri*, candidate*):
		name{anno*} -> result
		where
			subtask* := <map(nabl-use-candidate(|lang, partition, uri*, <nabl-fix-name> name))> candidate*;
			choice   := <new-task(|partition)> Choice(subtask*);
		  u        := <new-use(|partition, choice)>;
		  if <is-completion-name> name then
		  	completion-subtask* := <mapconcat(nabl-completion-candidate(|lang, partition, uri*))> candidate*;
		  	completion-concat   := <new-task(|partition)> Concat(completion-subtask*);
		  	result              := name{u, Completion(completion-concat), anno*}
		  else
		  	result := name{u, anno*}
	  	end

	nabl-use-subtasks(disambiguate, wildcardimport|partition, ns, name, prop*, range): 
		uri  -> [task|subtasks]
		with
			task := <nabl-use-subtasks-one(disambiguate, wildcardimport|partition, ns, name, prop*, range)> uri;
      switch !range
      	case One(): ![]
      	case All(): <nabl-uri-parent < nabl-use-subtasks(disambiguate, id|partition, ns, name, prop*, range) + ![]> uri
    	end => subtasks
    	
  nabl-use-subtasks-one(disambiguate, wildcardimport|partition, ns, name, prop*, range):
		uri  -> disambiguated
		with
			defsTask            := <new-task(|partition)> ResolveDefs(<nabl-use-subtask-uri(|partition)> uri, ns, name);
			namedImportsTask    := <new-task(|partition)> ResolveNamedImports(<nabl-use-subtask-uri(|partition)> uri, ns, name);
			namedDefsTask       := <new-task(|partition)> ResolveDefs(namedImportsTask, ns, name);
			if wildcardimport then 
				wildcardImportsTask := <new-task(|partition)> ResolveWildcardImports(<nabl-use-subtask-uri(|partition)> uri, ns);
				wildcardDefsTask    := [<new-task(|partition)> ResolveDefs(wildcardImportsTask, ns, name)]
			else
				wildcardDefsTask := []
			end;
			
			if ExternalDef(x) := <nabl-uri-path; Hd> uri then
        ext-uri  := <nabl-uri-language; nabl-base-uri; nabl-extend-uri(|Anonymous(x))> uri;
        subtasks := [<new-task(|partition)> ResolveDefs(<nabl-use-subtask-uri(|partition)> ext-uri, ns, name)]
      else
      	subtasks := []
      end;
      
      concatted     := <new-task(|partition)> Concat([defsTask, namedDefsTask|<conc> (wildcardDefsTask, subtasks)]);
      filtered      := <nabl-use-propconstraint(|partition, prop*)> concatted;
      disambiguated := <nabl-use-disambiguate(disambiguate|partition, prop*, ns, name)> filtered
          	
	nabl-use-subtask-uri(|partition) = try(is-list; !Choice(<id>); new-task(|partition))
		  	
	// candidate in current scope
	nabl-use-candidate(|lang, partition, uri*, name):
		UseCandidate(ns, prop*, Current(), wci, _) -> choice
		where
			uri       := <lookup-uri(|lang, ns)> uri*;
      subtask*  := <nabl-use-subtasks(id, !wci; ?True()|partition, ns, name, prop*, All())> uri; // TODO: only disambiguate if required.
      choice    := <new-task(|partition)> Choice(subtask*)

	// candidate in another scope (result of resolution)	  
	nabl-use-candidate(|lang, partition, uri*, name):
		UseCandidate(ns, prop*, c@Context(ctx-ns, ctx-name, ctx-prop*, ctx-context), _, dep*) -> choice
		where
			ctx-result := <nabl-use-candidate(|lang, partition, uri*, ctx-name)> UseCandidate(ctx-ns, ctx-prop*, ctx-context, True(), dep*);
			subtask*   := <nabl-use-subtasks(id, id|partition, ns, <nabl-fix-name> name, prop*, One())> ctx-result; // TODO: only disambiguate if required.
			choice     := <new-task(|partition)> Choice(subtask*)
			
	nabl-use-propconstraint(|partition, prop*):
		task -> result
		where
			if not([] := prop*) then
				result := <new-task(|partition)> PropConstraint(prop*, task)
			else
				result := task
			end	

	nabl-use-disambiguate(disambiguate|partition, prop*, namespace, name):
		task -> result
		where
			disambiguate;
			result := <new-task(|partition)> DisambiguateDefs(task, prop*, namespace, name)

rules // completion

	// candidate in current scope
	nabl-completion-candidate(|lang, partition, uri*):
		UseCandidate(ns, prop*, Current(), wci, _) -> subtask*
		where
			uri       := <lookup-uri(|lang, ns)> uri*;
			subtask*  := <nabl-completion-subtasks(!wci; ?True()|partition, ns, prop*, All())> uri

	// candidate in another scope (result of resolution)	  
	nabl-completion-candidate(|lang, partition, uri*):
		UseCandidate(ns, prop*, c@Context(ctx-ns, ctx-name, ctx-prop*, ctx-context), _, _) -> subtask*
		where
			ctx-result := <nabl-use-candidate(|lang, partition, uri*, ctx-name)> UseCandidate(ctx-ns, ctx-prop*, ctx-context, True(), []);
			subtask*   := <nabl-completion-subtasks(id|partition, ns, prop*, One())> ctx-result
	
	nabl-completion-subtasks(wildcardimport|partition, ns, prop*, range): 
		uri  -> [task|subtasks]
		with
			task := <nabl-completion-subtasks-one(wildcardimport|partition, ns, prop*, range)> uri;
      switch !range
      	case One(): ![]
      	case All(): <nabl-uri-parent < nabl-completion-subtasks(id|partition, ns, prop*, range) + ![]> uri
    	end => subtasks
    	
  nabl-completion-subtasks-one(wildcardimport|partition, ns, prop*, range):
		uri  -> filtered
		with
			defsTask            := <new-task(|partition)> ResolveAllDefs(<nabl-use-subtask-uri(|partition)> uri, ns);
			
			// TODO: completions for imported definitions.
			/*
			namedImportsTask    := <new-task(|partition)> ResolveNamedImports(<nabl-use-subtask-uri(|partition)> uri, ns, name);
			namedDefsTask       := <new-task(|partition)> ResolveDefs(namedImportsTask, ns, name);
			if wildcardimport then 
				wildcardImportsTask := <new-task(|partition)> ResolveWildcardImports(<nabl-use-subtask-uri(|partition)> uri, ns);
				wildcardDefsTask    := [<new-task(|partition)> ResolveDefs(wildcardImportsTask, ns, name)]
			else
				wildcardDefsTask := []
			end;
			*/
			
			if ExternalDef(x) := <nabl-uri-path; Hd> uri then
        ext-uri  := <nabl-uri-language; nabl-base-uri; nabl-extend-uri(|Anonymous(x))> uri;
        subtasks := [<new-task(|partition)> ResolveAllDefs(<nabl-use-subtask-uri(|partition)> ext-uri, ns)]
      else
      	subtasks := []
      end;
      
      concatted     := <new-task(|partition)> Concat([defsTask]);
      filtered      := <nabl-use-propconstraint(|partition, prop*)> concatted
    
rules // generic analysis of imports
  
  nabl-import(|lang, partition, uri*, imports) =
    where(<map(nabl-import-candidate(|lang, partition, uri*))> imports)
  
  nabl-import-candidate(|lang, partition, uri*) =
    ?Single(term, scope*, dep)
  ; Def(uri) := <nabl-collect-def> term
  ; ns       := <nabl-uri-namespace> uri
  ; segment  := <nabl-uri-path; Hd> uri
  ; <map(nabl-import-alias(|lang, partition, uri*, uri, ns, segment))> scope*
       
  nabl-import-candidate(|lang, partition, uri*) =
    ?Wildcard(import*, from, into, dep)
  ; <map(nabl-import-prop(|lang, partition, uri*, from, into))> import*
  
  nabl-import-alias(|lang, partition, uri*, uri, ns, segment):
    scope -> <new-alias(|partition, uri, alias-uri)>
  where
    base-uri  := <nabl-scope-uri(|lang, uri*, ns)> 
  ; alias-uri := <nabl-extend-uri(|segment)> base-uri
    
  nabl-import-prop(|lang, partition, uri*, from, into):
    Import(lang, ins) -> <new-prop(|partition, into-uri, Import(), (ins, from-uri))>
  where
     Imported(ns) := ins
  <+ ns           := ins
  where
    from-uri := <nabl-scope-uri(|lang, uri*, ns)> from 
  ; into-uri := <nabl-scope-uri(|lang, uri*, ns)> into 
  ; Result(import-calc)    := <new-task(|partition, <dependent-tasks> from-uri)> ImportCalc(into-uri)
  ; Result(import-closure) := <new-task(|partition, [import-calc])> ImportClosure(into-uri)
        
  nabl-scope-uri(|lang, uri*, ns):
    Current() -> <lookup-uri(|lang, ns)> uri*
  
  nabl-scope-uri(|lang, uri*, ns):
    DefScope(term{anno*}) -> <lookup> (ns, scope*)
    where
      <fetch-elem(?Scope(scope*))> anno*
      
  nabl-scope-uri(|lang, uri*, ns):
    Context(_, name, _, _) -> uri
    where
      Use(uri) := <nabl-collect-use> name
      
rules // generic analysis of properties
  
  // call back to generic analysis
	nabl-props(|partition, prop*):
	  name -> name'
	  where
	    Def(uri) := <nabl-collect-def> name;
		  name'    := <foldl(extend-prop(|partition, uri))> (prop*, name)
      
	extend-prop(|partition, uri):
		(Prop(type, result, dep*), name) -> name
		where
		  prop := <new-prop(|partition, uri, type, result)> name
        
rules // name retrieval
  
  nabl-name = is-string
  
  nabl-name-apply(s) = is-string; s
    
  nabl-fix-name = try(fix-completion-name); strip-annos
  
rules // URI retrieval
  
  nabl-collect-def =
    try(nabl-name);
    get-annos;
    collect-one(?Def(_))
    
  nabl-collect-all-def =
    try(nabl-name);
    get-annos;
    collect-all(?Def(_))
    
  nabl-collect-use =
    try(nabl-name);
    get-annos;
    collect-one(?Use(_))
    
  nabl-collect-all-use =
    try(nabl-name);
    get-annos;
    collect-all(?Use(_))
    
  nabl-collect-completion =
    get-annos;
    collect-one(?Completion(_))
    
  nabl-collect-all-completion =
    get-annos;
    collect-all(?Completion(_))

rules // helpers
	
	replace-scope-uri(|path) = foldl(update-scope-uri(!path|<nabl-uri-language> path))
  extend-scope-uri(s|lang) = foldl(update-scope-uri(s|lang))
  
	update-scope-uri(update|lang):
		(key, uri*) -> result
		where
		  result := <fetch((?key, update))> uri* 
		<+ 
		  result := [(key, <nabl-base-uri; update> lang)|uri*]
			  
	lookup-uri(|lang, ns) =
	  <lookup> (ns, <id>) <+ <nabl-base-uri> lang
 
  lookup-uri(|uri*) =
    <lookup> (<id>, uri*)

"

	create-nbl-complete = 
		<output-text-file(|["lib", "runtime", "nbl"], "complete.str")>
"module runtime/nbl/complete

imports
	
	runtime/nbl/collect
  runtime/nbl/uri
  runtime/task/core
  
signature

  constructors
    
    COMPLETION : String -> COMPLETION
    
rules // Code completion

  nabl-propose-completions:
    ast -> proposal*
    with
	    	completion* := <collect-one(?COMPLETION(_)); nabl-collect-all-completion> ast;
				def*        := <mapconcat(\\Completion(result) -> result\\; task-get-solved)> completion*;
				proposal*   := <map(nabl-uri; nabl-uri-name)> def*
			<+
				proposal*   := []
"

	create-nbl-entries = 
		<output-text-file(|["lib", "runtime", "nbl"], "entries.str")>
"module runtime/nbl/entries

imports
  
  runtime/nbl/collect
  runtime/nbl/utils
  runtime/nbl/uri
  runtime/index/core
  
signature

  constructors
    
    Def   : URI                    -> Entry
    Alias : URI * URI              -> Entry
    Use   : URI                    -> Entry
    Prop  : URI * Property * Value -> Entry
  
rules
  
  new-def(|partition, uri):
    x -> definition
    with
      definition := <force-origins(!Def(uri))> x;
      <index-add(|partition)> definition;
			<new-alias(|partition, <nabl-nonunique-uri> uri, uri)> x
      
  new-alias(|partition, uri, alias-uri):
    x -> alias
    with
      alias := <force-origins(!Alias(uri, alias-uri))> x;
      if <not(eq)> (uri, alias-uri) then
      	<index-add(|partition)> alias
      end
      
  new-use(|partition, uri):
    x -> use
    with
      use := <force-origins(!Use(uri))> x;
      <index-add(|partition)> use

  new-prop(|partition, uri, kind, val):
    x -> prop
    with
      prop := <force-origins(!Prop(uri, kind, val))> x;
      <index-add(|partition)> prop
      
rules // index uri & value projections
  
  /** @internal */
  nabl-uri-impl:
    Def(uri) -> uri
    
  /** @internal */
  nabl-uri-impl:
    Alias(uri, _) -> uri
    
  /** @internal */  
  nabl-uri-impl:
    Use(uri) -> <nabl-is-uri> uri
    
  /** @internal */  
  nabl-uri-impl:
    Prop(uri, _, _) -> uri
    
    
  /** @internal */
  nabl-value-impl:
    Def(value) -> value
    
  /** @internal */
  nabl-value-impl:
    Alias(_, value) -> value

  /** @internal */
  nabl-value-impl:
    Use(value) -> value
    
  /** @internal */
  nabl-value-impl:
    Prop(_, _, value) -> value

"

	create-nbl-interface = 
		<output-text-file(|["lib", "runtime", "nbl"], "interface.str")>
"module runtime/nbl/interface

strategies // Collect
  
	nabl-scoping-site = fail
	
	nabl-def-site(
	  child-uris, sibiling-uris, implicits
	| lang, partition, unique*, uri*, state*
	) = fail
	
	nabl-state-site = fail
	
	nabl-use-site(|lang, partition, uri*, state*) = fail
	
	nabl-import-site(|lang, partition, uri*, state*) = fail
	
	nabl-prop-site(|lang, partition, state*, implicit*) = fail
	
strategies // Projections
  
	nabl-name = fail
	
	nabl-name-apply(s) = fail
	
	nabl-scopes = fail

strategies // Tasks
  
	calc-property = fail

	message-task(|partition) = fail
	
strategies // Lookup hooks
	
	nabl-property-eq(|kind) = fail
	
	nabl-disambiguate(|prop*, namespace, name) = fail

"

	create-nbl-lookup = 
		<output-text-file(|["lib", "runtime", "nbl"], "lookup.str")>
"module runtime/nbl/lookup

imports
  
  runtime/nbl/collect
  runtime/nbl/query
  runtime/nbl/tasks
  runtime/nbl/uri
  runtime/nbl/entries
  runtime/task/core

rules // Lookup
	
	nabl-lookup(|ns, name):
		uri -> def*
		with
  		uri' := <nabl-extend-uri(|ns, name, ())> uri;
  		def* := <nabl-get-all-definitions> uri'

	nabl-lookup-all(|ns):
		uri -> def*
		with
  		def*  := <nabl-get-child-definitions(|ns)> uri

	nabl-lookup-named-import(|ns, name):
		uri -> import*
		with
			language := <nabl-uri-language> uri;
      import*  := <nabl-get-import-uris-named(|language, ns, name)> uri
			  		
	nabl-lookup-unnamed-import(|ns):
		uri -> import*
		with
			language := <nabl-uri-language> uri;
      import*  := <nabl-get-import-uris-unnamed(|language, ns)> uri

rules // Imports

  nabl-get-import-uris-unnamed(|language, namespace):
  	uri -> <nabl-get-import-uris-unnamed(|[uri], 0, language, namespace)> uri

  nabl-get-import-uris-unnamed(|seen, count, language, namespace):
    uri -> result
    with
      importResult*        := <nabl-get-all-properties(|Import(language, namespace))> uri;
      importURI*           := <map(task-get-solved; filter(nabl-uri) <+ task-create-dependencies; ![<id>]); concat> importResult*;
      if d1 := <task-collect-dependencies> importURI* then
      	result := [d1]
      else
	      importedResult*      := <nabl-get-all-properties(|Import(language, Imported(namespace)))> uri;
	      importedURI*         := <map(task-get-solved; filter(nabl-uri) <+ task-create-dependencies; ![<id>]); concat> importedResult*;
	      if d2 := <task-collect-dependencies> importedURI* then
	      	result := [d2]
	      else
		      transitiveImportURI* := <filter(nabl-get-import-uris-unnamed-transitive(|seen, count, language, namespace)); concat> importedURI*;
		      result               := [importURI*, transitiveImportURI*]
      	end
    	end

  nabl-get-import-uris-unnamed-transitive(|seen, count, language, namespace):
    uri -> transitiveImportURI*
    where
    	not(<lt> (count, 1));
      not(<fetch(?uri)> seen);
      transitiveImportURI* := <nabl-get-import-uris-unnamed(|[uri|seen], <dec> count, language, namespace)> uri

  nabl-get-import-uris-named(|language, namespace, name):
    uri -> importURI*
    with
      importResult* := <nabl-get-all-properties(|Import(language, namespace, name))> uri;
      importURI*    := <map(task-get-solved <+ task-create-dependencies; ![<id>]); concat> importResult*

"

	create-nbl-query = 
		<output-text-file(|["lib", "runtime", "nbl"], "query.str")>
"module runtime/nbl/query

imports
  
  runtime/nbl/uri
  runtime/nbl/entries
  runtime/index/query
  
rules // Specific queries

  /**
   * Gets all unique and non-unique definition entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-definitions> [Entity(), \"M\", \"Bar\"] => [Def([Entity(), \"M\", \"Bar\"]), ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Def(uri))
   */
  nabl-get-all-definitions:
    containsURI -> <nabl-get-unique-nonunique(\\uri -> Def(uri)\\)> uri
    where
    	uri := <nabl-uri> containsURI
    	
  /**
   * Gets all child definition entries in given URI that match given namespace.
   *
   * Example:
   *   <nabl-get-child-definitions> [Entity(), \"M\", \"Bar\"] => [Def([Field(), \"a\", \"M\", \"Bar\"]), ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Def(uri))
   */
  nabl-get-child-definitions(|ns):
    containsURI -> <nabl-get-children(|ns)> Def(uri)
    where
    	uri := <nabl-uri> containsURI

  /**
   * Gets a property that matches the kind of value and given URI, or fails if no property is found.
   *
   * Example:
   *   <nabl-get-property(|Size())> Def([Entity(), \"Bar\"]) => Size(8)
   *
   * @param type Only properties of this kind is returned.
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> Prop(uri, kind, value)
   */
  nabl-get-property(|kind) = 
  	nabl-get-all-properties(|kind); Hd
      
  /**
   * Gets all properties that match the kind of value and given URI.
   *
   * Example:
   *   <nabl-get-all-properties(|Size())> Def([Entity(), \"Bar\"]) => [Size(8), ...]
   *
   * @param kind Only data of this kind is returned.
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Prop(uri, kind, value))
   */
  nabl-get-all-properties(|kind):
		containsURI -> <nabl-get-all-values> Prop(uri, kind, ())
    where
    	uri := <nabl-uri> containsURI
     
  /**
   * Gets all Use entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-uses> Def([Entity(), \"M\", \"Bar\"]) => [Use([Entity(), \"M\", \"Bar\"]), ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Use(uri))
   */
  nabl-get-all-uses:
    containsURI -> <nabl-get-all> Use(uri)
    where
    	uri := <nabl-uri> containsURI

  /**
   * Gets all Alias entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-aliases> Def([Entity(), \"M\", \"Bar\"]) => [[Entity(), \"M\", \"Baz\"], ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(aliasURI)
   */
  nabl-get-all-aliases:
    containsURI -> aliasURI*
    where
    	uri := <nabl-uri> containsURI;
      if nonUniqueURI := <nabl-replace-uri-qualifier(|NonUnique())> uri then
        aliasURI* := <nabl-get-all-values> Alias(nonUniqueURI, ()) 
      else
        aliasURI* := []
      end

rules // Generic queries
  
  nabl-get-all:
    template -> <index-get-all> template
       
  nabl-get-all-values:
    template -> <nabl-get-all; map(nabl-value)> template

  nabl-get:
    template -> <nabl-get-all; Hd> template
     
  nabl-get-value:
    template -> <nabl-get-all; Hd; nabl-value> template
  
  nabl-get-children:
    template -> entries
      with
        entries  := <index-get-children> template

  nabl-get-children(|namespace):
    template -> entries
      with
        children := <index-get-children> template;
        entries  := <nabl-filter-entries(|namespace)> children
        
  nabl-get-children(|namespace, prefix):
    template -> entries
      with
        children := <index-get-children> template;
        entries  := <nabl-filter-entries(|namespace, prefix)> children

  nabl-get-unique-nonunique(create-template):
  	uri -> [unique*, nonUnique*]
  	where
      if alias* := <nabl-get-all-aliases> uri then
        unique* := <mapconcat(create-template; nabl-get-all)> alias*
      else
        unique* := []
      end;
      if nonUniqueURI := <nabl-replace-uri-qualifier(|NonUnique())> uri then
        nonUnique*    := <create-template; nabl-get-all> nonUniqueURI
      else
        nonUnique*    := []
      end

rules /** @internal Entry filtering */
  
  /** @internal */
  nabl-filter-entries(|namespace, prefix):
    entry* -> <filter(nabl-compare-prefix(|namespace, prefix))> entry*
  
  /** @internal */
  nabl-filter-entries(|namespace):
    entry* -> <filter(nabl-compare-namespace(|namespace))> entry*

rules /** @internal Helpers */
  
  /** @internal */
  nabl-compare-prefix(|namespace, prefix):
    entry -> <id>
    where
      uri := <nabl-uri> entry;
      <eq> (namespace, <nabl-uri-namespace> uri);
      <is-substring(!prefix)> <nabl-uri-name> uri
      
  /** @internal */
  nabl-compare-namespace(|namespace):
    entry -> <id>
    where
      uri := <nabl-uri> entry;
      <eq> (namespace, <nabl-uri-namespace> uri)

"

	create-nbl-resolve = 
		<output-text-file(|["lib", "runtime", "nbl"], "resolve.str")>
"module runtime/nbl/resolve

imports
  
  runtime/nbl/tasks
	runtime/nbl/entries
	runtime/task/core
      
rules // Reference resolution
  
  nabl-is-reference =
    ?Use(_)
    
  nabl-has-reference =
    collect-one(nabl-is-reference)
    
  nabl-has-reference =
    has-annos;
    get-annos;
    nabl-has-reference
  
  // TODO: does not go through annotations?
	nabl-collect-all-resolved-defs:
		ast -> def*
		with
			if ast' := <insert-results> ast then
				def* := <collect-all(?Def(_))> ast'
			else
				def* := []
			end

	nabl-collect-one-resolved-def =
		insert-results-or-create-dependency;
		oncetd-annos((?Def(_) <+ ?Dependency(_)); ?d); !d
		
	oncetd-annos(s) = s <+ has-annos; get-annos; one(oncetd-annos(s)) <+ one(oncetd-annos(s))
	
"

	create-nbl-tasks = 
		<output-text-file(|["lib", "runtime", "nbl"], "tasks.str")>
"module runtime/nbl/tasks

imports 
  
  runtime/task/core
  runtime/nbl/lookup
  runtime/nbl/collect
  runtime/nbl/query
  runtime/nbl/interface
  runtime/nbl/uri
  runtime/nbl/utils
  runtime/nbl/entries
  
signature
  
  constructors
    
    ResolveDefs            : Scope * Namespace * Name                  -> Instruction
    DisambiguateDefs       : List(Def) * List(Prop) * Namespace * Name -> Instruction
    ResolveNamedImports    : Scope * Namespace * Name                  -> Instruction
    ResolveWildcardImports : Scope * Namespace                         -> Instruction
    ImportCalc             : URI                                       -> Instruction
    ImportClosure          : URI                                       -> Instruction
    PropConstraint         : List(Prop) * List(Result)                 -> Instruction
    PropCalc               : Property * Term                           -> Instruction
        
    ResolveAllDefs         : Scope * Namespace                  -> Instruction
        
rules // Resolve
  
  // Looks up defintions in scopes with namespace and name.
  perform-task(|nr):
  	ResolveDefs(scope, ns, name) -> def*
  	where
  		uri   := <nabl-uri> scope;
  		name' := <try-remove-list; strip-annos> name; // TODO: can this be a list?
  		<nabl-add-read-extend(|nr, ns, name')> uri;
  		def*  := <nabl-lookup(|ns, name')> uri;
  		not(?[])

	// Calls a user-defined disambiguation filter on definitions with relevant information.
	perform-task(|nr):
		DisambiguateDefs(def*, prop*, namespace, name) -> result
		where
			if <Tl> def* then
				<try(nabl-disambiguate(|prop*, namespace, name))> def*
			else
				!def*
			end => result

	task-is-combinator = ?DisambiguateDefs(_, _, _, _)

	// Looks up named imports, active in scopes with namespace and name..
	perform-task(|nr):
		ResolveNamedImports(scope, ns, name) -> result
		where
			uri     := <nabl-uri> scope;
			<nabl-add-read(|nr)> uri;
			name'   := <try-remove-list; strip-annos> name; // TODO: can this be a list?
			import* := <nabl-lookup-named-import(|ns, name')> uri;
      switch id
      	case ?[]                            : fail
      	case task-collect-dependencies => d : !d
      	otherwise                           : id
      end => result
	
	// Looks up wildcard imports for a namespace active in scopes.
	perform-task(|nr):
		ResolveWildcardImports(scope, ns) -> result
		where
			uri         := <nabl-uri> scope;
			import-uri* := <resolve-one-wildcard-import(|nr, ns)> uri;
      switch id
      	case ?[]                            : fail
      	case task-collect-dependencies => d : !d
      	otherwise                           : id
      end => result
			
	resolve-one-wildcard-import(|nr, ns):
		uri -> result
		with
			<nabl-add-read(|nr)> uri;
			if task-exists(|ImportClosure(uri)) then
				import-closure-id := <task-instruction-id> ImportClosure(uri);
				switch id
					case task-has-failed                                  : <task-add-dependency-nocycle(|nr)> import-closure-id; ![]
					case task-get-result; Hd => h                         : <task-add-dependency-nocycle(|nr)> import-closure-id; <hashtable-get(|ns) <+ ![]> h
					case not(task-becomes-cyclic(|nr, import-closure-id)) : ![<task-create-dependency> import-closure-id]
					otherwise                                             : ![]
				end => result
			else
				result := []
			end

rules // Visibility
	
  // Looks up defintions in scopes with namespace and name.
  perform-task(|nr):
  	ResolveAllDefs(scope, ns) -> def*
  	where
  		uri  := <nabl-uri> scope;
  		def* := <nabl-lookup-all(|ns)> uri;
  		not(?[])

rules // Import calculation
	
	// Import calculation.
	perform-task(|nr):
		ImportCalc(uri) -> result
		where
			<nabl-add-read(|nr)> uri;
			import-ns-use*        := <nabl-get-all-properties(|Import())> uri;
			(imported-uri*, uri*) := <partition(resolve-transitive-import, resolve-import)> import-ns-use*;
  		switch id
        case d := <task-collect-dependencies> : !d
        otherwise                             : id
			end => result

	resolve-transitive-import: (Imported(ns), use) -> (ns, <resolve-import-use> use)
	resolve-import: (ns, use) -> (ns, <resolve-import-use> use)
	resolve-import-use = task-get-solved; filter(nabl-uri) <+ task-create-dependencies
	
	// Import transitive closure calculation.
	perform-task(|nr):
		ImportClosure(uri) -> result
		with
			<nabl-add-read(|nr)> uri;
			import-calc-id        := <task-instruction-id> ImportCalc(uri);
			(imported-uri*, uri*) := <task-get-result; Hd> import-calc-id; // Result for this task must exit, as a dependency is expressed on it during collect.
			hashtable             := <new-hashtable>;
			<map(import-to-hash-table(|hashtable))> uri*;
			d* := <collect-all(?URI(_, _)); mapconcat(import-closure-transitive(|nr, hashtable))> imported-uri*;
			switch id
				case task-collect-dependencies => d : !d
				otherwise                           : !hashtable
			end => result
			
	import-to-hash-table(|hashtable):
		(ns, import-uri*) -> <hash-multimap-putlist(|ns, import-uri*)> hashtable
		
	import-closure-transitive(|nr, hashtable):
		uri	-> result
		with
			<nabl-add-read(|nr)> uri;
			if task-exists(|ImportClosure(uri)) then
				import-closure-id := <task-instruction-id> ImportClosure(uri);
				switch id
					case task-has-failed                                  : <task-add-dependency-nocycle(|nr)> import-closure-id; ![]
					case task-get-result; Hd => h                             : <task-add-dependency-nocycle(|nr)> import-closure-id; <hash-multimap-copy(|h)> hashtable; ![]
					case not(task-becomes-cyclic(|nr, import-closure-id)) : ![<id>]
					otherwise                                             : ![]
				end => result
			else
				result := []
			end

rules // Property constraints
	  
  perform-task(|nr):
  	PropConstraint(prop*, res*) -> result
  	where
  		filtered := <filter(nabl-resolve-constraint(|prop*))> res*;
      switch id
      	case task-collect-dependencies => d : !d
      	otherwise                           : id
      end => result
      
  task-is-combinator = ?PropConstraint(_, _)
  		
  nabl-resolve-constraint(|prop*):
    entry -> entry'
    where
      filtered := <filter(nabl-resolve-constraint-one(|entry))> prop*;
      switch id
      	case ?[]                            : fail
      	case task-collect-dependencies => d : !d
      	otherwise                           : !entry
      end => entry'
      
  // TODO: check dependencies (3rd subterm) as well.
  nabl-resolve-constraint-one(|entry):
    Prop(type, expectedValue, _) -> entry'
    where
    	uri   := <nabl-uri> entry;
      value := <nabl-get-property(|type)> uri;
      if value' := <insert-results> value then
        expectedValue' := <insert-results> expectedValue;
        <nabl-property-eq(|type) <+ eq> (expectedValue', value');
        entry' := entry
      else
        entry' := <task-create-dependencies> value
      end

rules // Utility
	
	nabl-add-read(|nr) = try(nabl-replace-uri-qualifier(|())); task-add-read(|nr)
	nabl-add-read-extend(|nr, ns, name) = nabl-extend-uri(|ns, name, ()); task-add-read(|nr)

"

	create-nbl-uri = 
		<output-text-file(|["lib", "runtime", "nbl"], "uri.str")>
"module runtime/nbl/uri

imports
  
  runtime/nbl/interface
  runtime/index/core
  
signature

  sorts
  
    Language
    Segment
    Qualifier
    
  constructors
    
    Language    : String                       -> Language
    ID          : Namespace * Name * Qualifier -> Segment
    Subsequent  : String                       -> Segment
    Anonymous   : String                       -> Segment
    ExternalDef : String                       -> Segment
    Unique      : String                       -> Qualifier
    NonUnique   :                                 Qualifier
    Unique      :                                 Qualifier
    URI         : Language * List(Segment)     -> URI
    
rules // Construction
  
  nabl-base-uri = 
    !URI(<id>, [])
     
  nabl-extend-uri(|segment) = 
    URI(id, ![segment|<id>])
    
  nabl-extend-uri(|namespace, name, qualifier) = 
    URI(id, ![ID(namespace, name, qualifier)|<id>])
    
  nabl-replace-uri(|segment) = 
    URI(id, [!segment|id])
    
  nabl-replace-uri(|namespace, name, qualifier) = 
    URI(id, [!ID(namespace, name, qualifier)|id])
    
  nabl-replace-uri-qualifier(|qualifier) =
    URI(id, [ID(id, id, !qualifier)|id])
      
  nabl-external-segment: Anonymous(name) -> ExternalDef(name)
  
	nabl-nonunique-uri =
		URI(id, [ID(id, id, !NonUnique())|id])

rules // stable URI extensions
  
  nabl-extend-uri(|table, partition, ns, n, u):
    uri -> <nabl-extend-uri(|ns, n, qualifier)> uri
    where 
	    if where(<?NonUnique()> u) then
	      qualifier := NonUnique()
	    else
	      qualifier := Unique(<stable-uri-part(|table, partition)> (partition, uri, ns, n))
	    end
    
  nabl-extend-uri-anonymous(|table, partition):
    uri -> <nabl-extend-uri(|Anonymous(unique))> uri
    where
      unique := <stable-uri-part(|table, partition)> (partition, uri, \"anonymous\")
      
  nabl-extend-uri-subsequent(|table, partition):
    uri -> <nabl-extend-uri(|Subsequent(unique))> uri
    where
      unique := <stable-uri-part(|table, partition)> (partition, uri, \"subsequent\")

  stable-uri-part(|table, partition):
    key -> $[[partition]/[unique]]
    where
      if value := <hashtable-get(|key)> table then
        unique    := <int-to-string> value;
        new-value := <inc> value
      else
        unique    := \"0\";
        new-value := 1
      end;
      <hashtable-put(|key, new-value)> table
      
rules // Projections
  
  nabl-uri = 
    nabl-uri-impl <+ nabl-uri-generic
    
  nabl-value = 
    nabl-value-impl <+ nabl-value-generic
  
  nabl-uri-language:
    URI(language, _) -> language
    
  nabl-uri-language-name:
    URI(Language(name), _) -> name
    
  nabl-uri-path:
    URI(_, path) -> path
    
  nabl-uri-parent:
    URI(language, path) -> URI(language, parent)
    where
      [_|parent] := path
  
  nabl-uri-parent(|targetNamespace):
    URI(language, path) -> URI(language, parent')
    where
      [_|parent] := path;
      if [segment|_] := parent; namespace := <nabl-segment-namespace> segment then
        if <nabl-scopes> (namespace, targetNamespace) then
          parent' := parent
        else
          parent' := <nabl-uri-parent(|targetNamespace)> parent
        end
      else
        parent' := parent
      end
      
  nabl-uri-name:
    uri -> <nabl-uri-path; Hd; nabl-segment-name> uri
    
  nabl-uri-namespace:
    uri -> <nabl-uri-path; Hd; nabl-segment-namespace> uri    

  nabl-uri-qualifier:
    uri -> <nabl-uri-path; Hd; nabl-segment-qualifier> uri
      
  nabl-segment-namespace:
    ID(namespace, _, _) -> namespace
    
  nabl-segment-name:
    ID(_, name, _) -> name
    
  nabl-segment-qualifier:
    ID(_, _, qualifier) -> qualifier
    
  nabl-uri-scope      = URI(id, Tl)
  nabl-uri-scopes    = nabl-closure(nabl-uri-scope)
  
  nabl-uri-in-scope  = URI(id, [id|Tl])
  nabl-uri-in-scopes = nabl-closure(nabl-uri-in-scope)
  
  nabl-closure(s) = 
      s 
    < ![<id>|<nabl-closure(s)>] 
    + ![]

rules // Conditions
  
  nabl-is-uri =
  	?URI(_, _)
  
  nabl-is-unique =
    nabl-uri-qualifier;
    ?Unique(_)
    
  nabl-is-nonunique =
    nabl-uri-qualifier;
    ?NonUnique()

rules // Equality
  
  nabl-uri-eq = 
    ?(URI(lang1, segs1), URI(lang2, segs2));
    <eq> (lang1, lang2);
    <zip(nabl-uri-segment-eq)> (segs1, segs2)
    
  nabl-uri-segment-eq =
    ?(ID(ns1, name1, _), ID(ns2, name2, _));
    <eq> (ns1, ns2);
    <eq> (name1, name2)
     
  nabl-uri-segment-eq =
    ?(Subsequent(_), Subsequent(_))
    
  nabl-uri-segment-eq =
    ?(Anonymous(_), Anonymous(_))
    
  nabl-uri-segment-eq =
    ?(ExternalDef(_), ExternalDef(_))

rules // Printing
  
  nabl-print-uri:
    uri -> $[[ns] [names]]
    where
      ns#(_) := <nabl-uri-namespace> uri;
      names  := <nabl-uri-path; filter(nabl-segment-name); separate-by(|\".\"); concat-strings> uri
        
rules /** @internal Projections */

  /** @internal */
  nabl-uri-impl:
    URI(_, _) -> <id>

  /** @internal */
  nabl-uri-generic:
    term -> <not(is-list); ?_#(<?[<id>|_]>); nabl-is-uri> term
    
  /** @internal */
  nabl-value-impl:
    URI(_, _) -> <id>
    
  /** @internal */
  nabl-value-generic:
    term -> <not(is-list); ?_#(<?[_, <id>|_]> ); nabl-is-uri> term
    
  /** @internal */  
  nabl-uri-impl:
    _{anno*} -> <fetch-elem(nabl-uri)> anno*

  /** @internal */  
  nabl-value-impl:
    _{anno*} -> <fetch-elem(nabl-value)> anno*

"

	create-nbl-utils = 
		<output-text-file(|["lib", "runtime", "nbl"], "utils.str")>
"module runtime/nbl/utils

imports
	
	libstratego-lib
	runtime/task/core

rules 
	
	match(m|val) = where (!val; m)
	
	vdebug(s) = where(verbose < debug(s) + id)
	verbose   = fail

  force-origins(s) =
    ![<id>]; all(s); ?[<id>]

	is-completion-name = ?\"completion123\"
  fix-completion-name = is-completion-name; !\"\"

  add-annotation(|a):
    t{a*} -> t{a, a*}

  remove-annotations(s):
    t{a*} -> t{a'*}
    where
      a'* := <remove-all(s)> a*
  
  measure-time(s, log) =
    where(before := <times>);
    s;
    where(after := <times>; !(after, before); diff-times; times-to-seconds; Fst; log)
  
  measure-time(s, log | name) = 
    measure-time(s, record-time(|name); log)
  
  record-time(|name) = id
    
  //external record-time-native(|name)
  	
 	try-make-list = is-list <+ ?Dependency(_) <+ ![<id>]
		
	try-remove-list = is-list < Hd + id
		
rules // multimap simulation
	
	hash-multimap-put(|key, value):
		hashtable -> hashtable
		where
			values := <hash-multimap-getorcreate(|key)> hashtable;
			<hashtable-put(|key, [value|values])> hashtable 
			
	hash-multimap-putlist(|key, put-value*):
		hashtable -> hashtable
		where
			value* := <hash-multimap-getorcreate(|key)> hashtable;
			<hashtable-put(|key, [value*, put-value*])> hashtable 
			
	hash-multimap-getorcreate(|key) =
		hashtable-get(|key) <+ hashtable-put(|key, []); ![]
	
	hash-multimap-copy(|from):
		to -> to
		where
			// wtf is this I don't even.. hashtable-fold needs term arguments instead of current term arguments.
			<hashtable-fold(hash-multimap-copy-fold|to)> from
			
	hash-multimap-copy-fold(|key, value*):
		to -> <hash-multimap-putlist(|key, value*)> to

"

	create-task-core = 
		<output-text-file(|["lib", "runtime", "task"], "core.str")>
"module runtime/task/core

imports 
  
  runtime/task/interface
  runtime/task/utils
  
signature

  sorts
  
    Result Instruction
  
  constructors
    
    Result : TaskID -> Result
    Fail : Result
    
    Single     : List(Result) -> Result
    Dependency : List(TaskID) -> Result
		
rules // Creation
  
  tdebug(s) = id
  //tdebug(s) = debug(s)
  
  new-task(|partition) = new-task(|partition, <dependent-tasks>)
  new-task(|partition, dependencies) = 
  		task-is-combinator; task-add-combinator(|partition, dependencies, <id>) 
  	<+ 
  		task-add-task(|partition, dependencies, <id>)
   
  //    tdebug(!\"new task \")
  //  ; avoid-task(|dependencies)
  //  ; tdebug(!\"avoided \")
  // <+ task-add-task(|partition, dependencies, <id>)
  //  ; tdebug(!\"added \")
      
  dependent-tasks = collect-all(dependent-task, union); flatten-list; make-set
  dependent-task = ?Result(<id>) 
  dependent-task =
    has-annos; get-annos; dependent-tasks

rules // Dependencies
	
  task-create-dependencies =
  	collect-all(?Result(<id>));
  	!Dependency(<id>)

  task-create-dependency =
		!Dependency([<id>])
  	
	task-has-dependencies =
		fetch(?Dependency(_))
		
	task-collect-dependencies =
		collect-all(?Dependency(<id>));
		concat;
		where(Hd);
		!Dependency(<id>)

rules // Results

	insert-results-hashmap(|results-hashmap) =
		switch id
			case has-annos  : !(<id>, <get-annos; insert-results-hashmap(|results-hashmap)>); set-annos
			case is-list    : filter(insert-results-hashmap(|results-hashmap); not(?[]))
			case ?Result(n) : (<hashtable-get(|n)> results-hashmap) <+ <with(fail|\"Cannot insert result: \")> n
			otherwise       : all(insert-results-hashmap(|results-hashmap))
		end
	
	insert-results-with-fail =
		switch id
			case has-annos  : !(<id>, <get-annos; insert-results-with-fail>); set-annos
			case is-list    : filter(insert-results-with-fail; not(?[]))
			case ?Result(n) : (task-api-get-results(|n) <+ (task-api-has-failed(|n); ![]) <+ with(fail|\"Cannot insert result: \"))
			otherwise       : all(insert-results-with-fail)
		end
	
	insert-results =
		switch id
			case has-annos  : !(<id>, <get-annos; insert-results>); set-annos
			case is-list    : map(insert-results); remove-all(?[])
			case ?Result(n) : task-api-get-results(|n) <+ (task-api-has-failed(|n); ![])
			otherwise       : all(insert-results)
		end
		
	insert-results-or-create-dependency =
		switch id
			case has-annos  : !(<id>, <get-annos; insert-results-or-create-dependency>); set-annos
			case is-list    : map(insert-results-or-create-dependency); remove-all(?[])
			case ?Result(n) : task-api-get-results(|n) <+ (task-api-has-failed(|n); ![]) <+ !Dependency([n])
			otherwise       : all(insert-results-or-create-dependency)
		end
	
rules // Projections
	
	task-result-id:
    Result(taskID) -> taskID

	task-collect-result-ids =
		collect-all-annos(task-result-id, union)

rules // API
	
	task-setup(|project-path)                            = task-api-setup(|project-path)
	task-start-collection(|partition)                    = task-api-start-collection(|partition)
	task-stop-collection(|partition)                     = task-api-stop-collection(|partition)
	task-add-task(|partition, dependencies, instruction) = task-api-add-task(|partition, dependencies, instruction)
	task-add-combinator(|partition, dependencies, instruction) = task-api-add-combinator(|partition, dependencies, instruction)
	task-becomes-cyclic(|taskIDFrom, taskIDTo)           = task-api-becomes-cyclic(|taskIDFrom, taskIDTo)
	task-debug-info(|partition)                          = task-api-debug-info(|partition)
	task-add-message(|taskID, message)                   = task-api-add-message(|taskID, message)
	task-get-messages(|partition)                        = task-api-get-messages(|partition)
	task-evaluate(|changed-read*)                        = task-api-evaluate(task-collect-result-ids, 
	                                                         insert-results-hashmap, task-perform-task|changed-read*)
	task-exists(|instruction)                            = task-api-exists(|instruction)
	task-reset                                           = task-api-reset
	task-persist                                         = task-api-persist
	task-unload(|project-path)                           = task-api-unload(|project-path)
	task-unload                                          = task-unload(|<id>)
	
	// TODO: rename to task-get-results.
	task-get-result =
		switch id
			case ?Result(taskID) : task-api-get-results(|taskID)
			otherwise            : task-api-get-results(|<id>)
		end
	
	task-has-failed =
		switch id
			case ?Result(taskID) : task-api-has-failed(|taskID)
			otherwise            : task-api-has-failed(|<id>)
		end
		
	task-get-solved =
		switch id
			case ?Result(taskID) : task-api-get-results(|taskID) <+ (task-api-has-failed(|taskID); ![])
			otherwise            : task-api-has-failed(|<id>) <+ (task-api-has-failed(|<id>); ![])
		end
				
	task-get-dependencies:
		taskID -> <task-api-get-dependencies(|taskID)>
				
	task-add-read(|taskID):
		read -> <task-api-add-read(|taskID, read)>
		
	task-add-dependency(|taskID):
		dependency -> <task-api-add-dependency(|taskID, dependency)>
		
	task-add-dependency-nocycle(|taskID):
		dependency -> <(not(task-becomes-cyclic(|taskID, dependency)); task-api-add-dependency(|taskID, dependency)) <+ id>
		
	task-instruction-id:
		instruction -> <task-api-task-id(|instruction)>
		
	task-perform-task(|nr) = perform-task(|nr)

rules /** @internal API externals */

	task-api-setup(|project-path) = prim(\"task_api_setup\", project-path)
	task-api-start-collection(|partition) = prim(\"task_api_start_collection\", partition)
	task-api-stop-collection(|partition) = prim(\"task_api_stop_collection\", partition)
	task-api-add-task(|partition, dependencies, instruction) = prim(\"task_api_add_task\", partition, dependencies, instruction)
	task-api-add-combinator(|partition, dependencies, instruction) = prim(\"task_api_add_combinator\", partition, dependencies, instruction)
	task-api-becomes-cyclic(|taskIDFrom, taskIDTo) = prim(\"task_api_becomes_cyclic\", taskIDFrom, taskIDTo)
	task-api-get-results(|taskID) = prim(\"task_api_get_results\", taskID)
	task-api-debug-info(|partition) = prim(\"task_api_debug_info\", partition)
	task-api-add-message(|taskID, message) = prim(\"task_api_add_message\", taskID, message)
	task-api-get-messages(|partition) = prim(\"task_api_get_messages\", partition)
	task-api-has-failed(|taskID) = prim(\"task_api_has_failed\", taskID)
	task-api-add-read(|taskID, read) = prim(\"task_api_add_read\", taskID, read)
	task-api-add-dependency(|taskID, dependency) = prim(\"task_api_add_dependency\", taskID, dependency)
	task-api-evaluate(collect-results, insert-results, perform-task|changed-reads) = prim(\"task_api_evaluate\", collect-results, insert-results, perform-task|changed-reads)
	task-api-exists(|instruction) = prim(\"task_api_exists\", instruction)
	task-api-get-dependencies(|taskID) = prim(\"task_api_get_dependencies\", taskID)
	task-api-reset = prim(\"task_api_reset\")
	task-api-persist = prim(\"task_api_persist\")
	task-api-task-id(|instruction) = prim(\"task_api_task_id\", instruction)
	task-api-unload(|project-path) = prim(\"task_api_unload\", project-path)

"

	create-task-debug = 
		<output-text-file(|["lib", "runtime", "task"], "debug.str")>
"module runtime/task/debug

imports
	
	runtime/task/core

rules
	
	task-transitive-dependencies = task-transitive-dependencies(|[])
	
	task-transitive-dependencies(|seen):
		taskID -> [dep*, trans-dep*]
		where
			not(<elem> (taskID, seen));
			dep*       := <task-get-dependencies> taskID;
			trans-dep* := <mapconcat(task-transitive-dependencies(|[taskID|seen]))> dep*
			
	task-transitive-dependencies(|seen):
		taskID -> []
		where
			<elem> (taskID, seen)
			
rules
	
	task-debug-ast:
		ast -> debug*
		with
			resultID* := <task-collect-result-ids> ast;
			dep*      := <mapconcat(task-transitive-dependencies)> resultID*;
			debug*    := <make-set; map(task-debug-info(|<id>))> [resultID*, dep*]

"

	create-task-interface = 
		<output-text-file(|["lib", "runtime", "task"], "interface.str")>
"module runtime/task/interface

strategies
  
  perform-task(|nr)  = fail
  task-match         = fail
  avoid-task(|dep*)  = fail
  task-is-combinator = fail
"

	create-task-messages = 
		<output-text-file(|["lib", "runtime", "task"], "messages.str")>
"module runtime/task/messages

imports
	
	runtime/task/core
	runtime/task/tasks
	runtime/editor/origins
	
signature

	sorts
	
		Message
		
	constructors
		
    Error   : Origin * Term -> Message
    Warning : Origin * Term -> Message
    Note    : Origin * Term -> Message
    
strategies
	
	task-error-message(|message):
		term -> Error(<origin-location>, message)
		
	task-warning-message(|message):
    term -> Warning(<origin-location>, message)
    
	task-note-message(|message):
    term -> Note(<origin-location>, message)
    
	task-message:
		Error(_, message) -> message

	task-message:
		Warning(_, message) -> message
		
	task-message:
		Note(_, message) -> message
	
	task-create-message-on-failure(|partition, task):
    message -> <new-task(|partition)> Message(task, Failure(), message)
  
  task-create-error-on-failure(|partition, task, message):
		term -> <new-task(|partition)> Message(task, Failure(), <origin-track-forced(task-error-message(|message))> term)
		
	task-create-warning-on-failure(|partition, task, message):
		term -> <new-task(|partition)> Message(task, Failure(), <origin-track-forced(task-warning-message(|message))> term)
		
	task-create-note-on-failure(|partition, task, message):
		term -> <new-task(|partition)> Message(task, Failure(), <origin-track-forced(task-note-message(|message))> term)
			
	task-create-message-on-failure(|partition, task):
    message -> <new-task(|partition)> Message(task, Success(), message)
  
  task-create-error-on-success(|partition, task, message):
		term -> <new-task(|partition)> Message(task, Success(), <origin-track-forced(task-error-message(|message))> term)
		
	task-create-warning-on-success(|partition, task, message):
		term -> <new-task(|partition)> Message(task, Success(), <origin-track-forced(task-warning-message(|message))> term)
		
	task-create-note-on-success(|partition, task, message):
		term -> <new-task(|partition)> Message(task, Success(), <origin-track-forced(task-note-message(|message))> term)
		
"

	create-task-tasks = 
		<output-text-file(|["lib", "runtime", "task"], "tasks.str")>
"module runtime/task/tasks

imports
	
	runtime/task/core
	runtime/task/interface
  runtime/nbl/utils
  
signature

	constructors
		
    Choice  : List(Result)                         -> Instruction
    Message : List(Result) * MessageTrigger * Term -> Instruction
    Match   : ID * List(Term) * Term               -> Instruction
    Rewrite : ID * Term                            -> Instruction
    Concat  : List(Result)                         -> Instruction
    
    Success : MessageTrigger
    Failure : MessageTrigger
	
rules
	
	avoid-task(|dep*):
	  Choice([choice]) -> choice
	  where
	    <dependent-tasks> choice => dep*
	
	avoid-task(|dep*):
    Choice(choice*) -> <concat> choice*
    where
      [] := <dependent-tasks> choice*
      
	perform-task(|nr):
 		Choice(choice*) -> <Hd> choice*
 		
	task-is-combinator = ?Choice(_)

	// TODO: can we still use <Hd> to determine if a task failed or not?
	// TODO: should not store any result.
  perform-task(|n):
    Message(task, trigger, message) -> []
    where
    	switch !trigger
    		case Success() : <Hd> task; task-add-message(|n, message)
    		case Failure() : not(<Hd> task); task-add-message(|n, message)
    	end

	task-is-combinator = ?Message(_, _, _)

  avoid-task(|dep*):
    Match(_, _, _) -> <perform-task(|0) <+ ![]>
    where
      [] := dep*
    	
  perform-task(|nr): 
  	Match(key, bound, term) -> <task-match> (key, term, bound)
  
  perform-task(|nr): 
    Rewrite(key, term) -> <task-match> (key, term)
  
  // TODO: this should no longer be needed with single-result tasks?
  perform-task(|nr):
  	Concat(term*) -> <concat> term*

	task-is-combinator = ?Concat(_)
"

	create-task-utils = 
		<output-text-file(|["lib", "runtime", "task"], "utils.str")>
"module runtime/task/utils

rules
	
  crush-annos(nul, sum, s) :
    _#(xs){a*} -> r2
    where
     r1 := <foldr(nul, sum, s)> xs;
     r2 := <foldr(!r1, sum, s)> a*

	collect-all-annos(s, un) =
		![<s> | <crush-annos(![], un, collect-all-annos(s, un))>]
	<+ crush-annos(![], un, collect-all-annos(s, un))

"

	create-tmpl-pp = 
		<output-text-file(|["lib", "runtime", "tmpl"], "pp.str")>
"module runtime/tmpl/pp

imports
  libstratego-lib
  libstratego-gpp

signature constructors

  Parenthetical : Unknown -> Unknown

strategies

  // Unwrap Parenthetical/1 if pp fails, in case the user is using
  // parenthesize, but grammar does not contain {bracket} production.
  pp-one(pp) = (pp <+ ?Parenthetical(<pp>)); filter(gpp-is-real-vbox)

  pp-one-V(pp) = pp-one(pp); (?[] <+ !V([], <id>))
  pp-one-Z(pp) = pp-one(pp); (?[] <+ !Z([], <id>))

  pp-option(pp) = \\None() -> []\\ + ?Some(<pp>)

  pp-V-list(pp)    = ?[] <+ !V([], <map(pp-one-V(pp))>)
  pp-V-list(pp|vs) = ?[] <+ !V([SOpt(VS(), vs)], <map(pp-one-V(pp))>)

  pp-indent(|is) = filter(gpp-is-real-vbox); (?[] <+ !I([SOpt(IS(), is)], H([SOpt(HS(), \"0\")], <id>)))

  pp-H-list(pp)     = ?[] <+ !H([], <map(pp-one-Z(pp))>)
  pp-H-list(pp|sep) = ?[] <+ !H([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

  pp-HV-list(pp)     = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
  pp-HV-list(pp|sep) = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

  pp-HZ-list(pp)     = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
  pp-HZ-list(pp|sep) = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)
"

	create-types-collect = 
		<output-text-file(|["lib", "runtime", "types"], "collect.str")>
"module runtime/types/collect

imports 
	
  runtime/task/core
  runtime/task/messages
  runtime/task/tasks
  runtime/types/interface
  runtime/types/tasks
  runtime/nbl/collect
  runtime/nbl/utils
  runtime/editor/origins
  
strategies
  
  annotate-property-tasks(|task*) =
    !([Type()|<custom-properties <+ ![]>], <id>)
  ; foldl(annotate-property-task(|task*) <+ Snd)
  
  annotate-property-task(|task*):
    (kind, term{a*}) -> term{(kind, prop), a*}
    where
      not(<property-task(|kind)> term)
    where
      prop := <new-property-task(|task*)> 
     
  new-property-task(|task*):
    (Type(), term) -> <type-of(|task*)> term

  property-task(|kind, task*) = 
     property-task(|kind)
  <+ <new-property-task(|task*)> (kind, <id>)
 
  property-task(|kind) = 
    get-annos
  ; fetch-elem(?(kind, task))
  ; !task
 
  property-of(|kind) = property-task(|kind); insert-results; try-remove-list
    
strategies
  
  prop-calc(|task*, dep*) = 
    where(all-dep* := <union> (<dependent-tasks>, <dependent-tasks> dep*));
    <new-task(|task*, all-dep*)> PropCalc(<id>)
    
  prop-check(|kind, task*, dep*):
    (term, expected) -> task
    where
      actual    := <property-task(|kind)> term
    ; expected* := <try-make-list> expected
    ; check*    := <map(<new-task(|task*)> PropCheck(actual, <id>))> expected*
    ; task      := <new-task(|task*, <dependent-tasks> [dep*, check*])> Choice(check*)
  
  prop-check(|kind, task*, dep*):
    (term, expected, msg) -> task
    where
      task := <prop-check(|kind, task*, dep*)> (term, expected)
    ; <origin-track-forced(task-create-error-on-failure(|task*, task, msg))> term
  
  prop-lookup(|kind, task*, dep*) = 
    where(all-dep* := <union> (<dependent-tasks> dep*, <dependent-tasks>))
  ; <new-task(|task*, all-dep*)> PropLookup(kind, <id>) 
  
  prop-match(|task*, relation) = 
    <new-task(|task*)> Rewrite(relation, <id>)
    
  prop-match(|task*, relation, dep*) = 
    where(all-dep* := <union> (<dependent-tasks> dep*, <dependent-tasks>))
  ; <new-task(|task*)> Rewrite(relation, <id>)
  
strategies
  
  type-is(|task*)           = prop-calc(|task*, [])
  type-is(|task*, dep*)     = prop-calc(|task*, dep*)
  
  type-check(|task*)        = prop-check(|Type(), task*, [])
  type-check(|task*, dep*)  = prop-check(|Type(), task*, dep*)
  
  type-lookup(|task*)       = prop-lookup(|Type(), task*, [])
  type-lookup(|task*, dep*) = prop-lookup(|Type(), task*, dep*)
  
  type-match(|task*, relation) = prop-match(|task*, relation)

  type-of = property-of(|Type())
  
"

	create-types-interface = 
		<output-text-file(|["lib", "runtime", "types"], "interface.str")>
"module runtime/types/interface

strategies
  
  custom-properties = fail
  
  new-property-task(|task*): (kind, term) -> <fail>

  type-of(|task*) = fail

  type-prop-eq = eq

"

	create-types-tasks = 
		<output-text-file(|["lib", "runtime", "types"], "tasks.str")>
"module runtime/types/tasks

imports 
	
	runtime/nbl/resolve
	runtime/nbl/collect
	runtime/nbl/entries
	runtime/nbl/query
	runtime/nbl/utils
	runtime/nbl/uri
	runtime/nbl/tasks
  runtime/types/interface
  runtime/task/core
  
signature
  
  constructors

    PropLookup : Property * Term -> Instruction    
    PropCalc   : Term * Term     -> Instruction
    PropCalc   : Term            -> Instruction
    PropCheck  : Term * Term     -> Instruction

rules
  
  perform-task(|n): 
  	PropLookup(kind, t) -> result
  	where
  		resolved := <nabl-collect-one-resolved-def> t;
  		switch id
  			case ?Def(_) : where(nabl-uri; nabl-add-read(|n)); nabl-get-property(|kind); insert-results-or-create-dependency // TODO: is this read needed?
  			otherwise    : id
  		end => result
  
  avoid-task(|dep*):
    PropCalc(_) -> <perform-task(|0)> 
    where
      [] := dep*
  	
  perform-task(|n): 
  	PropCalc(result) -> result
  
  avoid-task(|dep*):
    PropCheck(actual, expected) -> <perform-task(|0) <+ ![]> 
    where
      [] := dep*
  	
  perform-task(|n): 
  	PropCheck(actual, expected) -> actual
  	where
  		<type-prop-eq> (actual, expected)

"

create-all-runtime-libraries = 
	create-analysis-complete
; 	create-analysis-core
; 	create-analysis-debug
; 	create-analysis-defaults
; 	create-analysis-multiple
; 	create-analysis-resolve
; 	create-analysis-single
; 	create-editor-editor
; 	create-editor-origins
; 	create-editor-positions
; 	create-editor-queue
; 	create-index-core
; 	create-index-globals
; 	create-index-partition
; 	create-index-query
; 	create-nbl-check
; 	create-nbl-collect
; 	create-nbl-complete
; 	create-nbl-entries
; 	create-nbl-interface
; 	create-nbl-lookup
; 	create-nbl-query
; 	create-nbl-resolve
; 	create-nbl-tasks
; 	create-nbl-uri
; 	create-nbl-utils
; 	create-task-core
; 	create-task-debug
; 	create-task-interface
; 	create-task-messages
; 	create-task-tasks
; 	create-task-utils
; 	create-tmpl-pp
; 	create-types-collect
; 	create-types-interface
; 	create-types-tasks
