module sdf2imp/project/create-runtime-libraries

imports
  sdf2imp/util/-

strategies
  
  remove-runtime-libraries =
  	<rmdir> "lib/runtime"
  
  create-nabl-lookup = 
    <output-text-file(|["lib", "runtime", "nabl"], "lookup.str")>
"module runtime/nabl/lookup

imports
  
  runtime/nabl/query
  runtime/nabl/uri
  runtime/nabl/collect
  runtime/properties/query
  runtime/task/core

rules // Lookup
  
  nabl-lookup(|ns, name):
    uri -> def*
    with
      uri' := <nabl-extend-uri(|ns, name, NonUnique())> uri;
      def* := <nabl-get-all-definitions> uri'

  nabl-lookup-all(|ns):
    uri -> def*
    with
      def*  := <nabl-get-child-definitions(|ns)> uri

  nabl-lookup-named-import(|ns, name):
    uri -> import*
    with
      language := <nabl-uri-language> uri;
      import*  := <nabl-get-import-uris-named(|language, ns, name)> uri

rules // Imports

  nabl-get-import-uris-named(|language, namespace, name):
    uri -> importURI*
    with
      importResult* := <get-index-properties(|Import(language, namespace, name))> uri; // TODO: this now uses aliasses?
      importURI*    := <map(task-get-solved <+ task-create-dependencies; ![<id>]); concat> importResult*

"

  create-nabl-query = 
    <output-text-file(|["lib", "runtime", "nabl"], "query.str")>
"module runtime/nabl/query

imports
  
  runtime/nabl/uri
  runtime/nabl/entries
  runtime/index/query
  runtime/task/core
  
rules // Specific queries

  /**
   * Gets all unique and non-unique definition entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-definitions> [Entity(), \"M\", \"Bar\"] => [Def([Entity(), \"M\", \"Bar\"]), ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Def(uri))
   */
  nabl-get-all-definitions:
    contains-uri* -> <mapconcat(nabl-get-unique-nonunique(!Def(<id>)))> uri*
    where
      uri* := <nabl-uris> contains-uri*
      
  /**
   * Gets all child definition entries in given URI that match given namespace.
   *
   * Example:
   *   <nabl-get-child-definitions> [Entity(), \"M\", \"Bar\"] => [Def([Field(), \"a\", \"M\", \"Bar\"]), ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Def(uri))
   */
  nabl-get-child-definitions(|ns):
    contains-uri* -> [def*, alias-def*]
    where
      uri*       := <nabl-uris> contains-uri*;
      def*       := <mapconcat(!Def(<id>); nabl-get-children(|ns)); mapconcat(nabl-uri; nabl-get-unique-nonunique(!Def(<id>)))> uri*;
      alias-def* := <mapconcat(!Alias(<id>, ()); nabl-get-children(|ns)); mapconcat(nabl-value; !Def(<id>); nabl-get-all-definitions)> uri*

  /**
   * Gets all Use entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-uses> Def([Entity(), \"M\", \"Bar\"]) => [Use([Entity(), \"M\", \"Bar\"]), ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Use(uri))
   */
  nabl-get-all-uses:
    containsURI -> <nabl-get-all> Use(uri)
    where
      uri := <nabl-uri> containsURI

  /**
   * Gets all Alias entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-aliases> Def([Entity(), \"M\", \"Bar\"]) => [[Entity(), \"M\", \"Baz\"], ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(aliasURI)
   */
  nabl-get-all-aliases:
    contains-uri* -> alias-uri*
    where
      uri*           := <nabl-uris> contains-uri*;
      nonunique-uri* := <filter(nabl-replace-uri-qualifier(|NonUnique()))> uri*;
      alias-uri*     := <mapconcat(!Alias(<id>, ()); nabl-get-all-values)> nonunique-uri*
      
  /**
   * Gets all InverseAlias entries that match the given URI.
   *
   * Example:
   *   <nabl-get-all-aliases> Def([Entity(), \"M\", \"Bar\"]) => [[Entity(), \"M\", \"Baz\"], ...]
   *
   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(inverseAliasURI)
   */
  nabl-get-all-inverse-aliasses:
    contains-uri* -> inverse-alias*
    where
      uri*           := <nabl-uris> contains-uri*;
      inverse-alias* := <mapconcat(!InverseAlias(<id>, ()); nabl-get-all-values)> uri*

rules // Generic queries
  
  nabl-get-all:
    template -> <index-get-all> template
       
  nabl-get-all-values:
    template -> <nabl-get-all; map(nabl-value)> template

  nabl-get:
    template -> <nabl-get-all; Hd> template
     
  nabl-get-value:
    template -> <nabl-get-all; Hd; nabl-value> template
  
  nabl-get-children:
    template -> entries
      with
        entries  := <index-get-children> template

  nabl-get-children(|namespace):
    template -> entries
      with
        children := <index-get-children> template;
        entries  := <nabl-filter-entries(|namespace)> children
        
  nabl-get-children(|namespace, prefix):
    template -> entries
      with
        children := <index-get-children> template;
        entries  := <nabl-filter-entries(|namespace, prefix)> children

  nabl-get-unique-nonunique(create-template):
    uri -> [unique*, non-unique*]
    where
      if alias* := <nabl-get-all-aliases> uri then
        // HACK: handle Result terms on the resulting URI of an alias. this should be decomposed into a task?
        (alias-result*, alias-uri*) := <partition(?Result(_); insert-results-or-create-dependency)> alias*;
        if deps := <task-collect-dependencies> alias-result* then
          unique* := [deps]
        else
          unique-uri*    := <mapconcat(create-template; nabl-get-all)> alias-uri*;
          unique-result* := <try(concat)> alias-result*;
          unique*        := [unique-uri*, unique-result*]
        end
      else
        unique* := []
      end;
      if non-unique-uri := <nabl-replace-uri-qualifier(|NonUnique())> uri then
        non-unique* := <create-template; nabl-get-all> non-unique-uri
      else
        non-unique* := []
      end

rules /** @internal Entry filtering */
  
  /** @internal */
  nabl-filter-entries(|namespace, prefix):
    entry* -> <filter(nabl-compare-prefix(|namespace, prefix))> entry*
  
  /** @internal */
  nabl-filter-entries(|namespace):
    entry* -> <filter(nabl-compare-namespace(|namespace))> entry*

rules /** @internal Helpers */
  
  /** @internal */
  nabl-compare-prefix(|namespace, prefix):
    entry -> <id>
    where
      uri := <nabl-uri> entry;
      <eq> (namespace, <nabl-uri-namespace> uri);
      <is-substring(!prefix)> <nabl-uri-name> uri
      
  /** @internal */
  nabl-compare-namespace(|namespace):
    entry -> <id>
    where
      uri := <nabl-uri> entry;
      <eq> (namespace, <nabl-uri-namespace> uri)

"

  create-nabl-uri = 
    <output-text-file(|["lib", "runtime", "nabl"], "uri.str")>
"module runtime/nabl/uri

imports
  
  runtime/nabl/interface
  runtime/index/core
  runtime/editor/annotations
  
signature

  sorts
  
    Language
    Segment
    Qualifier
    
  constructors
    
    Language    : String                       -> Language
    ID          : Namespace * Name * Qualifier -> Segment
    Subsequent  : String                       -> Segment
    Anonymous   : String                       -> Segment
    Unique      : String                       -> Qualifier
    NonUnique   :                                 Qualifier
    Unique      :                                 Qualifier
    URI         : Language * List(Segment)     -> URI
    Barrier     : List(Namespace)              -> Annotation
    
rules // Construction
  
  nabl-base-uri = 
    !URI(<id>, [])
     
  nabl-extend-uri(|segment) = 
    URI(id, ![segment|<id>])
    
  nabl-extend-uri(|namespace, name, qualifier) = 
    URI(id, ![ID(namespace, name, qualifier)|<id>])
    
  nabl-replace-uri(|segment) = 
    URI(id, [!segment|id])
    
  nabl-replace-uri(|namespace, name, qualifier) = 
    URI(id, [!ID(namespace, name, qualifier)|id])
    
  nabl-replace-uri-qualifier(|qualifier) =
    URI(id, [ID(id, id, !qualifier)|id])
      
  nabl-nonunique-uri =
    URI(id, [ID(id, id, !NonUnique())|id])
    
  nabl-uri-add-barriers(|namespace*):
    URI(lang, [seg|s]) -> URI(lang, [<replace-annotation(?Barrier(_)|new-barrier)> seg|s])
    where
      existing-namespace* := <get-annotation(?Barrier(<id>)) <+ ![]> seg;
      new-barrier         := Barrier([existing-namespace*, namespace*])
      
  nabl-uri-strip-barriers = 
    URI(id, map(remove-annotations(?Barrier(_))))
    
rules // Stable URI extensions
  
  nabl-extend-uri(|table, partition, ns, n, u):
    uri -> <nabl-extend-uri(|ns, n, qualifier)> uri
    where 
      if where(<?NonUnique()> u) then
        qualifier := NonUnique()
      else
        qualifier := Unique(<stable-uri-part(|table, partition)> (partition, uri, ns, n))
      end
    
  nabl-extend-uri-anonymous(|table, partition):
    uri -> <nabl-extend-uri(|Anonymous(unique))> uri
    where
      unique := <stable-uri-part(|table, partition)> (partition, uri, \"anonymous\")
      
  nabl-extend-uri-subsequent(|table, partition):
    uri -> <nabl-extend-uri(|Subsequent(unique))> uri
    where
      unique := <stable-uri-part(|table, partition)> (partition, uri, \"subsequent\")

  stable-uri-part(|table, partition):
    key -> $[[partition]/[unique]]
    where
      if value := <hashtable-get(|key)> table then
        unique    := <int-to-string> value;
        new-value := <inc> value
      else
        unique    := \"0\";
        new-value := 1
      end;
      <hashtable-put(|key, new-value)> table
      
rules // Projections
  
  nabl-uri = fail
  nabl-uris = fail
  nabl-value = fail
  nabl-values = fail
  
  nabl-uri-language:
    URI(language, _) -> language
    
  nabl-uri-language-name:
    URI(Language(name), _) -> name
    
  nabl-uri-path:
    URI(_, path) -> path
    
  nabl-uri-parent:
    URI(language, path) -> URI(language, parent)
    where
      [_|parent] := path
  
  nabl-uri-parents:
    uri -> parent*
    where
      if parent := <nabl-uri-parent> uri then
        parent* := [parent|<nabl-uri-parents> parent]
      else
        parent* := [] 
      end
      
  nabl-uri-parents(|target-ns):
    uri -> parent*
    where
      barrier-ns* := <nabl-uri-barriers <+ ![]> uri;
      if <not(elem)> (target-ns, barrier-ns*); parent := <nabl-uri-parent> uri then
        // Strip barriers from parent because URI's in the index also do not have barriers (matching would fail).
        parent* := [<nabl-uri-strip-barriers> parent|<nabl-uri-parents(|target-ns)> parent]
      else
        parent* := [] 
      end
        
  nabl-uri-name:
    uri -> <nabl-uri-path; Hd; nabl-segment-name> uri
    
  nabl-uri-namespace:
    uri -> <nabl-uri-path; Hd; nabl-segment-namespace> uri    

  nabl-uri-qualifier:
    uri -> <nabl-uri-path; Hd; nabl-segment-qualifier> uri
    
  nabl-uri-barriers:
    uri -> <nabl-uri-path; Hd; nabl-segment-barriers> uri
      
  nabl-segment-namespace:
    ID(namespace, _, _) -> namespace
    
  nabl-segment-name:
    ID(_, name, _) -> name
    
  nabl-segment-name:
    Subsequent(name) -> name
  
  nabl-segment-name:
    Anonymous(name) -> name
    
  nabl-segment-qualifier:
    ID(_, _, qualifier) -> qualifier
    
  nabl-segment-barriers:
    segment -> namespace*
    where
      Barrier(namespace*) := <get-annotation(?Barrier(_))> segment 
    
  nabl-uri-scope      = URI(id, Tl)
  nabl-uri-scopes    = nabl-closure(nabl-uri-scope)
  
  nabl-uri-in-scope  = URI(id, [id|Tl])
  nabl-uri-in-scopes = nabl-closure(nabl-uri-in-scope)
  
  nabl-closure(s) = 
      s 
    < ![<id>|<nabl-closure(s)>] 
    + ![]

rules // Conditions
  
  nabl-is-uri =
    ?URI(_, _)
  
  nabl-is-unique =
    nabl-uri-qualifier;
    ?Unique(_)
    
  nabl-is-nonunique =
    nabl-uri-qualifier;
    ?NonUnique()
    
  nabl-segment-is-id =
    ?ID(_, _, _)

rules // Equality
  
  nabl-uri-eq = 
    ?(URI(lang1, segs1), URI(lang2, segs2));
    <eq> (lang1, lang2);
    <zip(nabl-uri-segment-eq)> (segs1, segs2)
    
  nabl-uri-segment-eq =
    ?(ID(ns1, name1, _), ID(ns2, name2, _));
    <eq> (ns1, ns2);
    <eq> (name1, name2)
     
  nabl-uri-segment-eq =
    ?(Subsequent(_), Subsequent(_))
    
  nabl-uri-segment-eq =
    ?(Anonymous(_), Anonymous(_))
    
rules // Printing
  
  nabl-print-uri:
    uri -> $[[ns] [names]]
    where
      ns#(_) := <nabl-uri-namespace> uri;
      names  := <nabl-uri-path; filter(nabl-segment-name); separate-by(|\".\"); concat-strings> uri
        
rules /** @internal Projections */

  /** @internal */
  nabl-uri:
    URI(_, _) -> <id>
    
  /** @internal */
  nabl-value:
    URI(_, _) -> <id>
 
  /** @internal */
  nabl-uris:
    URI(_, _) -> [<id>]
    
  /** @internal */
  nabl-values:
    URI(_, _) -> [<id>]

    
  /** @internal */  
  nabl-uri =
    has-annos;
    get-annos;
    fetch-elem(nabl-uri)

  /** @internal */  
  nabl-value =
    has-annos;
    get-annos;
    fetch-elem(nabl-value)

  /** @internal */  
  nabl-uris =
    has-annos;
    get-annos;
    filter(nabl-uri)

  /** @internal */  
  nabl-values =
    has-annos;
    get-annos;
    filter(nabl-value)

"

  create-nabl-constraints = 
    <output-text-file(|["lib", "runtime", "nabl"], "constraints.str")>
"module runtime/nabl/constraints

imports
  runtime/nabl/uri
  runtime/nabl/collect
  runtime/nabl/entries
  runtime/nabl/tasks
  runtime/task/core
  runtime/task/tasks
  runtime/properties/tasks
  
rules
  
  nabl-lookup-local(|ctx) =
    nabl-uri
  ; nabl-lookup-local(|ctx, <nabl-uri-namespace>, <nabl-uri-name>)
    
  nabl-lookup-local(|ctx, ns) =
    nabl-uri
  ; nabl-lookup-local(|ctx, ns, <nabl-uri-name>)
  
  nabl-lookup-local(|ctx, ns, name) =
    nabl-uri-parent
  ; <new-task(|ctx)> ResolveDefs(<id>, ns, name, [])

rules
  
  nabl-lookup-lexical(|ctx) =
    nabl-uri
  ; nabl-lookup-lexical(|ctx, <nabl-uri-namespace>, <nabl-uri-name>)
    
  nabl-lookup-lexical(|ctx, ns) =
    nabl-uri
  ; nabl-lookup-lexical(|ctx, ns, <nabl-uri-name>)
  
  nabl-lookup-lexical(|ctx, ns, name) =
    nabl-uri-parents
  ; map(<new-task(|ctx)> ResolveDefs(<id>, ns, name, []))
  ; <new-task(|ctx)> Choice(<id>)
  
  nabl-lookup-lexical-parent(|ctx) =
    nabl-uri
  ; nabl-lookup-lexical-parent(|ctx, <nabl-uri-namespace>, <nabl-uri-name>)
    
  nabl-lookup-lexical-parent(|ctx, ns) =
    nabl-uri
  ; nabl-lookup-lexical-parent(|ctx, ns, <nabl-uri-name>)
  
  nabl-lookup-lexical-parent(|ctx, ns, name) =
    nabl-uri-parent
  ; nabl-lookup-lexical(|ctx, ns, name)
    
rules
  
  nabl-lookup-local-import(|ctx) =
    nabl-uri
  ; nabl-lookup-local-import(|ctx, <nabl-uri-namespace>, <nabl-uri-name>)
  
  nabl-lookup-local-import(|ctx, ns) =
    nabl-uri
  ; nabl-lookup-local-import(|ctx, ns, <nabl-uri-name>)
  
  nabl-lookup-local-import(|ctx, ns, name) =
    nabl-uri-parent
  ; <new-task(|ctx)> PropsLookup(Import(ns), Def(<id>))
  ; <new-task(|ctx)> ResolveDefs(<id>, ns, name, [])
  
rules
  
  nabl-lookup-lexical-import(|ctx) =
    nabl-uri
  ; nabl-lookup-lexical-import(|ctx, <nabl-uri-namespace>, <nabl-uri-name>)
  
  nabl-lookup-lexical-import(|ctx, ns) =
    nabl-uri
  ; nabl-lookup-lexical-import(|ctx, ns, <nabl-uri-name>)
  
  nabl-lookup-lexical-import(|ctx, ns, name) =
    nabl-uri-parents
  ; map(
      <new-task(|ctx)> PropsLookup(Import(ns), Def(<id>))
    ; <new-task(|ctx)> ResolveDefs(<id>, ns, name, [])
    )
  ; <new-task(|ctx)> Choice(<id>)
    
"

  create-nabl-incremental = 
    <output-text-file(|["lib", "runtime", "nabl"], "incremental.str")>
"module nbl/incremental

imports
  
  runtime/nabl/uri
  runtime/nabl/interface
  runtime/task/core
  
rules // Read generation
  
  nabl-add-uri-read(|taskID):
    uri -> uri
    with
      <try(nabl-replace-uri-qualifier(|())); task-add-read(|taskID)> uri
      
  nabl-add-ns-read(|taskID, ns):
    uri -> uri
    with
      <task-add-read(|taskID)> (uri, ns)
      
  nabl-add-name-read(|taskID, ns, name):
    uri -> uri
    with
      <nabl-extend-uri(|ns, name, ()); task-add-read(|taskID)> uri
      
rules // Read processing
  
  nabl-get-changed-reads:
    changed-entry* -> [uri-read*, ns-read*]
    with
      uri*      := <filter(nabl-diff-entry; nabl-uri)> changed-entry*;
      uri-read* := <map(try(nabl-replace-uri-qualifier(|())))> uri*;
      ns-read*  := <filter(nabl-create-ns-read)> uri*
  
  nabl-create-ns-read:
    uri -> (uri', ns)
    where
      ns   := <nabl-uri-namespace> uri;
      uri' := <nabl-uri-parent> uri

"

  create-nabl-namegen = 
    <output-text-file(|["lib", "runtime", "nabl"], "namegen.str")>
"module nbl/namegen

imports
  
  runtime/nabl/collect
  runtime/nabl/query
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/nabl/interface
  runtime/editor/origins
  runtime/editor/annotations
  runtime/index/core
  runtime/index/query
  
signature

  constructors
    
    GenerateName : Namespace -> GenerateName
    GenerateNum  : URI * Int -> Entry
  
rules
  
  nabl-namegen-stem(|ns) = add-annotation(|GenerateName(ns))

rules // Name generation
  
  nabl-namegen(|lang, partition, unique*, uri*, anno*):
    name -> <origin-track-forced(!newname{anno'*})> name
    where
      <get-annotation(?GenerateName(ns))> name;
      uri      := <lookup-uri(|lang, ns)> uri*;
      newname  := <nabl-namegen-get(|lang, partition, ns, uri, unique*)> name;
      anno'*   := <remove-all(?GenerateName(_))> anno*
  
  nabl-namegen-get(|lang, partition, ns, uri, unique*):
    name -> result
    with
      name-key := (name, \"namegen\");
      if full-newname := <hashtable-get(|name-key)> unique* then
        result := full-newname
      else
        nextnum := <nabl-namegen-get-num(|uri) <+ !0>;
        numstr  := <int-to-string> nextnum;
        newname := <nabl-namegen-name-create(|lang, partition, uri, ns)> numstr;
        result  := $[[newname][numstr]];
        <hashtable-put(|name-key, result)> unique*;
        <inc; nabl-namegen-store-num(|partition, uri)> nextnum
      end

rules // Name generation strategies
      
  nabl-namegen-name-create(|lang, partition, uri, ns) = 
    nabl-namegen-name(|lang, partition, uri, ns) <+ nabl-namegen-name-generic(|lang, partition, uri, ns)
      
  nabl-namegen-name-generic(|lang, partition, uri, ns):
    name -> <nabl-namegen-name-generic-fix> 
      $[[<nabl-namegen-name-generic-str> lang-name][<nabl-namegen-name-generic-str> partition][ns-name][uri-name][name]]
    with
      Language(lang-name) := lang;
      ns-name             := <get-constructor; nabl-namegen-name-generic-str> ns;
      uri-name            := <nabl-uri-path; filter(nabl-segment-name; nabl-namegen-name-generic-str); concat-strings> uri
  
  nabl-namegen-name-generic-str = 
    explode-string; reverse; (take(|3) <+ take(|2) <+ take(|1) <+ ![]); reverse; implode-string
      
  nabl-namegen-name-generic-fix = 
    lower-case; string-replace(|\"/\", \"_\"); string-replace(|\"-\", \"_\"); string-replace(|\".\", \"_\")

rules // Storage & retrieval
  
  nabl-namegen-get-num(|uri)              = <nabl-get-all-values; !(<id>, 0); foldl(max)> GenerateNum(uri, ())
  nabl-namegen-store-num(|partition, uri) = <index-add(|<nabl-namegen-partition(|partition)>)> GenerateNum(uri, <id>)
  nabl-namegen-clear(|partition)          = nabl-namegen-partition(|partition); index-clear-partition
  nabl-namegen-partition(|partition)      = !$[[partition]_namegen]
  nabl-uri                                : GenerateNum(uri, _) -> uri
  nabl-value                              : GenerateNum(_, num) -> num
  
"

  create-nabl-check = 
    <output-text-file(|["lib", "runtime", "nabl"], "check.str")>
"module runtime/nabl/check

imports
  
  runtime/nabl/resolve
  runtime/nabl/collect
  runtime/nabl/query
  runtime/nabl/tasks
  runtime/nabl/entries
  runtime/nabl/interface
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/task/core
  runtime/task/messages
  runtime/task/tasks
  
rules // Error checking tasks
  
  nabl-unresolved-task(|partition, task):
    name -> name
    where
      not(nabl-check-disable-unresolved)
    with
      <nabl-fix-name; task-create-error-on-failure(|partition, task, \"Unresolved reference\")> name
      
  nabl-duplicate-task(|partition, unique):
    name -> name
    where
      uri := <nabl-uri> name;
      ns  := <nabl-uri-namespace> uri;
      not(<nabl-check-disable-duplicate(|uri, ns)> name)
    with
      if Unique() := unique then
        uri'    := <nabl-uri-parent> uri;
        resolve := <new-task(|partition)> ResolveDefs(uri', ns, name, []);
        <task-create-error-on-multiple(|partition, resolve, \"Duplicate definition\")> name
      end
      
  // TODO: check needs to be converted into a task.
  nabl-hiding-task(|partition):
    name -> name
    where
      uri := <nabl-uri> name;
      ns  := <nabl-uri-namespace> uri;
      not(<nabl-check-disable-hiding(|uri, ns)> name)
    where
      if inverse-alias* := <nabl-get-all-inverse-aliasses> uri then
        uri* := <map(nabl-uri-parent; nabl-uri-parent)> inverse-alias*
      else
        uri* := <nabl-uri-parent; nabl-uri-parent; ![<id>]> uri
      end;
      task* := <map(nabl-use-subtask(|partition, ns, <nabl-fix-name> name, [], All()))> uri*;
      task  := <new-task(|partition)> Choice(task*);
      <task-create-error-on-success(|partition, task, \"Declaration hides previous definition\")> name

  nabl-constraint(|partition) = 
    nabl-hiding-task(|partition)

rules // Legacy
 
  nabl-is-unresolved =
    ?node;
    has-annos;
    get-annos;
    where(nabl-has-reference);
    not(nabl-collect-one-resolved-def)
  
  nabl-get-ambiguities =
    nabl-collect-all-resolved-defs;
    mapconcat(nabl-get-all-aliases);
    filter(nabl-uri; nabl-uri-parent);
    make-set;
    where(<gt> (<length>, 1))
  
  nabl-get-duplicate-definitions =
    has-annos;
    get-annos;
    collect-one(?Def(_));
    nabl-get-all-definitions;
    make-set;
    where(<gt> (<length>, 1))

"

  create-nabl-utils = 
    <output-text-file(|["lib", "runtime", "nabl"], "utils.str")>
"module runtime/nabl/utils

imports
  
  libstratego-lib
  runtime/task/core
  runtime/editor/annotations

rules 
  
  match(m|val) = where (!val; m)
  
  vdebug(s) = where(verbose < debug(s) + id)
  verbose   = fail

  is-completion-name = ?\"completion123\"
  fix-completion-name = is-completion-name; !\"\"
  
  measure-time(s, log) =
    where(before := <times>);
    s;
    where(after := <times>; !(after, before); diff-times; times-to-seconds; Fst; log)
  
  measure-time(s, log | name) = 
    measure-time(s, record-time(|name); log)
  
  record-time(|name) = id
    
  try-make-list = is-list <+ ?Dependency(_) <+ ![<id>]
    
  try-remove-list = is-list < Hd + id
  
  // @deprecated use runtime/editor/annotations get-annotation(s)
  has-annotation(s) = get-annotation(s)
  
rules // multimap simulation
  
  hash-multimap-put(|key, value):
    hashtable -> hashtable
    where
      values := <hash-multimap-getorcreate(|key)> hashtable;
      <hashtable-put(|key, [value|values])> hashtable 
      
  hash-multimap-putlist(|key, put-value*):
    hashtable -> hashtable
    where
      value* := <hash-multimap-getorcreate(|key)> hashtable;
      <hashtable-put(|key, [value*, put-value*])> hashtable 
      
  hash-multimap-getorcreate(|key) =
    hashtable-get(|key) <+ hashtable-put(|key, []); ![]
  
  hash-multimap-copy(|from):
    to -> to
    where
      // wtf is this I don't even.. hashtable-fold needs term arguments instead of current term arguments.
      <hashtable-fold(hash-multimap-copy-fold|to)> from
      
  hash-multimap-copy-fold(|key, value*):
    to -> <hash-multimap-putlist(|key, value*)> to

"

  create-nabl-resolve = 
    <output-text-file(|["lib", "runtime", "nabl"], "resolve.str")>
"module runtime/nabl/resolve

imports
  
  runtime/nabl/tasks
  runtime/nabl/entries
  runtime/task/core
  runtime/task/utils
  
rules // Reference resolution
  
  nabl-is-reference =
    ?Use(_)
    
  nabl-has-reference =
    collect-one(nabl-is-reference)
    
  nabl-has-reference =
    has-annos;
    get-annos;
    nabl-has-reference
  
  nabl-collect-all-resolved-defs:
    ast -> def*
    with
      if ast' := <insert-results> ast then
        def* := <collect-all-annos(?Def(_), conc)> ast'
      else
        def* := []
      end

  nabl-collect-one-resolved-def =
    insert-results-or-create-dependency;
    collect-one-annos(?Def(_) <+ ?Dependency(_))
  
"

  create-nabl-interface = 
    <output-text-file(|["lib", "runtime", "nabl"], "interface.str")>
"module runtime/nabl/interface

strategies // Collect
  
  nabl-scoping-site = fail
  
  nabl-def-site(
    child-uris, sibiling-uris, implicits
  | lang, partition, unique*, uri*, state*
  ) = fail
  
  nabl-external-def-site(|partition) = fail

  nabl-state-site = fail
  
  nabl-use-site(|lang, partition, unique*, uri*, state*) = fail
  
  nabl-import-site(|lang, partition, unique*, uri*, state*) = fail
  
  nabl-prop-site(|lang, partition, uri*, state*, implicit*) = fail
  
strategies // Projections
  
  nabl-get-name = fail
  
  nabl-name-apply(s) = fail
  
strategies // Lookup hooks
    
  nabl-disambiguate(|prop*, namespace, name) = fail

strategies // Name generation
  
  nabl-namegen-name(|lang, partition, uri, ns) = fail
  
strategies // Default error checks
  
  nabl-check-disable-unresolved = fail
  
  nabl-check-disable-duplicate(|uri, ns) = fail
  
  nabl-check-disable-hiding(|uri, ns) = fail
  
strategies // Incrementality
  
  nabl-diff-entry = fail
  
"

  create-nabl-tasks = 
    <output-text-file(|["lib", "runtime", "nabl"], "tasks.str")>
"module runtime/nabl/tasks

imports 
  
  runtime/task/core
  runtime/task/tasks
  runtime/task/utils
  runtime/nabl/lookup
  runtime/nabl/collect
  runtime/nabl/query
  runtime/nabl/incremental
  runtime/nabl/interface
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/nabl/entries
  runtime/properties/entries
  runtime/properties/eq
  runtime/properties/query
  
signature
  
  constructors
    
    CollectDefs            : Term                                      -> Instruction
    ResolveDefs            : Scope * Namespace * Name * Prop           -> Instruction
    CheckDefs              : Namespace * URI                           -> Instruction
    DisambiguateDefs       : List(Def) * List(Prop) * Namespace * Name -> Instruction
    ResolveNamedImports    : Scope * Namespace * Name                  -> Instruction
    ImportCalc             : URI                                       -> Instruction
    ImportClosure          : URI                                       -> Instruction
    PropConstraint         : Kind * Expected * Result                  -> Instruction
        
    ResolveAllDefs         : Scope * Namespace                         -> Instruction
    ResolveAllDefs         : Scope * Namespace * Name * Prop           -> Instruction
        
rules // basics
  
  perform-task(|nr) = 
    ?CollectDefs(<id>)
  ; (?Def(_) <+ try(nabl-get-name); get-annos; mapconcat(?Def(_); MkSingleton + ?Use(<is-list <+ MkSingleton>)))

rules // Resolve
  
  // Looks up defintions in scopes with namespace and name.
  perform-task(|nr):
    ResolveDefs(scope, ns, name, prop*) -> result
    where
      uri        := <nabl-uri> scope;
      name'      := <try-remove-list; strip-annos> name;
      <nabl-add-name-read(|nr, ns, name')> uri;
      def*       := <nabl-lookup(|ns, name')> uri;
      result     := <filter(filter-defs-props(|prop*)); (task-collect-dependencies <+ not(?[]))> def*
      
  task-short-circuit = ?ResolveDefs(_, _, _, _)
 
 
  perform-task(|nr):
    ResolveAllDefs(scope, ns, name, prop*) -> <perform-task(|nr)> ResolveDefs(scope, ns, name, prop*)
 
      
  filter-defs-props(|prop*):
    definition -> <map(filter-defs-prop(|definition)); (task-collect-dependencies <+ !definition)> prop*
    
  filter-defs-prop(|definition):
    Prop(kind, expected, _) -> result
    where
      uri    := <nabl-uri> definition;
      value  := <get-index-property(|kind)> uri;
      value' := <insert-results-or-create-dependency> value;
      switch id
        case task-collect-dependencies => d : !d
        otherwise                           : <nabl-property-eq> (kind, Eq(), (expected, value')); !definition <+
                                              <nabl-property-eq> (kind, Eq(), (expected, <try-remove-list> value')); !definition
      end => result

  perform-task(|nr):
    PropConstraint(kind, expected, definition) -> <filter-defs-prop(|definition)> Prop(kind, expected, [])
    
  perform-task(|nr):
    CheckDefs(ns, d) -> d
    where
      <nabl-uri; nabl-uri-namespace; ?ns> d
  
  // TODO: this task is not created any more
  // Calls a user-defined disambiguation filter on definitions with relevant information.
  // perform-task(|nr):
  //  DisambiguateDefs(def*, prop*, namespace, name) -> result
  //  where
  //    if <Tl> def* then
  //      <try(nabl-disambiguate(|prop*, namespace, name))> def*
  //    else
  //      !def*
  //    end => result;
  //    not(?[])
  // 
  //  task-is-combinator = ?DisambiguateDefs(_, _, _, _)

  // TODO: this task is not created any more
  // Looks up named imports, active in scopes with namespace and name..
  // perform-task(|nr):
  //  ResolveNamedImports(scope, ns, name) -> result
  //  where
  //    uri     := <nabl-uri> scope;
  //    <nabl-add-uri-read(|nr)> uri;
  //    name'   := <try-remove-list; strip-annos> name; // TODO: can this be a list?
  //    import* := <nabl-lookup-named-import(|ns, name')> uri;
  //      switch id
  //        case ?[]                            : fail
  //        case task-collect-dependencies => d : !d
  //        otherwise                           : id
  //      end => result

rules // Visibility
  
  // Looks up defintions in scopes with namespace and name.
  perform-task(|nr):
    ResolveAllDefs(scope, ns) -> def*
    where
      uri  := <nabl-uri> scope;
      <nabl-add-ns-read(|nr, ns)> uri;
      def* := <nabl-lookup-all(|ns)> uri;
      not(?[])

  nabl-resolve-all-defs-subtasks(|partition, ns, prop*, range):
    uri -> [task|subtasks]
    with
      task := <nabl-resolve-all-defs-subtasks-one(|partition, ns, prop*, range)> uri;
      switch !range
        case One(): ![]
        case All(): <nabl-uri-parent < nabl-resolve-all-defs-subtasks(|partition, ns, prop*, range) + ![]> uri
      end => subtasks
    
  nabl-resolve-all-defs-subtasks-one(|partition, ns, prop*, range):
    uri -> filtered
    with
      def-task := <new-task(|partition)> ResolveAllDefs(uri, ns)
    ; filtered  := <nabl-use-propconstraint(|partition)> (def-task, prop*)

"

  create-nabl-complete = 
    <output-text-file(|["lib", "runtime", "nabl"], "complete.str")>
"module runtime/nabl/complete

imports
  
  runtime/nabl/collect
  runtime/nabl/uri
  runtime/task/core
  
signature

  constructors
    
    COMPLETION : String -> COMPLETION
    
rules // Code completion

  nabl-propose-completions:
    ast -> proposal*
    with
        completion* := <collect-one(?COMPLETION(_)); nabl-collect-all-completion> ast;
        def*        := <mapconcat(\\Completion(result) -> result\\; task-get-solved)> completion*;
        proposal*   := <map(nabl-uri; nabl-uri-name)> def*
      <+
        proposal*   := []

"

  create-nabl-entries = 
    <output-text-file(|["lib", "runtime", "nabl"], "entries.str")>
"module runtime/nabl/entries

imports
  
  runtime/nabl/collect
  runtime/nabl/utils
  runtime/nabl/uri
  runtime/nabl/resolve
  runtime/index/core
  runtime/editor/origins
  
signature

  constructors
    
    Def          : URI                    -> Entry
    Alias        : URI * URI              -> Entry
    InverseAlias : URI * URI              -> Entry
    Use          : Result                 -> Entry

rules // Index entries to diff for incrementality
  
  nabl-diff-entry = ?Def(_)
  
  nabl-diff-entry = ?Alias(_, _)
 
rules
  
  new-def(|partition, uri):
    x -> definition
    with
      definition := <origin-track-forced(!Def(uri))> x;
      <index-add(|partition)> definition;
      <new-alias(|partition, <nabl-nonunique-uri> uri, uri)> x
      
  new-alias(|partition, uri, alias-uri):
    x -> alias
    with
      alias := <origin-track-forced(!Alias(uri, alias-uri))> x;
      ialias := <origin-track-forced(!InverseAlias(alias-uri, uri))> x;
      if <not(eq)> (uri, alias-uri) then
        <index-add(|partition)> alias;
        <index-add(|partition)> ialias
      end

  new-use(|partition, uri):
    x -> use
    with
      use := <origin-track-forced(!Use(uri))> x;
      <index-add(|partition)> use

rules // index uri & value projections
  
  /** @internal */
  nabl-uri:
    Def(uri) -> uri

  /** @internal */
  nabl-uris:
    Def(uri) -> [uri]
    
  /** @internal */
  nabl-uri:
    Alias(uri, _) -> uri
    
  /** @internal */
  nabl-uris:
    Alias(uri, _) -> [uri]
    
  /** @internal */
  nabl-uri:
    InverseAlias(uri, _) -> uri
    
  /** @internal */
  nabl-uris:
    InverseAlias(uri, _) -> [uri]
    
  /** @internal */  
  nabl-uri:
    Use(uri) -> <nabl-collect-one-resolved-def; nabl-uri> uri
    
  /** @internal */  
  nabl-uris:
    Use(uri) -> <nabl-collect-all-resolved-defs; map(nabl-uri)> uri
    
  /** @internal */
  nabl-value:
    Def(value) -> value
    
  /** @internal */
  nabl-values:
    Def(value) -> [value]
    
  /** @internal */
  nabl-value:
    Alias(_, value) -> value
    
  /** @internal */
  nabl-values:
    Alias(_, value) -> [value]
    
  /** @internal */
  nabl-value:
    InverseAlias(_, value) -> value
    
  /** @internal */
  nabl-values:
    InverseAlias(_, value) -> [value]

  /** @internal */
  nabl-value:
    Use(value) -> <nabl-uri>
    
  /** @internal */
  nabl-values:
    Use(value) -> <nabl-uris>

"

  create-nabl-collect = 
    <output-text-file(|["lib", "runtime", "nabl"], "collect.str")>
"module runtime/nabl/collect

imports
  
  runtime/task/core
  runtime/task/tasks
  runtime/task/messages
  runtime/nabl/tasks
  runtime/nabl/entries
  runtime/nabl/check
  runtime/nabl/namegen
  runtime/nabl/interface
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/properties/collect
  runtime/properties/entries
  runtime/properties/tasks
  runtime/editor/origins
  runtime/editor/annotations
  runtime/types/collect

signature 

  sorts
  
    State DefScope ImplicitDef Use RefScope Range

  constructors // state
    
    State : String * Term -> State

  constructors // def

    Current    :              DefScope
    Subsequent :              DefScope
    DefScope   : Term      -> DefScope
    Scope      : Namespace -> Scope
    
  constructors // use
      
    UseCandidate  : Namespace * List(Property) * RefScope * WildcardImport * List(Dependency) -> Use
    
    True  : WildcardImport
    False : WildcardImport
  
    Current     :                                                   RefScope
    Surrounding :                                                   RefScope
    Context     : String * Namespace * List(Property) * RefScope -> RefScope
    RefScope    : Term                                           -> RefScope
    
    All : Range
    One : Range
    
    Completion : Result -> Completion
  
  constructors // import
    
    Wildcard : List(Import) * RefScope * DefScope * List(Dependency) -> ImportDesc
    Single   : Namespace * Term * DefScope * List(Dependency) -> ImportDesc
    Imported : Namespace                   -> Namespace
    Import   : Namespace                   -> Property
    Import   : Language * Namespace        -> Property
    Import   : Language * Namespace * Name -> Property
      
  constructors // partition
  
    CollectPartition : Partition
  
strategies // generic traversal
  
  /**
   * Main strategy to collect all index elements and task* from an AST.
   */
  nabl-collect(|partition, lang) =
    nabl-collect(id|lang, partition, <new-hashtable>, [])
    
  /**
   * Performs the collection in a topdown traversal. 
   * At each node, it tries various calls to generated strategies, which call back to generic strategies.
   */
  nabl-collect(sibling-uris|lang, partition, unique*, uri*) =
    nabl-state-pop(?state*)
  ; try(nabl-scoping-site)
  ; (
       nabl-scope-site(?uri'*|lang, partition, unique*, uri*)
    <+ match(?uri'*|uri*) 
    ) 
  ; (
       nabl-def-site(?child-uri*, sibling-uris, ?implicit*|lang, partition, unique*, uri'*, state*)
    <+ match(sibling-uris|uri*)
     ; match(?child-uri*|uri'*)
    )    
  ; try(nabl-state-site)
  // visit children from left to right  
  ; preserve-annos(origin-track-forced(id#(nabl-siblings(|lang, partition, unique*, child-uri*))))
  ; try(nabl-external-def-site(|partition))
  ; try(nabl-use-site(|lang, partition, unique*, uri'*, state*))
  ; try(nabl-import-site(|lang, partition, unique*, child-uri*, state*))
  ; try(nabl-prop-site(|lang, partition, uri*, state*, implicit*))
  ; nabl-annotate-properties(|lang, partition, uri'*)
    
  nabl-siblings(|lang, partition, unique*, uri*) = 
    []  
  + [ nabl-collect(?sibling-uri*|lang, partition, unique*, uri*)
    | nabl-siblings(|lang, partition, unique*, sibling-uri*) ]

rules // generic analysis of state
  
  nabl-state(pattern|state) =
    map(try(nabl-state-annotate(pattern|state)))
      
  nabl-state-annotate(pattern|state) =
    ?pattern; add-annotation(|state)
    
  nabl-state-pop(states'):
    term{anno*} -> term'
    where
      state* := <collect-all(?State(_, _))> anno*;
      term'  := <remove-annotations(?State(_, _))> term;
      match(states'|state*)
      
  nabl-get-state(|name) =
    fetch-elem(?State(name, _))

rules // generic analysis of scopes
  
  nabl-scope-site(adapted-uris|lang, partition, unique*, uri*) =
    remove-annotations(?Scope(ns*))
  ; where (
      uri'* := <extend-scope-uri(nabl-extend-uri-anonymous(|unique*, partition)|lang)> (ns*, uri*)
    ; match(adapted-uris| uri'*)
    ; scope-uri* := <map(!(<id>, <lookup-uri(|uri'*)>))> ns*
    )
  ; add-annotation(|Scope(scope-uri*))
    
  nabl-scope(|ns1*) = 
     remove-annotations(?Scope(ns2*))
   ; add-annotation(|Scope(<union> (ns1*, ns2*)))
  <+ add-annotation(|Scope(ns1*))
   
rules // generic analysis of defs
      
  // call back to generic analysis
  nabl-def(child-uris, sibling-uris|lang, partition, unique*, child-uri*, sibl-uri*, ns, unique, defscope, scoped, nt-scoped):
    a@name{anno*} -> name''
    where
      // get URI for namespace of definition site
      current-uri := <lookup-uri(|lang, ns)> child-uri*
    with
      // generate a name if needed
      name' := <try(nabl-namegen(|lang, partition, unique*, child-uri*, anno*))> name
    where
      switch !defscope
        // in each case we 
        // 1. build URI of the definition site
        // 2. update URIs for children (vertical scope)
        // 3. update URIs for right siblings (horizontal scope)
       
        // 1st case: definition in current scope
        case Current(): 
    
        // 1. extend current URI with ID segment
        // 2. extend URIs of scoped name'spaces
        // 3. preserve
          def-uri         := <nabl-extend-uri(|unique*, partition, ns, <rm-annotations> name', unique)> current-uri
        ; nt-def-uri      := <nabl-uri-add-barriers(|nt-scoped)> def-uri
        ; new-child-uri*  := <replace-scope-uri(|def-uri)> (scoped, child-uri*)
        ; new-child-uri'* := <replace-scope-uri(|nt-def-uri)> (nt-scoped, new-child-uri*)
        ; match(child-uris|new-child-uri'*)
        ; match(sibling-uris|sibl-uri*)
       
        // 2nd case: definition in subsequent scope and maybe in external scopes
        case fetch-elem(?Subsequent()) => def-scope*:
           
        // 1. extend current URI with subsequent and ID segment
        // 2. preserve
        // 3. extend URI for name'space of definition site with Subsequent segment
          subs-uri := <nabl-extend-uri-subsequent(|unique*, partition)> current-uri
        ; def-uri  := <nabl-extend-uri(|unique*, partition, ns, <rm-annotations> name', unique)> subs-uri
        ; match(child-uris|child-uri*)
        ; match(sibling-uris|<replace-scope-uri(|subs-uri)> ([ns], sibl-uri*))
    
        // 3rd case: definition only in external scopes
        case is-list => def-scope*:
        
        // 1. extend base URI with anonymous and ID segment
        // 2. preserve
        // 3. preserve
          ano-uri := <nabl-base-uri; nabl-extend-uri-anonymous(|unique*, partition)> lang 
        ; def-uri := <nabl-extend-uri(|unique*, partition, ns, <rm-annotations> name', unique)> ano-uri
        ; match(child-uris|child-uri*)
        ; match(sibling-uris|sibl-uri*)
      end
    with
      // Add Def entry to the index. Strip barriers from URI so that barriers don't end up in the index.
      d      := <new-def(|partition, <nabl-uri-strip-barriers> def-uri)> a;
      name'' := <replace-annotation(?Def(_)|d)> name'
    with
      <try(nabl-duplicate-task(|partition, unique))> name''
  
  nabl-def-alias(|partition, def-uri):
    term{anno*} -> <id>
    where
      <fetch-elem(?Scope(scope*))> anno*
    ; ns        := <nabl-uri-namespace> def-uri
    ; base-uri  := <lookup> (ns, scope*)
    ; segment   := <nabl-uri-path; Hd> def-uri
    ; alias-uri := <nabl-extend-uri(|segment); nabl-nonunique-uri> base-uri
    where
     new-alias(|partition, alias-uri, def-uri)
      
rules // generic analysis of uses
  
  // single candidate
  nabl-use(|lang, partition, unique*, uri*, candidate) =
    where (<not(is-list)> candidate);
    nabl-use(|lang, partition, unique*, uri*, [candidate])
  
  // list of candidates
  nabl-use(|lang, partition, unique*, uri*, candidate*):
    name{anno*} -> result
    with
      // generate a name if needed
      name' := <try(nabl-namegen(|lang, partition, unique*, uri*, anno*))> name
    where
      if inner-name := <not(is-string); nabl-get-name> name'; Use(inner-use-task) := <nabl-collect-use> inner-name then
        // Filter the inner use with properties instead of creating a new resolution task 
        subtask* := <map(nabl-filter-use-candidate(|lang, partition, uri*, inner-use-task))> candidate*;
        choice   := <new-task(|partition)> Choice(subtask*);
        u        := <new-use(|partition, choice)>;
        <try(nabl-unresolved-task(|partition, choice))> inner-name; // TODO: this may result in multiple unresolved msgs.
        // TODO: what about completions?
        result := <nabl-name-apply(replace-annotations(?Use(_)|u))> name'
      else
        subtask* := <map(nabl-use-candidate(|lang, partition, uri*, <nabl-fix-name> name'))> candidate*;
        choice   := <new-task(|partition)> Choice(subtask*);
        u        := <new-use(|partition, choice)>;
        <try(nabl-unresolved-task(|partition, choice))> name';
        if <is-completion-name> name' then
          completion-subtask* := <mapconcat(nabl-completion-candidate(|lang, partition, uri*))> candidate*;
          completion-concat   := <new-task(|partition)> Combine(completion-subtask*);
          result              := <replace-annotations(?Use(_)|[u, Completion(completion-concat)])> name'
        else
          result := <replace-annotation(?Use(_)|u)> name'
        end
      end


  nabl-use-subtask(|partition, ns, name, prop*, range):
    uri -> <new-task(|partition)> ResolveDefs(uri*, ns, name, prop*)
    with
      // Strip barriers because URI's in the index also do not have barriers (matching would fail).
      // Try because uri could be a Result(_) term.
      uri' := <try(nabl-uri-strip-barriers)> uri;
      switch !range
        case One(): ![uri']
        case All(): ![uri'|<nabl-uri-parents(|ns)> uri]
      end;
      mapconcat(nabl-use-subtask-scopes(|partition, ns)); 
      <new-task(|partition)> Combine(<id>) => uri*
      // TODO: disambiguation
      // TODO: order of imported URI's is unclear
      
  nabl-use-subtask-all(|partition, ns, name, prop*, range):
    uri -> <new-task(|partition)> ResolveAllDefs(uri*, ns, name, prop*)
    with
      // Strip barriers because URI's in the index also do not have barriers (matching would fail).
      // Try because uri could be a Result(_) term.
      uri' := <try(nabl-uri-strip-barriers)> uri;
      switch !range
        case One(): ![uri']
        case All(): ![uri'|<nabl-uri-parents(|ns)> uri]
      end;
      mapconcat(nabl-use-subtask-scopes(|partition, ns)); 
      <new-task(|partition)> Combine(<id>) => uri*
      // TODO: disambiguation
      // TODO: order of imported URI's is unclear
      
  nabl-use-subtask-scopes(|partition, ns):
    uri -> [uri', wildcard-import]
    with
      uri'            := <try(nabl-is-uri; MkSingleton)> uri
    ; wildcard-import := <prop-create-lookup(|partition, Import(ns)); task-create-insert(|partition); task-create-combine(|partition)> uri
      
  nabl-use-check-tasks(|partition, ns):
    name -> task'
    where
      Use(task) := <nabl-collect-use> name;
      task'     := <new-task(|partition)> CheckDefs(ns, task)
      
  nabl-use-check-tasks(|partition, ns):
    task -> task'
    where
      <not(nabl-collect-use)> task;
      task' := <new-task(|partition)> CheckDefs(ns, task)


  // candidate in current scope
  nabl-use-candidate(|lang, partition, uri*, name):
    UseCandidate(ns, prop*, Current(), _, _) -> subtask
    where
      uri       := <lookup-uri(|lang, ns)> uri*;
      subtask   := <nabl-use-subtask(|partition, ns, name, prop*, All())> uri // TODO: only disambiguate if required.
      
  // candidate in another scope (result of another resolution, which will be created here)    
  nabl-use-candidate(|lang, partition, uri*, name):
    UseCandidate(ns, prop*, Context(ctx-ns, ctx-name, ctx-prop*, ctx-context), _, dep*) -> subtask
    where
      <not(?Result(_))> ctx-name;
      ctx-result := <nabl-use-candidate(|lang, partition, uri*, ctx-name)> UseCandidate(ctx-ns, ctx-prop*, ctx-context, True(), dep*);
      subtask    := <nabl-use-subtask(|partition, ns, <nabl-fix-name> name, prop*, One())> ctx-result // TODO: only disambiguate if required.
  
  // candidate in another scope (result of existing resolution)   
  nabl-use-candidate(|lang, partition, uri*, name):
    UseCandidate(ns, prop*, Context(_, ctx-result@Result(_), _, _), _, dep*) -> subtask
    where
      subtask := <nabl-use-subtask(|partition, ns, <nabl-fix-name> name, prop*, One())> ctx-result // TODO: only disambiguate if required.

      
  // filtering candidate in current scope
  nabl-filter-use-candidate(|lang, partition, uri*, use-task):
    UseCandidate(ns, prop*, Current(), _, _) -> check-task
    where
      constraint-task := <nabl-use-propconstraint(|partition)> (use-task, prop*);
      check-task      := <nabl-use-check-tasks(|partition, ns)> 

  // filtering candidate in another scope: ignore existing resolution  
  nabl-filter-use-candidate(|lang, partition, uri*, name):
    UseCandidate(_, _, Context(_, _, _, _), _, _) -> <nabl-use-candidate(|lang, partition, uri*, name)>

      
  nabl-use-propconstraint(|partition):
    (task, [p@Prop(kind, expected, deps)|rest]) -> rec
    where
      pc  := <new-task(|partition, <dependent-tasks> (task, deps, p))> PropConstraint(kind, expected, task);
      rec := <nabl-use-propconstraint(|partition)> (pc, rest)
      
  nabl-use-propconstraint(|partition):
    (task, []) -> task

  nabl-use-disambiguate(disambiguate|partition, prop*, namespace, name):
    task -> result
    where
      disambiguate;
      result := <new-task(|partition)> DisambiguateDefs(task, prop*, namespace, name)

rules // completion

  // candidate in current scope
  nabl-completion-candidate(|lang, partition, uri*):
    UseCandidate(ns, prop*, Current(), wci, _) -> subtask*
    where
      uri       := <lookup-uri(|lang, ns)> uri*;
      subtask*  := <nabl-resolve-all-defs-subtasks(|partition, ns, prop*, All())> uri

  // candidate in another scope (result of resolution)    
  nabl-completion-candidate(|lang, partition, uri*):
    UseCandidate(ns, prop*, c@Context(ctx-ns, ctx-name, ctx-prop*, ctx-context), _, _) -> subtask*
    where
      ctx-result := <nabl-use-candidate(|lang, partition, uri*, ctx-name)> UseCandidate(ctx-ns, ctx-prop*, ctx-context, True(), []);
      subtask*   := <nabl-resolve-all-defs-subtasks(|partition, ns, prop*, One())> ctx-result
    
rules // generic analysis of imports
  
  nabl-import(|lang, partition, unique*, uri*, imports) =
    where(<map(nabl-import-candidate(|lang, partition, unique*, uri*))> imports)
  
  nabl-import-candidate(|lang, partition, unique*, uri*) =
    ?Single(ns, term, scope*, dep)
  ; Use(uri) := <nabl-collect-use> term
  ; name     := <nabl-get-name; nabl-fix-name> term
  ; <try-make-list; map(nabl-import-alias(|lang, partition, unique*, uri*, uri, ns, name))> scope*
  
  nabl-import-alias(|lang, partition, unique*, uri*, target-uri, ns, name):
    scope -> <new-alias(|partition, alias-uri, target-uri)>
  where
    base-uri  := <nabl-scope-uri(|lang, uri*, ns)> scope
    // TODO: uniqueness should be a property of the import, assumes non-unique right now.
  ; alias-uri := <nabl-extend-uri(|unique*, partition, ns, name, NonUnique())> base-uri


  nabl-import-candidate(|lang, partition, unique*, uri*) =
    ?Wildcard(import*, from, into, dep)
  ; <map(nabl-import-prop(|lang, partition, uri*, from, into))> import*
    
  nabl-import-prop(|lang, partition, uri*, from, into):
    Import(lang, ns) -> <new-prop(|partition, into-uri, Import(ns), from-uri)>
  where
     <not(?Imported(_))> ns
  where
    from-uri := <nabl-scope-uri(|lang, uri*, ns)> from 
  ; into-uri := <nabl-scope-uri(|lang, uri*, ns)> into
    
  nabl-import-prop(|lang, partition, uri*, from, into):
    Import(lang, Imported(ns)) -> <new-prop(|partition, into-uri, Import(ns), proplookup)>
  where
    from-uri := <nabl-scope-uri(|lang, uri*, ns)> from 
  ; into-uri := <nabl-scope-uri(|lang, uri*, ns)> into
  ; proplookup := <new-task(|partition)> PropsLookup(Import(ns), from-uri)


  nabl-scope-uri(|lang, uri*, ns):
    Current() -> <lookup-uri(|lang, ns); nabl-uri-strip-barriers> uri*
  
  nabl-scope-uri(|lang, uri*, ns):
    DefScope(term{anno*}) -> <lookup; nabl-uri-strip-barriers> (ns, scope*)
    where
      <fetch-elem(?Scope(scope*))> anno*
      
  nabl-scope-uri(|lang, uri*, ns):
    Context(_, name, _, _) -> uri
    where
      Use(uri) := <nabl-collect-use> name
              
rules // name retrieval

  nabl-get-name = is-string
  
  nabl-name-apply(s) = is-string; s
    
  nabl-fix-name = try(fix-completion-name); strip-annos
  
rules // URI retrieval
  
  nabl-collect-def =
    try(nabl-get-name);
    get-annos;
    collect-one(?Def(_))
    
  nabl-collect-all-def =
    try(nabl-get-name);
    get-annos;
    collect-all(?Def(_))
    
  nabl-collect-use =
    try(nabl-get-name);
    get-annos;
    collect-one(?Use(_))
    
  nabl-collect-all-use =
    try(nabl-get-name);
    get-annos;
    collect-all(?Use(_))
    
  nabl-collect-completion =
    get-annos;
    collect-one(?Completion(_))
    
  nabl-collect-all-completion =
    get-annos;
    collect-all(?Completion(_))

rules // helpers
  
  replace-scope-uri(|path) = foldl(update-scope-uri(!path|<nabl-uri-language> path))
  extend-scope-uri(s|lang) = foldl(update-scope-uri(s|lang))
  
  update-scope-uri(update|lang):
    (key, uri*) -> result
    where
      result := <fetch((?key, update))> uri* 
    <+ 
      result := [(key, <nabl-base-uri; update> lang)|uri*]
        
  lookup-uri(|lang, ns) =
    <lookup> (ns, <id>) <+ <nabl-base-uri> lang
 
  lookup-uri(|uri*) =
    <lookup> (<id>, uri*)

"

  create-editor-interop = 
    <output-text-file(|["lib", "runtime", "editor"], "interop.str")>
"module runtime/editor/interop

rules
  
  foreign-call(|lang,strategy) = prim(\"SSL_EXT_foreigncall\", lang, strategy)

"

  create-editor-queue = 
    <output-text-file(|["lib", "runtime", "editor"], "queue.str")>
"module runtime/editor/queue

rules
  
  // Set markers and analyzed AST for a given file. Use when checking files from a queued strategy.
  // Current term: (ast-analyzed, errors, warnings, notes) tuple
  // fileOrAST: file to set the markers on or the root node of the file to set markers on 
  set-markers(|fileOrAST) = prim(\"SSL_EXT_set_markers\", fileOrAST)
  
  // Set only the markers for given file, does not change the stored AST.
  // Current term: (errors, warnings, notes) tuple
  // fileOrAST: file to set the markers on or the root node of the file to set markers on 
  set-only-markers(|fileOrAST) = prim(\"SSL_EXT_set_only_markers\", fileOrAST)

  // Indicate that one or more files need analysis. 
  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
  queue-analysis = 
       (is-list; list-loop(queue-analysis))
    <+ prim(\"SSL_EXT_queue_analysis\")
    
  // Gets the number of background analyses for currenct project and language.
  // Current term: ignored
  analysis-count = prim(\"SSL_EXT_queue_analysis_count\")

  // Set the total number of work units to complete. Can be called multiple times. 
  // Current term: number of work units (int).
  set-total-work-units = prim(\"SSL_EXT_set_total_work_units\")
  
  // Complete one work unit and update progress monitors.
  // Current term: ignored
  complete-work-unit = prim(\"SSL_EXT_complete_work_unit\")
  
  // Queue a strategy for background processing with a progress indicator.
  // Current term: the term to pass to the background strategy
  // s: the strategy, as string
  // description: name of the task (will be shown in progress view)
  queue-strategy(|s,description) = prim(\"SSL_EXT_queue_strategy\", s, description)
  
  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
  set-analysis-backgrounded = !\"BACKGROUNDED\"

"

  create-editor-positions = 
    <output-text-file(|["lib", "runtime", "editor"], "positions.str")>
"module runtime/editor/positions

signature constructors

  MARKER: Term
  
strategies

  desugar-position(desugar|ast):
    position -> position'
    where
      ast'  := <at-position(!<id>{MARKER()}|position)> ast;
      ast'' := <topdown(repeat(preserve-annos({?x; desugar; not(?x)})))> ast';
      position' := <position-of-term({?_{a*}; <one(?MARKER())> a*})> ast''
   
  at-position(s|position):
    c#(t*) -> t'
    where
      !position => [i | position']
    where
      t' := c#(<at-index(at-position(s|position'))> (i, t*))

  at-position(s|position):
    t -> t'
    where
      !position => [];
      t' := <s> t

  position-of-term(is-term):
    t -> []
    where
      is-term
  
  position-of-term(is-term):
    _#(t*) -> <position-of-term(is-term|0)> t*
  
  position-of-term(is-term|start-index):
    [t | t*] -> position
    where
      if i* := <position-of-term(is-term)> t then
        position := [start-index | i*]
      else
        position := <position-of-term(is-term | <inc> start-index)> t*
      end

  term-at-position(|position):
    t -> t'
    where
      at-position(?t'|position) 

  parent-at-position(|position):
    t -> t'
    where
      !position => [i, _];
      t' := <subterm-at(|i)> t
  
  parent-at-position(|position):
    t -> <parent-at-position(|position')> t'
    where
      !position => [i | position' @ [_, _ | _]];
      t' := <subterm-at(|i)> t

  subterm-at(|index):
    _#(t*) -> <index(|<inc> index)> t*

"

  create-editor-origins = 
    <output-text-file(|["lib", "runtime", "editor"], "origins.str")>
"module runtime/editor/origins

imports
  
  runtime/editor/editor

strategies
  
  origin-term      = prim(\"SSL_EXT_origin_term\", <id>)
  origin-text      = prim(\"SSL_EXT_origin_text\", <id>)
  origin-offset    = prim(\"SSL_EXT_origin_offset\", <id>)
  origin-location  = prim(\"SSL_EXT_origin_location\", <id>)
  origin-line      = origin-location => (<id>, _, _, _)
  origin-column    = origin-location => (_, <id>, _, _)
  origin-file      = prim(\"SSL_EXT_origin_file\", <id>)
  origin-strip     = prim(\"SSL_EXT_origin_strip\", <id>)
  origin-equal(|t) = prim(\"SSL_EXT_origin_equal\", <id>, t)

  origin-location-offset = prim(\"SSL_EXT_origin_location_offset\", <id>)
  origin-location-offset-set(|origin-location-offset) = prim(\"SSL_EXT_set_origin_location_offset\", origin-location-offset)

  origin-language-description =
    prim(\"SSL_EXT_languagedescription\", <id>)

  origin-language =
    origin-file; 
    origin-language-description;
    Fst
  
  origin-surrounding-comments =
    prim(\"SSL_EXT_origin_surrounding_comments\", <origin-language>, <id>)
    
  origin-documentation-comment =
    origin-surrounding-comments;
    filter(string-as-chars(documentation-comment-chars));
    concat-strings
  
  documentation-comment-chars:
    ['*' | c*] -> <ltrim(' ' + '\\t' + '\\n' + '\\r')> c*

  origin-track-forced(s) =
    ![<id>]; all(s); ?[<id>]

  origin-relative-path:
    trm -> rel-path
    where
      full-path := <origin-file> trm;
      len-project-prefix := <project-path; string-length; inc>;
      rel-path := <string-as-chars(drop(|len-project-prefix))> full-path

  origin-debug:
    term -> term
    with
      <(origin-term     <+ !\"Failed\"); debug(!\"origin-trm: \")> term;
      <(origin-location <+ !\"Failed\"); debug(!\"origin-loc: \")> term 
"

  create-editor-annotations = 
    <output-text-file(|["lib", "runtime", "editor"], "annotations.str")>
"module runtime/editor/annotations

imports
  
rules // TODO: does not belong to editor, move to a new 'utils' directory
  
  get-annotation(s) =
    has-annos;
    get-annos;
    collect-one(s)

  add-annotation(|a):
    t{a*} -> t{a, a*}
    
  add-annotations(|a'*):
    t{a*} -> t{a'*, a*}

  remove-annotations(s):
    t{a*} -> t{a'*}
    where
      a'* := <remove-all(s)> a*
      
  replace-annotation(s|a):
    t{a*} -> t{a, a'*}
    where
      a'* := <remove-all(s)> a*
      
  replace-annotations(s|a'*):
    t{a*} -> t{a'*, a''*}
    where
      a''* := <remove-all(s)> a*

"

  create-editor-outline-library = 
    <output-text-file(|["lib", "runtime", "editor"], "outline-library.str")>
"module runtime/editor/outline-library

imports
  
  runtime/editor/origins
  runtime/editor/annotations
  
strategies
  
  /**
   * Creates an outline given a strategy s1 that rewrites AST nodes to outline labels.
   * Only AST nodes for which s1 succeed end up in the outline.
   *
   * Example:
   *   outline = simple-label-outline(to-outline-label)
   *   to-outline-label: Entity(name, _) -> name
   *   to-outline-label: Property(name, _) -> name
   */
  simple-label-outline(s1) = collect-om(to-outline-node(s1, fail), conc)
  
  /**
   * Similar to simple-label-outline(s1), but with an additional strategy s2 that rewrites
   * AST nodes to outline nodes. Strategy s2 gets priority over strategy s1 in case both succeed.
   *
   * Example:
   *   outline = custom-label-outline(to-outline-label, to-outline-node)
   *   to-outline-label: Entity(name, _) -> name
   *   to-outline-node: Property(name, _) -> Node(name, [Node(\"dummy\", [])])
   */
  custom-label-outline(s1, s2) = collect-om(origin-track-forced(s2) <+ to-outline-node(s1, s2), conc)

  /**
  * @internal
  * Note: we annotate labels with random numbers to guarantee that similar labels do not share the
  * same in-memory term, which would cause origins to be overwritten.
  */  
  to-outline-node(s1, s2):
    term -> Node(label, children)
    where
      random := <next-random>;
      label := <origin-track-forced(s1; term-to-outline-label; add-annotation(|random); remove-annotations(?random))> term;
      children := <get-arguments; custom-label-outline(s1, s2)> term
      
  /**
  * @internal
  */  
  term-to-outline-label =
    is-string 
      <+
    ?term{a}; origin-text; ?label; !label{a}
      <+
    write-to-string // fallback

rules

rules
  
  /**
  * Given a string of literals (e.g. \"context-free syntax\"), converts the string
  * into an outline label by providing it with origin information. The result is
  * that the correct portion of text in the editor gets selected, upon selecting
  * nodes with this label in the outline view.
  * Note: this strategy is useful for constructing outline labels for unnamed
  * elements. 
  *
  * @param term (e.g. 'context-free-syntax([])') provides the origin.
  */  
  literals-to-outline-label(|term):
    literals -> literals
    where
      literals' := <split-at-space> literals;
      (a, b, c, d, e) := <origin-location-offset> term;
      (before, after) := <split-before> (<origin-text> term, <Hd> literals');
      start-offset := <add> (d, <string-length> before);
      end-offset := <get-literals-end-offset(|literals', start-offset)> after;
      <origin-location-offset-set(|(a, b, c, start-offset, end-offset))> literals
      
  /**
  * @internal
  */      
  get-literals-end-offset(|literals, start-offset):
    text -> end-offset
    where
      (before, after) := <split-after> (text, <Hd> literals);
      end-offset := <get-literals-end-offset(|<Tl> literals, <add> (start-offset, <string-length> before))> after

  /**
  * @internal
  */
  get-literals-end-offset(|literals, start-offset):
    _ -> <dec> start-offset
    where
      [] := literals

rules

  /**
  * Given a term application, gets the portion of the origin text up to the start
  * of the origin text of the first subterm. If the result is an empty string, it
  * gets the origin text of the first subterm instead. Excess whitespace, such as
  * tabs and new lines, are removed.
  */
  origin-text-at-start:
    term -> result'
    where
      (cons, args) := <explode-term> term;
      offset1 := <origin-offset; ?(<id>, _)> term;
      offset2 := <Hd; origin-offset; ?(<id>, _)> args;
      offset-diff := <subt> (offset2, offset1);
      if (0 := offset-diff)
      then result' := <Hd; origin-text; guarantee-one-space-separation> args
      else result := <origin-text; explode-string; take(!offset-diff); rtrim(is-whitespace + test('\\n')); implode-string> term;
        result' := <guarantee-one-space-separation> result;
        (a, b, c, d, e) := <origin-location-offset> term;
        <origin-location-offset-set(|(a, b, c, d, <add> (d, <string-length; dec> result)))> result'
      end
  
  /**
  * @internal
  */
  guarantee-one-space-separation = string-as-chars(
      map(try(test('\\n' + ' '); !' '));
      foldr(![], rm-double-space <+ MkCons)
    )
  rm-double-space: (' ', l@[' '|xs]) -> l
  
signature constructors
  
  Node: label * children -> Node

"

  create-editor-editor = 
    <output-text-file(|["lib", "runtime", "editor"], "editor.str")>
"module runtime/editor/editor

rules
  
  project-path = prim(\"SSL_EXT_projectpath\")
  
  plugin-path = prim(\"SSL_EXT_pluginpath\")
    
  refresh-workspace-file:
    path -> <prim(\"SSL_EXT_refreshresource\", path)>
    
  editor-init =
    // Ensure all dynamic rules are properly scoped
    try(dr-scope-all-end);
    dr-scope-all-start
"

  create-modelware-model2tree = 
    <output-text-file(|["lib", "runtime", "modelware"], "model2tree.str")>
"module modelware/model2tree

imports
  
  modelware/signatures
  runtime/nabl/-

rules
  
  mw-model2tree: M(obj)                    -> <mw-obj2term> obj
  mw-obj2term  : Obj(_, QID(\"ast\", c), s*) -> c#(<map(mw-slot2term)> s*)
  mw-slot2term : None()                    -> None()
  mw-slot2term : Some(val)                 -> Some(<mw-val2term> val)
  mw-slot2term : []                        -> []
  mw-slot2term : val                       -> <mw-val2term>
  mw-val2term  : Data(val)                 -> val
  mw-val2term  : Link(uri)                 -> <mw-name-of + map(mw-name-of)> uri
  mw-val2term  : Contain(obj)              -> <mw-obj2term + map(mw-obj2term)> obj
  
rules
  
  mw-name-of = ?URI(_, <id>); Hd; ?ID(_, <id>, _)

"

  create-modelware-signatures = 
    <output-text-file(|["lib", "runtime", "modelware"], "signatures.str")>
"module modelware/signatures

signature constructors // grammar

  // TODO

signature constructors // metamodel
  
  // TODO
  
signature constructors // model
  
  M      : Object                      -> Model
  Obj    : Opt(URI) * QID * List(Slot) -> Object
         : Value                       -> Slot
         : Opt(Value)                  -> Slot
         : List(Value)                 -> Slot
  Data   : String                      -> Value
  Contain: Object                      -> Value
  Link   : QID                         -> Value
  QID    : PackName * ClassName        -> QID

"

  create-modelware-tree2model = 
    <output-text-file(|["lib", "runtime", "modelware"], "tree2model.str")>
"module modelware/tree2model

imports
  
  modelware/signatures
  runtime/nabl/-

rules
  
  mw-tree2model: t       -> M(<mw-term2obj>)
  mw-term2obj  : c#(t*)  -> Obj(<mw-def-uris>, QID(\"ast\", c), <map(mw-term2slot)> t*)
  mw-term2slot : None()  -> None()
  mw-term2slot : Some(t) -> Some(<mw-term2val> t)
  mw-term2slot : t*      -> <map(mw-term2val); mw-combine>
  mw-term2slot : t       -> <mw-term2val>
  mw-term2val  : t       -> Data(t) where is-string; not(mw-ref-uri)
  mw-term2val  : t       -> Link(<mw-ref-uri>)
  mw-term2val  : t       -> Contain(<mw-term2obj> t) where mw-is-compound

rules
  
  mw-def-uris    = get-arguments; filter(get-annos; fetch-elem(?Def(<id>)))
  mw-ref-uri     = get-annos; fetch-elem(?Def(<id>) + ?Use(_); nabl-collect-one-resolved-def; ?Def(<id>))
  mw-is-compound = where(not(?Some(_))); explode-term + map(explode-term)

  mw-combine = ?[]
  mw-combine:
    t* -> c#([<map(get-arguments; Hd)> t*])
    where
      c#(_) := <Hd> t*

"

  create-relations-query = 
    <output-text-file(|["lib", "runtime", "relations"], "query.str")>
"module relations/query

imports
  relations/entries
  runtime/nabl/query
  
rules
  
  get-index-relation(|rel) =
    !RelTuple(<id>, rel, ())
  ; nabl-get-value
   
  get-index-relations(|rel) =
    !RelTuple(<id>, rel, ())
  ; nabl-get-all-values

"

  create-relations-interface = 
    <output-text-file(|["lib", "runtime", "relations"], "interface.str")>
"module relations/interface

strategies
  
  // interface for static relation tuples, e.g. 
  //
  // relation-tuple(store): (IntTy(), SubType()) -> <store> FloatTy()

  relation-tuple(store) = fail
"

  create-relations-tasks = 
    <output-text-file(|["lib", "runtime", "relations"], "tasks.str")>
"module relations/tasks

imports
  
  relations/entries
  relations/query
  relations/interface
  
signature
  
  constructors

    RelationLookup : Relation * Term        -> Instruction
    
rules

  perform-task(|n):
    RelationLookup(rel, t) -> [stat-val*, non-trans-val*, index-val*]
    where
      // <nabl-add-uri-read(|n)> uri
      stat-set := <new-iset>
    ; <try(relation-tuple(store-tuple(|stat-set)))> (t, rel)
    ; stat-val*  := <iset-elements> stat-set
    ; <iset-destroy> stat-set
    ; index-val* := <get-index-relations(|rel)> t
    ; if Transitive(rel') := rel then
        non-trans-val* := <get-index-relations(|rel)> t
      else
        non-trans-val* := []
      end
      
  store-tuple(|set): elem -> <fail> with <iset-add(|elem)> set
"

  create-relations-entries = 
    <output-text-file(|["lib", "runtime", "relations"], "entries.str")>
"module relations/entries

imports
  
  runtime/index/core
  runtime/editor/origins
  relations/-
  runtime/task/-
  
signature

  constructors
    
    RelTuple   : Term * Relation * Term -> Entry
    Inverse    : Relation -> Relation
    Transitive : Relation -> Relation 

rules // Index entries to diff for incrementality
  
  nabl-diff-entry = ?RelTuple(_, _, _)
 
rules
  
  new-rel-tuple(|partition, rel, t2):
    t1 -> tuple
    with
      tuple := <origin-track-forced(!RelTuple(t1, rel, t2))> t1
    ; <index-add(|partition)> tuple
    with // TODO: store inverses only for invertible relations
      inverse := <origin-track-forced(!RelTuple(t2, Inverse(rel), t1))> t2
    ; <index-add(|partition)> inverse
    with
      task := <new-task(|partition)> RelationLookup(Transitive(rel), t2)
    ; transitive := <origin-track-forced(!RelTuple(t1, Transitive(rel), task))> t1
    ; <index-add(|partition)> transitive
"

  create-properties-query = 
    <output-text-file(|["lib", "runtime", "properties"], "query.str")>
"module runtime/properties/query

imports
  runtime/nabl/query
  runtime/nabl/uri
  runtime/task/core
  runtime/properties/entries
  runtime/properties/tasks
  runtime/properties/interface
  runtime/nabl/interface

rules

  get-property-task(|kind) =
     map(get-property-task(|kind))
  <+ get-annos
   ; fetch-elem(?(kind, <id>))
    
rules
  
  get-property(|kind) =
  (  get-property-task(|kind)
  <+ try(nabl-get-name)
   ; get-index-property(|kind)
  ); try( // this is needed for cases where the results are already inserted
      insert-results // TODO: is this the right insertion? probably need recursive insertion.
    ; Hd
    ) 
   
  get-index-property(|kind) =
    nabl-uris // TODO: how to handle multiple values?
  ; fetch-elem(!Prop(<id>, kind, ()); nabl-get-value)
   
  get-index-properties(|kind) =
    nabl-uris // TODO: how to handle multiple values?
  ; mapconcat(!Prop(<id>, kind, ()); nabl-get-all-values)
   
    
   
//   /**
//    * Gets a property that matches the kind of value and given URI, or fails if no property is found.
//    *
//    * Example:
//    *   <nabl-get-property(|Size())> Def([Entity(), \"Bar\"]) => Size(8)
//    *
//    * @param type Only properties of this kind is returned.
//    * @type Def(uri) or \"name\"{uri} or URI(language, path) -> Prop(uri, kind, value)
//    */
//   nabl-get-property(|kind) = 
//     nabl-get-all-properties(|kind); Hd
//       
//   /**
//    * Gets all properties that match the kind of value and given URI.
//    *
//    * Example:
//    *   <nabl-get-all-properties(|Size())> Def([Entity(), \"Bar\"]) => [Size(8), ...]
//    *
//    * @param kind Only data of this kind is returned.
//    * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Prop(uri, kind, value))
//    */
//   nabl-get-all-properties(|kind):
//     contains-uri* -> <mapconcat(!Prop(<id>, kind, ()); nabl-get-all-values)> uri*
//     where
//       uri* := <nabl-uris> contains-uri*
// 
//   nabl-get-all-properties(|kind) = nabl-get-property-task(|kind); insert-results
//   
//   nabl-get-property-task(|partition, kind) = 
//      nabl-get-property-task(|kind)
//   <+ <new-task(|partition)> PropsLookup(kind, <nabl-uri>)
//   <+ <new-task(|partition)> Fail()
  
"

  create-properties-eq = 
    <output-text-file(|["lib", "runtime", "properties"], "eq.str")>
"module runtime/properties/eq

signature constructors
  
  Eq: Relation
  
strategies
  
  nabl-reflexive = ?Eq()
  
  nabl-property-eq:
    (_, rel, p) -> <where(strip-annos; eq); Fst> p
    where
      <nabl-reflexive> rel
  
  nabl-property-eq(|kind, rel, expected) = <nabl-property-eq> (kind, rel, (<id>, expected))
"

  create-properties-interface = 
    <output-text-file(|["lib", "runtime", "properties"], "interface.str")>
"module runtime/properties/interface

strategies // implementations generated from NaBL
  
  nabl-custom-properties(add-properties) = fail
  
  create-property-task(|ctx, kind) = fail

strategies // user-defined implementations
  
  nabl-constraint(|lang, partition, uri*) = nabl-constraint(|partition)

  nabl-constraint(|partition) = fail

  nabl-property-eq = fail
  
"

  create-properties-tasks = 
    <output-text-file(|["lib", "runtime", "properties"], "tasks.str")>
"module runtime/properties/tasks

imports 
  
  runtime/nabl/incremental
  runtime/nabl/uri
  runtime/properties/query
  runtime/properties/eq
  runtime/task/core
  runtime/editor/annotations
  
signature
  
  constructors

    PropsLookup : Property * URI                    -> Instruction
    PropCheck   : Property * Relation * Term * Term -> Instruction
    PropExtract : Property * Term                   -> Instruction
    
rules

  // TODO: replace all PropsLookup references with a call to this rule.
  prop-create-lookup(|ctx, kind):
    contains-uri -> <new-task(|ctx)> PropsLookup(kind, contains-uri)

  perform-task(|n):
    PropsLookup(kind, contains-uri) -> res
    where
      uri := <nabl-uri> contains-uri
    ; <nabl-add-uri-read(|n)> uri
    ; val := <get-index-properties(|kind)> uri
    ; res := <try(concat)> val
      // TODO: why try concat?
    
  perform-cyclic-task(|n):
    PropsLookup(kind, contains-uri) -> res
    where
      uri := <nabl-uri> contains-uri
    ; <nabl-add-uri-read(|n)> uri
    ; val := <get-index-properties(|kind)> uri
    ; res := <try(concat); make-set> val
      // TODO: why try concat?

rules
  
  // TODO: replace all PropCheck references with a call to this rule.
  prop-create-check(|ctx, kind, rel, actual):
    expected -> <new-task(|ctx)> PropCheck(kind, rel, actual, expected)
  
  perform-task(|n): 
    PropCheck(kind, rel, actual, expected) -> [<nabl-property-eq> (kind, rel, (actual, expected))]

rules

  // TODO: replace all PropExtract references with a call to this rule.
  prop-create-extract(|ctx, kind):
    term -> <new-task(|ctx)> PropExtract(kind, term)

  perform-task(|n):
    PropExtract(kind, term) -> <get-annotation(?(kind, <id>))> term

"

  create-properties-entries = 
    <output-text-file(|["lib", "runtime", "properties"], "entries.str")>
"module runtime/properties/entries

imports
  
  runtime/nabl/collect
  runtime/nabl/utils
  runtime/nabl/uri
  runtime/index/core
  runtime/editor/origins
  
signature

  constructors
    
    Prop  : URI * Property * Value -> Entry

rules // Index entries to diff for incrementality
  
  nabl-diff-entry = ?Prop(_, _, _)

rules
  
  new-prop(|partition, uri, kind, val):
    x -> prop
    with
      prop := <origin-track-forced(!Prop(uri, kind, val))> x;
      <index-add(|partition)> prop
        
rules // index uri & value projections
  
  /** @internal */  
  nabl-uri:
    Prop(uri, _, _) -> uri
    
  /** @internal */  
  nabl-uris:
    Prop(uri, _, _) -> [uri]
    
  /** @internal */
  nabl-value:
    Prop(_, _, value) -> value
    
  /** @internal */
  nabl-values:
    Prop(_, _, value) -> [value]

"

  create-properties-collect = 
    <output-text-file(|["lib", "runtime", "properties"], "collect.str")>
"module runtime/properties/collect

imports 
  
  runtime/properties/entries
  runtime/properties/tasks
  runtime/properties/interface
  runtime/properties/query
  runtime/task/core
  runtime/task/tasks
  runtime/nabl/collect
  runtime/nabl/uri
  runtime/nabl/tasks
  runtime/nabl/utils
  runtime/editor/origins
  runtime/editor/annotations
  runtime/types/collect
  
signature
  
  sorts
  
    Property
    
  constructors
    
    Prop : Property * Value * List(Dependency) -> Prop

rules // generic analysis of properties
  
  // call back to generic analysis
  nabl-store-props(|partition, prop*) =
    where (
      ?name
    ; nabl-collect-def; nabl-uri => uri
    ; <map(nabl-store-prop(|partition, uri, name))> prop*
    )
  
  nabl-store-prop(|partition, prop) =
    where (
      ?name
    ; nabl-collect-def; nabl-uri => uri
    ; <nabl-store-prop(|partition, uri, name)> prop
    )
      
  nabl-store-prop(|partition, uri, name):
    Prop(kind, prop, dep*) -> <new-prop(|partition, uri, kind, result)> name
    where
      result := <new-task(|partition, <dependent-tasks> dep*)> Id(prop)
      
rules
        
  // generic collection of property tasks
  nabl-annotate-properties(|lang, partition, uri*) =
    where(
      iset := <new-iset>
    ; try(nabl-custom-properties(\\p* -> <iset-addlist(|p*); fail> iset\\))
    ; kind* := [Type()|<iset-elements> iset]
    )
  ; !(kind*, <remove-property-annotations(|kind*)>)
  ; foldl(nabl-annotate-property(|lang, partition, uri*) <+ Snd)
  ; where(try(nabl-constraint(|lang, partition, uri*)))
  
  nabl-annotate-property(|lang, partition, uri*):
    (kind, term{a*}) -> term{(kind, prop), a*}
    where
      not(<get-property-task(|kind)> term)
    ; prop := <create-property-task(|partition, kind)> term
      
strategies
  
  nabl-prop-calc(|partition, dep*) = 
    where(all-dep* := <union> (<dependent-tasks> dep*, <dependent-tasks>))
  ; <new-task(|partition, all-dep*)> Id(<id>)
  
  nabl-prop-list(|partition, dep*) = 
    where(all-dep* := <union> (<dependent-tasks> dep*, <dependent-tasks>))
  ; <new-task(|partition, all-dep*)> Combine(<id>)
    
  nabl-prop-lookup(|kind, partition, dep*) = 
     get-annos
   ; fetch-elem(?(kind, <id>))
  <+ where(all-dep* := <union> (<dependent-tasks> dep*, <dependent-tasks>))
   ; <new-task(|partition, all-dep*)> CollectDefs(<id>)
   ; <new-task(|partition)> PropsLookup(kind, <id>)
  
  nabl-prop-match(|kind, partition, relation, expected) = 
    ?actual
  ; expected* := <try-make-list> expected
  ; check*    := <map(<new-task(|partition)> PropCheck(kind, relation, actual, <id>))> expected*
  ; <new-task(|partition, <dependent-tasks> check*)> Choice(check*)
  
  // // FIXME: is resolve a Result or a task ID?
  // nabl-prop-constraints(|partition, resolve) =
  //   <new-task(|partition, <dependent-tasks> [resolve | <map(nabl-prop-constraint)>])> Id(resolve)
  //     
  // nabl-prop-constraint(|partition, resolve):
  //   Prop(kind, expected, dep*) -> constr
  //   where
  //     actual := <new-task(|partition)> PropsLookup(kind, resolve) 
  //   ; dep'*  := <dependent-tasks> [expected, dep*]
  //   ; Result(constr) := <new-task(|partition, [actual, dep'*])> PropCheck(kind, Eq(), actual, expected)

rules
  
  get-or-create-property-task(|ctx, kind) = 
     get-property-task(|kind)
  <+ map(create-property-task(|ctx, kind))
  <+ create-property-task(|ctx, kind)
  
  create-property-task(|ctx, kind):
    r@Result(_) -> <new-task(|ctx)> PropExtract(kind, r)
    
  create-property-task(|ctx, kind) :
    x -> <nabl-prop-calc(|ctx, t*)> t*
    where 
      t* := <map(get-or-create-property-task(|ctx, kind))> x
    
rules
  
  remove-property-annotations(|kind*) =
    !(kind*, <id>); foldl(remove-property-annotation) 
    
  remove-property-annotation:
    (kind, term) -> <remove-annotations(?(kind, _))> term

"

  create-types-query = 
    <output-text-file(|["lib", "runtime", "types"], "query.str")>
"module runtime/types/query

imports
  
  runtime/types/collect
  runtime/properties/collect
  runtime/properties/query
  
rules // during analysis
  
  type-task(|ctx) = get-or-create-property-task(|ctx, Type())
  get-type-task   = get-property-task(|Type())
  
rules // post analysis
  
  get-type =
    get-property(|Type())
 
"

  create-types-interface = 
    <output-text-file(|["lib", "runtime", "types"], "interface.str")>
"module runtime/types/interface

imports
  
  runtime/types/collect
  
strategies // user-defined implementations
  
  create-type-task(|ctx) = fail
  
"

  create-types-collect = 
    <output-text-file(|["lib", "runtime", "types"], "collect.str")>
"module runtime/types/collect

imports 
  
  runtime/types/interface
  runtime/properties/collect
  runtime/properties/eq
  
signature

  constructors
    
    Type : Property
    
rules
  
  create-property-task(|ctx, kind) =
    where(Type() := kind)
  ; create-type-task(|ctx)
       
  type-is(|partition)           = nabl-prop-calc(|partition, [])
  type-is(|partition, dep*)     = nabl-prop-calc(|partition, dep*)
  
  type-list(|partition)         = nabl-prop-list(|partition, [])
  type-list(|partition, dep*)   = nabl-prop-list(|partition, dep*)
  
  type-lookup(|partition)       = nabl-prop-lookup(|Type(), partition, [])
  type-lookup(|partition, dep*) = nabl-prop-lookup(|Type(), partition, dep*)

  type-match(|partition, expected)           = nabl-prop-match(|Type(), partition, Eq(), expected)
  type-match(|partition, relation, expected) = nabl-prop-match(|Type(), partition, relation, expected)
   
  store-type(|partition, type) =
    nabl-store-prop(|partition, Prop(Type(), type, []))
    
"

  create-analysis-core = 
    <output-text-file(|["lib", "runtime", "analysis"], "core.str")>
"module runtime/analysis/core

imports
  
  runtime/analysis/interface
  runtime/index/core
  runtime/nabl/collect
  runtime/nabl/incremental
  runtime/nabl/entries
  runtime/nabl/uri
  runtime/nabl/utils
  runtime/task/core
  runtime/task/messages
  runtime/editor/origins
  
signature

  constructors
  
    File        : Path * AST -> File
    
    // Result(partition, initial-ast, analyzed-ast, changed-read*, error*, warning*, note*)
    Result      : Partition * AST * AST * List(URI) * List(Term) * List(Term) * List(Term) -> Result
    
    // DebugResult(removed-entry*, added-entry*, removed-task*, added-task*, invalidated-task*)
    DebugResult : List(Entry) * List(Entry) * List(TaskID) * List(TaskID) * List(TaskID) -> Result
    
rules // Analysis
  
  analyze-collect(|language, project-path) = analyze-collect(id|language, project-path)
  analyze-collect(try-recover|language, project-path):
    File(partition, initial-ast) -> ( 
      Result(partition, initial-ast, analyzed-ast, changed-read*, [], [], [])
    , DebugResult(<length> removed-entry*, <length> added-entry*, <length> removed-task*, <length> added-task*, <length> invalidated-task*)
    )
    with
      <analysis-core-debug(!\"Collecting: \")> partition;
      measure-time(
        measure-time(
          index-setup(|language, project-path);
          try(try-recover; index-recover);
          index-start-collection(|partition);
          task-setup(|project-path);
          try(try-recover; task-recover);
          task-start-collection(|partition)
          , analysis-core-debug-time(!\"Time - setup: \") | \"analyze-collect-setup\"
        ); measure-time(
          analyzed-ast := <nabl-collect(|partition, Language(language))> initial-ast
          , analysis-core-debug-time(!\"Time - collect: \") | \"analyze-collect-collect\" 
        ); measure-time(
          index-stop-collection => (removed-entry*, added-entry*);
          task-stop-collection(|partition) => (removed-task*, added-task*);
          changed-read* := <nabl-get-changed-reads> [removed-entry*, added-entry*]
          , analysis-core-debug-time(!\"Time - diff: \") | \"analyze-collect-diff\" 
        ); measure-time(
          task-invalidate-task-reads(|changed-read*) => invalidated-task*
          , analysis-core-debug-time(!\"Time - invalidate: \") | \"analyze-collect-invalidate\"
        )
      , id | \"analyze-collect-total\")
  
  analyze-perform-all:
    result* -> (result'*, evaluated-task*, skipped-task*, unevaluated-task*)
    with
      measure-time(
        measure-time(
          task-evaluate-scheduled => (evaluated-task*, skipped-task*, unevaluated-task*)
          , analysis-core-debug-time(!\"Time - evaluation: \") | \"analyze-task-evaluate\"
        ); measure-time(
          result'* := <map(analyze-messages)> result*
          , analysis-core-debug-time(!\"Time - messages: \") | \"analyze-task-messages\"
        )
    , id | \"analyze-task-total\")
      
  analyze-messages:
    (Result(partition, initial-ast, analyzed-ast, changed-read*, _, _, _), debug-result) -> 
    (Result(partition, initial-ast, analyzed-ast, changed-read*, error*, warning*, note*), debug-result)
    with
      (error*, warning*, note*) := <analyze-get-messages> partition

  analyze-get-messages:
    partition -> (error*, warning*, note*)
    with
      message* := <task-get-messages(|partition)>;
      error*   := <filter(?Error(_, _, _); analyze-message-to-tuple)> message*;
      warning* := <filter(?Warning(_, _, _); analyze-message-to-tuple)> message*;
      note*    := <filter(?Note(_, _, _); analyze-message-to-tuple)> message*
      
  analyze-message-to-tuple:
    message -> (<origin-location-offset-set(|origin)> term, msg)
    with
      origin := <task-message-origin> message;
      term   := <task-message-term> message;
      msg    := <task-message> message
      
rules // Projections
  
  analyze-result-reads:
    Result(_, _, _, changed-read*, _, _, _) -> changed-read*
    
  analyze-result-analyzed-ast:
    Result(_, _, analyzed-ast, _, _, _, _) -> analyzed-ast

  analysis-partition(|path, project-path) = !$[[project-path]/[path]]

rules // Debugging
  
  analysis-core-debug(msg) = try(analysis-core-debug-interface(msg))
  analysis-core-debug = try(analysis-core-debug-interface)
  analysis-core-debug-interface(msg) = fail
  analysis-core-debug-interface = fail
  
  analysis-core-debug-time(msg) = try(analysis-core-debug-time-interface(msg))
  analysis-core-debug-time = try(analysis-core-debug-time-interface)
  analysis-core-debug-time-interface(msg) = fail
  analysis-core-debug-time-interface = fail
  

"

  create-analysis-resolve = 
    <output-text-file(|["lib", "runtime", "analysis"], "resolve.str")>
"module runtime/analysis/resolve

imports
  
  runtime/nabl/resolve
  runtime/nabl/entries
  runtime/task/core
  runtime/index/core
  runtime/index/query
  
rules
  
  analysis-resolve(|language, project-path):
    node -> definition
    where
      task-setup(|project-path);
      index-setup(|language, project-path);
      definition := <has-annos; get-annos; fetch-elem(?Use(<id>)); task-get-result; Hd> node
      
  // Legacy
  analysis-resolve(|language, project-path, path) = analysis-resolve(|language, project-path)
"

  create-analysis-interface = 
    <output-text-file(|["lib", "runtime", "analysis"], "interface.str")>
"module runtime/analysis/interface

rules
  

"

  create-analysis-debug = 
    <output-text-file(|["lib", "runtime", "analysis"], "debug.str")>
"module runtime/analysis/debug

imports
  
  runtime/index/core
  runtime/index/query
  runtime/task/core
  runtime/task/debug
  runtime/editor/interop

rules // Index
   
  analysis-debug-show-all-partitions(|language) = analysis-debug-index-project(|language)
  analysis-debug-show-current-partition(|language) = analysis-debug-index-partition(|language)
   
  analysis-debug-index-project(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      result-ast := <index-get-all-partitions; map(\\f -> (f, <index-get-all-in-partition> f)\\)>;
      if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast then
        filename := $[[project-path]/[<dirname> path]/project.index];
        result   := result-index
      else
        filename := $[[project-path]/[<dirname> path]/index.project.aterm];
        result   := result-ast
      end
   
  analysis-debug-index-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      partition  := $[[project-path]/[path]];
      result-ast := [(partition, <index-get-all-in-partition> partition)];
      if result-index := <foreign-call(|\"Analysis\", \"from-index-debug-str\")> result-ast then
        filename := <guarantee-extension(|\"partition.index\")> path;
        result   := result-index
      else
        filename := <guarantee-extension(|\"index.partition.aterm\")> path;
        result   := result-ast
      end
  
rules // Task engine    
      
  analysis-debug-show-tasks(|language) = analysis-debug-task-partition(|language)
  analysis-debug-show-tasks-selection(|language) = analysis-debug-task-selection(|language)

  analysis-debug-task-project(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      task-setup(|project-path);
      result-ast := <task-debug-info(|())>;
      if result-task := <foreign-call(|\"Analysis\", \"from-task-debug-str\")> result-ast then
        filename := $[[project-path]/[<dirname> path]/project.task];
        result   := result-task
      else
        filename := $[[project-path]/[<dirname> path]/task.project.aterm];
        result   := result-ast
      end
      
  analysis-debug-task-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      task-setup(|project-path);
      partition  := $[[project-path]/[path]];
      result-ast := <task-debug-info(|partition)>;
      if result-task := <foreign-call(|\"Analysis\", \"from-task-debug-str\")> result-ast then
        filename := <guarantee-extension(|\"partition.task\")> path;
        result   := result-task
      else
        filename := <guarantee-extension(|\"task.partition.aterm\")> path;
        result   := result-ast
      end
      
  analysis-debug-task-selection(|language):
    (selected, _, _, path, project-path) -> (filename, result)
    with
      task-setup(|project-path);
      partition  := $[[project-path]/[path]];
      result-ast := <task-debug-ast> selected;
      if result-task := <foreign-call(|\"Analysis\", \"from-task-debug-str\")> result-ast then
        filename := <guarantee-extension(|\"selection.task\")> path;
        result   := result-task
      else
        filename := <guarantee-extension(|\"task.selection.aterm\")> path;
        result   := result-ast
      end
      
rules // Index & task engine
  
  analysis-debug-project(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      task-setup(|project-path);
      task-debug  := <task-debug-info(|())>;
      index-debug := <index-get-all-partitions; map(\\f -> (f, <index-get-all-in-partition> f)\\)>;
      result-ast  := (task-debug, index-debug);
      if result-analysis := <foreign-call(|\"Analysis\", \"from-debug-str\")> result-ast then
        filename := $[[project-path]/[<dirname> path]/project.analysis];
        result   := result-analysis
      else
        filename := $[[project-path]/[<dirname> path]/analysis.project.aterm];
        result   := result-ast
      end
      
  analysis-debug-partition(|language):
    (_, _, _, path, project-path) -> (filename, result)
    with
      index-setup(|language, project-path);
      task-setup(|project-path);
      partition   := $[[project-path]/[path]];
      task-debug  := <task-debug-info(|partition)>;
      index-debug := [(partition, <index-get-all-in-partition> partition)];
      result-ast  := (task-debug, index-debug);
      if result-analysis := <foreign-call(|\"Analysis\", \"from-debug-str\")> result-ast then
        filename := <guarantee-extension(|\"partition.analysis\")> path;
        result   := result-analysis
      else
        filename := <guarantee-extension(|\"partition.aterm\")> path;
        result   := result-ast
      end
   
rules // Resetting  
      
  analysis-debug-reset-index(|language):
    (_, _, _, path, project-path) -> None()
    with
      partition := $[[project-path]/[path]];
      index-setup(|language, project-path);
      index-reset
      
  analysis-debug-reset-task(|language):
    (_, _, _, path, project-path) -> None()
    with
      task-setup(|project-path);
      task-reset

  analysis-debug-reanalyze(|language):
    (_, _, _, path, project-path) -> None()
    with
      partition := $[[project-path]/[path]];
      task-setup(|project-path);
      task-reset;
      index-setup(|language, project-path);
      index-reload

"

  create-analysis-reanalysis = 
    <output-text-file(|["lib", "runtime", "analysis"], "reanalysis.str")>
"module runtime/analysis/reanalysis

imports
  
  runtime/analysis/core
  runtime/analysis/single
  runtime/analysis/defaults
  runtime/task/core
  runtime/index/core
  runtime/nabl/collect
  runtime/nabl/namegen

rules
  
  start-reanalysis(|language, path, project-path) =
    nabl-namegen-clear(|<analysis-partition(|path, project-path)>);
    index-push;
    task-push
    
  stop-reanalysis(|language, path, project-path) =
    task-pop;
    index-pop
  
  reanalysis(s|language, path, project-path) =
    where(start-reanalysis(|language, path, project-path); s; stop-reanalysis(|language, path, project-path))
  
  reanalyze-ast(|language, path, project-path):
    ast -> analyzed-ast
    with
      (
        analyzed-ast
      , (error*, warning*, note*)
      , removed-entry*
      , added-entry*
      , removed-task*
      , added-task*
      , invalidated-task*
      , evaluated-task*
      , skipped-task*
      , unevaluated-task*
      ) := <analyze-one(fail|language, path, project-path)> ast;
      
      <analysis-debug-results> (removed-entry*, added-entry*, removed-task*, added-task*, invalidated-task*, evaluated-task*, skipped-task*, unevaluated-task*);
      
      <map(analysis-default-debug(!\"Error: \"))> error*;
      <map(analysis-default-debug(!\"Warning: \"))> warning*;
      <map(analysis-default-debug(!\"Note: \"))> note*

"

  create-analysis-multiple = 
    <output-text-file(|["lib", "runtime", "analysis"], "multiple.str")>
"module runtime/analysis/multiple

imports

  runtime/analysis/core
  runtime/task/core
  runtime/nabl/utils

rules // Multi file analysis
  
  analyze-multiple(parse-file, complete-work-unit|language, project-path):
    path* -> result*
    with
      measure-time(
        file* := <map(analyze-parse-file(parse-file); where(complete-work-unit))> path*
      , id | \"analyze-parse\");
      result* := <analyze-multiple-files(complete-work-unit|language, project-path)> file*

  analyze-parse-file(parse-file):
    path -> File(path, ast)
    with
      if not(ast := <file-exists; parse-file> path) then
        ast := ()
      end

  analyze-multiple-files(complete-work-unit|language, project-path):
    file* -> (result'*, evaluated-task*, skipped-task*, unevaluated-task*)
    with
      result* := <map(analyze-collect(|language, project-path); where(complete-work-unit))> file*;
      (result'*, evaluated-task*, skipped-task*, unevaluated-task*) := <analyze-perform-all> result*
      
"

  create-analysis-single = 
    <output-text-file(|["lib", "runtime", "analysis"], "single.str")>
"module runtime/analysis/single

imports
  
  runtime/analysis/core
    
rules // Single file analysis
  
  analyze-one(|language, path, project-path) = 
    analyze-one(id|language, path, project-path)
  
  analyze-one(try-recover|language, path, project-path):
    ast -> 
    (
      analyzed-ast
    , (error*, warning*, note*)
    , removed-entry*
    , added-entry*
    , removed-task*
    , added-task*
    , invalidated-task*
    , evaluated-task*
    , skipped-task*
    , unevaluated-task*
    )
    with
      partition := <analysis-partition(|path, project-path)>;
      r@(
        Result(_, _, analyzed-ast, _, _, _, _)
      , DebugResult(removed-entry*, added-entry*, removed-task*, added-task*, invalidated-task*)
      ) := <analyze-collect(try-recover|language, project-path)> File(partition, ast);
      
      (result*, evaluated-task*, skipped-task*, unevaluated-task*) := <analyze-perform-all> [r];
      
      Result(_, _, _, _, error*, warning*, note*) := <Hd; Fst> result*
"

  create-analysis-complete = 
    <output-text-file(|["lib", "runtime", "analysis"], "complete.str")>
"module runtime/analysis/complete

imports
  
  runtime/nabl/complete
  runtime/task/core
  runtime/index/core
  
rules
  
  analysis-propose-completions(|language, project-path):
    ast -> <nabl-propose-completions> ast
    with
      task-setup(|project-path);
      index-setup(|language, project-path)

  // Legacy
  analysis-propose-completions(|language, project-path, path) = analysis-propose-completions(|language, project-path)

"

  create-analysis-defaults = 
    <output-text-file(|["lib", "runtime", "analysis"], "defaults.str")>
"module runtime/analysis/defaults

imports
  
  runtime/analysis/core
  runtime/analysis/single
  runtime/analysis/multiple
  runtime/nabl/utils
  runtime/index/core
  runtime/task/core
  runtime/editor/editor
  runtime/editor/queue

rules // Analysis
  
  analysis-default-editor = analysis-single-default-interface <+ (where(not(is-tuple)); analysis-multiple-default-queue)
  analysis-default-cmd = analysis-single-default-interface <+ (where(not(is-tuple)); analysis-multiple-default-interface)

  analysis-changed-partitions:
    taskID* -> <task-partitions-of(|taskID*)>
    
  is-test-file = 
    string-ends-with(|\".spt\")

rules // Single finle analysis
  
  analysis-single-default-interface = fail
  
  analysis-single-default(desugar-before, desugar-after, pp-message|language):
    (ast, path, project-path) -> (analyzed-ast, error*, warning*, note*)
    with
      editor-init;
      <analysis-default-debug(!\"Analyzing file: \")> path;
      
      (
        analyzed-ast
      , (analysis-error*, analysis-warning*, analysis-note*)
      , removed-entry-count
      , added-entry-count
      , removed-task-count
      , added-task-count
      , invalidated-task-count
      , evaluated-task*
      , skipped-task*
      , unevaluated-task*
      ) := <desugar-before; analyze-one(|language, path, project-path); desugar-after> ast;
      
      (error*, warning*, note*) := <analysis-message-collect(pp-message|analysis-error*, analysis-warning*, analysis-note*)> analyzed-ast;
      
      partition* := <analysis-changed-partitions> evaluated-task*;
      if <not(is-test-file)> path then
        partition := <analysis-partition(|path, project-path)>;
        <remove-all(?partition <+ ?path); analysis-message-update-partitions-queue(|language, project-path)> partition*
      end;
      
      <analysis-debug-results> (removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count, evaluated-task*, skipped-task*, unevaluated-task*)
      
rules // Multi-file analysis
      
  analysis-multiple-default-interface = fail    
      
  analysis-multiple-default-queue:
    path* -> None()
    with
      queue-strategy(|\"analysis-multiple-default-interface\", \"Analyzing files\")
      
  analysis-multiple-default(parse, desugar-before, desugar-after, pp-message|language, project-path):
    path* -> (analysis-result'*, evaluated-task*, unevaluated-task*)
    with
      analysis-default-debug(!\"Analyzing files: \");
      analysis-multiple-default-work-units; set-total-work-units;
      
      measure-time(
        measure-time(
          path'* := <map(\\p -> $[[project-path]/[p]]\\)> path*;
          (result*, evaluated-task*, skipped-task*, unevaluated-task*) := <analyze-multiple(parse; desugar-before, complete-work-unit|language, project-path)> path'*;
          (analysis-result*, debug-result*) := <unzip> result*
        , analysis-default-debug-time(!\"Time - analysis: \") | \"analysis-multiple-full-analysis\"
        );
        measure-time(
          analysis-result'* := <filter(analysis-update-editor(desugar-after, pp-message))> analysis-result*
          // TODO: Update markers for partitions that have had a task executed but were not analyzed.
        , analysis-default-debug-time(!\"Time - messages: \") | \"analysis-multiple-update-editors\"
        );
        measure-time(
          index-persist
        , analysis-default-debug-time(!\"Time - index persistance: \") | \"analysis-multiple-index-persist\"
        );
        measure-time(
          task-persist
        , analysis-default-debug-time(!\"Time - task engine persistance: \") | \"analysis-multiple-task-persist\"
        )       
      , analysis-default-debug-time(!\"Time - total: \") | \"analysis-multiple-total\"
      );
      measure-time(
        DebugResult(removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count) := <analysis-accumulate-debug-results> debug-result*;
        <analysis-debug-results> (removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count, evaluated-task*, skipped-task*, unevaluated-task*)
      , analysis-default-debug-time(!\"Time - debug: \") | \"analysis-multiple-debug\"
      )

  analysis-accumulate-debug-results = 
    !(<id>, DebugResult(0, 0, 0, 0, 0));
    foldl(analysis-concat-debug-result)
      
  analysis-concat-debug-result:
    (
      DebugResult(removed-entry1-count, added-entry1-count, removed-task1-count, added-task1-count, invalidated-task1-count)
    , DebugResult(removed-entry2-count, added-entry2-count, removed-task2-count, added-task2-count, invalidated-task2-count)
    )
    ->
    DebugResult(removed-entry-count, added-entry-count, removed-task-count, added-task-count, invalidated-task-count)
    with
      removed-entry-count    := <add> (removed-entry1-count, removed-entry2-count);
      added-entry-count      := <add> (added-entry1-count, added-entry2-count);
      removed-task-count     := <add> (removed-task1-count, removed-task2-count);
      added-task-count       := <add> (added-task1-count, added-task2-count);
      invalidated-task-count := <add> (invalidated-task1-count, invalidated-task2-count)

  analysis-update-editor(desugar-after, pp-message):
    Result(partition, initial-ast, analyzed-ast, changed-read*, error* , warning* , note*) -> 
    Result(partition, initial-ast, analyzed-desugared-ast, changed-read*, error'*, warning'*, note'*)
    where
      not(() := initial-ast)
    with
      analyzed-desugared-ast := <desugar-after> analyzed-ast;
      (error'*, warning'*, note'*) := <analysis-message-collect(pp-message|error*, warning*, note*)> analyzed-desugared-ast;
      <set-markers(|partition)> (analyzed-ast, error'*, warning'*, note'*)

  analysis-multiple-default-work-units = 
    length; !(<id>, 3); mul 
      
rules // Message collection and updating.
  
  constraint-error = fail
  constraint-warning = fail
  constraint-note = fail
  
  enable-wrapped-message-collect = fail
  message-collect-wrapped(s)     = fail
  
  analysis-message-collect(pp-message|analysis-error*, analysis-warning*, analysis-note*):
    ast -> ([<map(pp-message)> analysis-error*, error*], [<map(pp-message)> analysis-warning*, warning*], 
      [<map(pp-message)> analysis-note*, note*])
    with
      if enable-wrapped-message-collect then
        message-collect-wrapped(
          error*   := <collect-all(constraint-error, conc)> ast;
          warning* := <collect-all(constraint-warning, conc)> ast;
          note*    := <collect-all(constraint-note, conc)> ast
        )
      else
        error*   := <collect-all(constraint-error, conc)> ast;
        warning* := <collect-all(constraint-warning, conc)> ast;
        note*    := <collect-all(constraint-note, conc)> ast
      end
        
  
  analysis-message-update-partitions-queue(|language, project-path):
    partition* -> <queue-strategy(|\"analysis-message-update-partitions\", \"Updating messages\")> (partition*, language, project-path)
  
  analysis-message-update-partitions:
    (partition*, language, project-path) -> <filter(not(is-test-file); analysis-message-update-partition)> partition*
    with
      task-setup(|project-path);
      index-setup(|language, project-path)
    
  analysis-message-update-partition:
    partition -> <analyze-get-messages; set-only-markers(|partition)> partition
      
rules // On-save handler
  
  analysis-save-default(|language):
    (_, _, _, _, project-path) -> None()
    with
      index-setup(|language, project-path);
      index-persist;
      task-setup(|project-path);
      task-persist

rules // Debugging
  
  analysis-default-debug(msg) = try(analysis-default-debug-interface(msg))
  analysis-default-debug = try(analysis-default-debug-interface)
  analysis-default-debug-interface(msg) = fail
  analysis-default-debug-interface = fail
  
  analysis-default-debug-time(msg) = try(analysis-default-debug-time-interface(msg))
  analysis-default-debug-time = try(analysis-default-debug-time-interface)
  analysis-default-debug-time-interface(msg) = fail
  analysis-default-debug-time-interface = fail
  
  analysis-debug-results =
    ?(
        removed-entry-count
      , added-entry-count
      , removed-task-count
      , added-task-count
      , invalidated-task-count
      , evaluated-task*
      , skipped-task*
      , unevaluated-task*
    );
    <analysis-default-debug> $[Entries : [removed-entry-count] removed, [added-entry-count] added.];
    <analysis-default-debug> $[Tasks   : [removed-task-count] removed, [added-task-count] added, [invalidated-task-count] invalidated, [<length> evaluated-task*] evaluated, [<length> skipped-task*] skipped, [<length> unevaluated-task*] unevaluated.];
    <map(task-debug-info(|<id>); analysis-default-debug(!\"Unevaluated: \"))> unevaluated-task* 
  
"

  create-task-core = 
    <output-text-file(|["lib", "runtime", "task"], "core.str")>
"module runtime/task/core

imports 
  
  runtime/task/interface
  runtime/task/utils
  
signature

  sorts
  
    Result Instruction
  
  constructors
    
    Result : TaskID -> Result
    Fail   : Result
    
    Single     : List(Result) -> Result
    Dependency : List(TaskID) -> Result
    
rules // Creation
  
  tdebug(s) = id
  //tdebug(s) = debug(s)
  
  new-task(|partition) = new-task(|partition, <dependent-tasks>)
  new-task(|partition, dependencies):
    instruction -> result
    with
      is-combinator := <task-is-combinator; !1 <+ !0> instruction;
      short-circuit := <task-short-circuit; !1 <+ !0> instruction;
      result        := <task-add-task(|partition, dependencies, instruction, is-combinator, short-circuit)> instruction
 
  //    tdebug(!\"new task \")
  //  ; avoid-task(|dependencies)
  //  ; tdebug(!\"avoided \")
  // <+ task-add-task(|partition, dependencies, <id>)
  //  ; tdebug(!\"added \")
      
  dependent-tasks = collect-all(dependent-task, union); flatten-list; make-set
  dependent-task = ?Result(<id>) 
  dependent-task =
    has-annos; get-annos; dependent-tasks
    
  task-create-execute-ctx = !\"\"
  task-create-execute(create-task):
    term -> result
    with
      ctx := <task-create-execute-ctx>
    ; task-push
    ; task-start-collection(|ctx)
    ; Result(taskID) := <create-task> term
    ; task-stop-collection(|ctx)
    ; <task-evaluate-now> taskID
    ; result := <task-get-result> taskID
    ; task-pop

rules // Dependencies
  
  task-create-dependencies =
    collect-all-annos(?Result(<id>), union);
    !Dependency(<id>)

  task-create-dependency =
    !Dependency([<id>])
    
  task-has-dependencies =
    where(collect-one-annos(?Dependency(_)))
    
  task-collect-dependencies =
    collect-all-annos(?Dependency(<id>), union);
    concat;
    where(Hd);
    !Dependency(<id>)

rules // Results

  insert-results-hashmap(|results-hashmap) =
    switch id
      case has-annos  : ?t; !(<insert-results-hashmap-noannos(|results-hashmap)> t, <get-annos; insert-results-hashmap(|results-hashmap)> t); set-annos
      otherwise       : insert-results-hashmap-noannos(|results-hashmap)
    end
    
  insert-results-hashmap-noannos(|results-hashmap) =
    switch id
      case is-list    : filter(insert-results-hashmap(|results-hashmap))
      case ?Result(n) : try(<hashtable-get(|n)> results-hashmap)
      otherwise       : all(insert-results-hashmap(|results-hashmap))
    end
  
  insert-results-with-fail =
    switch id
      case has-annos  : !(<id>, <get-annos; insert-results-with-fail>); set-annos
      case is-list    : filter(insert-results-with-fail)
      case ?Result(n) : (task-api-get-results(|n) <+ (task-api-has-failed(|n); ![]) <+ with(fail|\"Cannot insert result: \"))
      otherwise       : all(insert-results-with-fail)
    end
  
  insert-results =
    switch id
      case has-annos  : !(<id>, <get-annos; insert-results>); set-annos
      case is-list    : map(insert-results)
      case ?Result(n) : task-api-get-results(|n) <+ (task-api-has-failed(|n); ![])
      otherwise       : all(insert-results)
    end
    
  insert-results-or-create-dependency =
    switch id
      case has-annos  : !(<id>, <get-annos; insert-results-or-create-dependency>); set-annos
      case is-list    : map(insert-results-or-create-dependency)
      case ?Result(n) : task-api-get-results(|n) <+ (task-api-has-failed(|n); ![]) <+ !Dependency([n])
      otherwise       : all(insert-results-or-create-dependency)
    end
  
rules // Projections
  
  task-result-id:
    Result(taskID) -> taskID

  task-collect-result-ids =
    collect-all-annos(task-result-id, union)

rules // API
  
  task-add-message(|taskID, message)                         = task-api-add-message(|taskID, message)
  task-add-task(|partition, dependencies, instruction, is-combinator, short-circuit) = task-api-add-task(|partition, dependencies, instruction, is-combinator, short-circuit)
  task-clear-partition                                       = task-api-clear-partition(|<id>)
  task-debug-info(|partition)                                = task-api-debug-info(|partition)
  task-evaluate-now                                          = task-api-evaluate-now(task-collect-result-ids, insert-results-hashmap, task-perform-task|<id>)
  task-evaluate-scheduled                                    = task-api-evaluate-scheduled(task-collect-result-ids, insert-results-hashmap, task-perform-task)
  task-get-messages(|partition)                              = task-api-get-messages(|partition)
  task-get-readers                                           = task-api-get-readers(|<id>)
  task-invalidate-task-reads(|changedRead*)                  = task-api-invalidate-task-reads(|changedRead*)
  task-merge                                                 = task-api-merge
  task-partitions-of(|taskIDOrTaskID*)                       = task-api-partitions-of(|taskIDOrTaskID*)
  task-persist                                               = task-api-persist
  task-pop                                                   = task-api-pop
  task-push                                                  = task-api-push
  task-recover                                               = task-api-recover
  task-reset                                                 = task-api-reset
  task-result-combinations                                   = task-api-result-combinations(task-collect-result-ids, insert-results-hashmap|<id>)
  task-setup(|project-path)                                  = task-api-setup(|project-path)
  task-setup                                                 = task-api-setup(|<id>)
  task-start-collection(|partition)                          = task-api-start-collection(|partition)
  task-stop-collection(|partition)                           = task-api-stop-collection(|partition)
  task-unload                                                = task-unload(|<id>)
  task-unload(|project-path)                                 = task-api-unload(|project-path)
  
  // TODO: rename to task-get-results.
  task-get-result =
    switch id
      case ?Result(taskID) : task-api-get-results(|taskID)
      otherwise            : task-api-get-results(|<id>)
    end
  
  task-has-failed =
    switch id
      case ?Result(taskID) : task-api-has-failed(|taskID)
      otherwise            : task-api-has-failed(|<id>)
    end
    
  task-get-solved =
    switch id
      case ?Result(taskID) : task-api-get-results(|taskID) <+ (task-api-has-failed(|taskID); ![])
      otherwise            : task-api-has-failed(|<id>) <+ (task-api-has-failed(|<id>); ![])
    end
        
  task-get-dependencies:
    taskID -> <task-api-get-dependencies(|taskID)>
        
  task-add-read(|taskID):
    read -> <task-api-add-read(|taskID, read)>

  task-perform-task(|nr) = perform-task(|nr)

rules /** @internal API externals */

  task-api-add-message(|taskID, message) = prim(\"task_api_add_message\", taskID, message)
  task-api-add-read(|taskID, read) = prim(\"task_api_add_read\", taskID, read)
  task-api-add-task(|partition, dependencies, instruction, is-combinator, short-circuit) = prim(\"task_api_add_task\", partition, dependencies, instruction, is-combinator, short-circuit)
  task-api-clear-partition(|partition) = prim(\"task_api_clear_partition\", partition)
  task-api-debug-info(|partition) = prim(\"task_api_debug_info\", partition)
  task-api-evaluate-now(collect, insert, perform|taskIDs) = prim(\"task_api_evaluate_now\", collect, insert, perform|taskIDs)
  task-api-evaluate-scheduled(collect, insert, perform|) = prim(\"task_api_evaluate_scheduled\", collect, insert, perform|)
  task-api-get-dependencies(|taskID) = prim(\"task_api_get_dependencies\", taskID)
  task-api-get-messages(|partition) = prim(\"task_api_get_messages\", partition)
  task-api-get-readers(|uri) = prim(\"task_api_get_readers\", uri)
  task-api-get-results(|taskID) = prim(\"task_api_get_results\", taskID)
  task-api-has-failed(|taskID) = prim(\"task_api_has_failed\", taskID)
  task-api-invalidate-task-reads(|changedReads) = prim(\"task_api_invalidate_task_reads\", changedReads)
  task-api-merge = prim(\"task_api_merge\")
  task-api-partitions-of(|taskIDOrTaskIDS) = prim(\"task_api_partitions_of\", taskIDOrTaskIDS)
  task-api-persist = prim(\"task_api_persist\")
  task-api-pop = prim(\"task_api_pop\")
  task-api-push = prim(\"task_api_push\")
  task-api-recover = prim(\"task_api_recover\")
  task-api-reset = prim(\"task_api_reset\")
  task-api-result-combinations(collect-results, insert-results|term) = prim(\"task_api_result_combinations\", collect-results, insert-results|term)
  task-api-setup(|project-path) = prim(\"task_api_setup\", project-path)
  task-api-start-collection(|partition) = prim(\"task_api_start_collection\", partition)
  task-api-stop-collection(|partition) = prim(\"task_api_stop_collection\", partition)
  task-api-unload(|project-path) = prim(\"task_api_unload\", project-path)
  
"

  create-task-messages = 
    <output-text-file(|["lib", "runtime", "task"], "messages.str")>
"module runtime/task/messages

imports
  
  runtime/task/core
  runtime/editor/origins
  
signature

  sorts
  
    Message
    MessageTrigger
    
  constructors
    
    Error   : Origin * Term * Msg -> Message
    Warning : Origin * Term * Msg -> Message
    Note    : Origin * Term * Msg -> Message
    
    Failure  : MessageTrigger // No results
    Success  : MessageTrigger // At least one result
    Multiple : MessageTrigger // More than one result

    Message  : Result * List(Result) * MessageTrigger * Term -> Instruction

overlays
  
  MISSING_ORIGIN = \"MISSING ORIGIN INFORMATION\"

rules // message creation
  
  task-error-message(|message):
    term -> Error(<task-message-origin-location-offset> term, term, message)
    
  task-warning-message(|message):
    term -> Warning(<task-message-origin-location-offset> term, term, message)
    
  task-note-message(|message):
    term -> Note(<task-message-origin-location-offset> term, term, message)

rules // querying
  
  task-message:
    Error(_, _, message) -> message

  task-message:
    Warning(_, _, message) -> message
    
  task-message:
    Note(_, _, message) -> message


  task-message-term:
    Error(_, term, _) -> term

  task-message-term:
    Warning(_, term, _) -> term
    
  task-message-term:
    Note(_, term, _) -> term
    

  task-message-origin:
    Error(origin, _, _) -> origin

  task-message-origin:
    Warning(origin, _, _) -> origin
    
  task-message-origin:
    Note(origin, _, _) -> origin
  
rules // task creation
  
  task-create-message-on-failure(|partition, task, exclude*):
    message -> <new-task(|partition)> Message(task, exclude*, Failure(), message)
  
  task-create-error-on-failure(|partition, task, exclude*, message) = 
    task-error-message(|message); task-create-message-on-failure(|partition, task, exclude*)
  task-create-error-on-failure(|partition, task, message) = 
    task-create-error-on-failure(|partition, task, [], message)
      
  task-create-warning-on-failure(|partition, task, exclude*, message) =
    task-warning-message(|message); task-create-message-on-failure(|partition, task, exclude*)
  task-create-warning-on-failure(|partition, task, message) =
    task-create-warning-on-failure(|partition, task, [], message)
    
  task-create-note-on-failure(|partition, task, exclude*, message) =
    task-note-message(|message); task-create-message-on-failure(|partition, task, exclude*)
  task-create-note-on-failure(|partition, task, message) =
    task-create-note-on-failure(|partition, task, [], message)    
      
      
  task-create-message-on-success(|partition, task, exclude*):
    message -> <new-task(|partition)> Message(task, exclude*, Success(), message)
  
  task-create-error-on-success(|partition, task, exclude*, message) = 
    task-error-message(|message); task-create-message-on-success(|partition, task, exclude*)
  task-create-error-on-success(|partition, task, message) = 
    task-create-error-on-success(|partition, task, [], message)
    
  task-create-warning-on-success(|partition, task, exclude*, message) =
    task-warning-message(|message); task-create-message-on-success(|partition, task, exclude*)
  task-create-warning-on-success(|partition, task, message) =
    task-create-warning-on-success(|partition, task, [], message)
    
  task-create-note-on-success(|partition, task, exclude*, message) =
    task-note-message(|message); task-create-message-on-success(|partition, task, exclude*)
  task-create-note-on-success(|partition, task, message) =
    task-create-note-on-success(|partition, task, [], message)
    
    
  task-create-message-on-multiple(|partition, task, exclude*):
    message -> <new-task(|partition)> Message(task, exclude*, Multiple(), message)
  
  task-create-error-on-multiple(|partition, task, exclude*, message) = 
    task-error-message(|message); task-create-message-on-multiple(|partition, task, exclude*)
  task-create-error-on-multiple(|partition, task, message) =
    task-create-error-on-multiple(|partition, task, [], message)
    
  task-create-warning-on-multiple(|partition, task, exclude*, message) =
    task-warning-message(|message); task-create-message-on-multiple(|partition, task, exclude*)
  task-create-warning-on-multiple(|partition, task, message) =
    task-create-warning-on-multiple(|partition, task, [], message)
    
  task-create-note-on-multiple(|partition, task, exclude*, message) =
    task-note-message(|message); task-create-message-on-multiple(|partition, task, exclude*)
  task-create-note-on-multiple(|partition, task, message) =
    task-create-note-on-multiple(|partition, task, [], message)

rules // task execution
  
  task-is-combinator = ?Message(_, _, _, _)

  perform-task(|n):
    Message(task, exclude*, trigger, message) -> []
    where
      <map(not(?[]))> exclude*;
      switch !trigger
        case ?Failure()  : not(<Hd> task); task-add-message(|n, message)
        case ?Success()  : <Hd> task; task-add-message(|n, message)
        case ?Multiple() : <Tl; Hd> task; task-add-message(|n, message)
      end

rules
  
  task-message-origin-location-offset:
    term -> <origin-location-offset <+ MISSING_ORIGIN()> term
    where
      not(<is-list> term)
    
  task-message-origin-location-offset:
    list -> location-offset
    where
      <is-list> list;
      (
        (partition, line, column, start-offset, _) := <Hd; origin-location-offset> list;
        (_, _, _, _, end-offset)                   := <last; origin-location-offset> list;
        location-offset := (partition, line, column, start-offset, end-offset)
      ) <+
        location-offset := MISSING_ORIGIN()

"

  create-task-new-messages = 
    <output-text-file(|["lib", "runtime", "task"], "new-messages.str")>
"module runtime/task/new-messages

imports
  
  runtime/task/core
  runtime/editor/origins
  runtime/task/messages
  
signature

  sorts
  
    Message
    MessageTrigger
    
  constructors
    
    Error   : Origin * Term * Msg -> Message
    Warning : Origin * Term * Msg -> Message
    Note    : Origin * Term * Msg -> Message
    
    Failure  : List(Result) -> MessageTrigger // No results
    Success  : List(Result) -> MessageTrigger // At least one result
    Multiple : List(Result) -> MessageTrigger // More than one result

    Message  : MessageTrigger * Term -> Instruction

rules // task creation
  
  task-create-message-on-triggers(|partition, triggers):
    message -> <new-task(|partition)> Message(triggers, message)
  
  task-create-error-on-triggers(|partition, triggers, message) = 
    task-error-message(|message); task-create-message-on-triggers(|partition, triggers)
    
  task-create-warning-on-triggers(|partition, triggers, message) =
    task-warning-message(|message); task-create-message-on-triggers(|partition, triggers)
    
  task-create-note-on-triggers(|partition, triggers, message) =
    task-note-message(|message); task-create-message-on-triggers(|partition, triggers)
  
rules // task execution
  
  task-is-combinator = ?Message(_, _)

  perform-task(|n):
    Message(trigger*, message) -> []
    where
      <map(?Failure([]) + ?Success([_|_]) + ?Multiple([_, _|_]))> trigger*
    where
      task-add-message(|n, message)

"

  create-task-utils = 
    <output-text-file(|["lib", "runtime", "task"], "utils.str")>
"module runtime/task/utils

rules

  oncetd-annos(s) = s <+ has-annos; get-annos; one(oncetd-annos(s)) <+ one(oncetd-annos(s))
  
  collect-one-annos(s) = oncetd-annos(s; ?t); !t
  
  crush-annos(nul, sum, s) :
    _#(xs){a*} -> r2
    where
     r1 := <foldr(nul, sum, s)> xs;
     r2 := <foldr(!r1, sum, s)> a*

  collect-all-annos(s, un) =
    ![<s> | <crush-annos(![], un, collect-all-annos(s, un))>]
  <+ crush-annos(![], un, collect-all-annos(s, un))

"

  create-task-interface = 
    <output-text-file(|["lib", "runtime", "task"], "interface.str")>
"module runtime/task/interface

strategies
  
  perform-task(|nr)  = fail
  task-rewrite       = fail
  task-match         = fail
  avoid-task(|dep*)  = fail
  task-is-combinator = fail
  task-short-circuit = fail

"

  create-task-debug = 
    <output-text-file(|["lib", "runtime", "task"], "debug.str")>
"module runtime/task/debug

imports
  
  runtime/task/core

signature

  constructors
    
    Debug : Term * Term -> Instruction

rules
  
  task-transitive-dependencies = task-transitive-dependencies(|[])
  
  task-transitive-dependencies(|seen):
    taskID -> [dep*, trans-dep*]
    where
      not(<elem> (taskID, seen));
      dep*       := <task-get-dependencies> taskID;
      trans-dep* := <mapconcat(task-transitive-dependencies(|[taskID|seen]))> dep*
      
  task-transitive-dependencies(|seen):
    taskID -> []
    where
      <elem> (taskID, seen)
      
rules
  
  task-debug-ast:
    ast -> debug*
    with
      resultID* := <task-collect-result-ids> ast;
      dep*      := <mapconcat(task-transitive-dependencies)> resultID*;
      debug*    := <make-set; map(task-debug-info(|<id>))> [resultID*, dep*]

rules
  
  task-debug(|ctx):
    term -> <new-task(|ctx)> Debug(\"\", term)
    
  task-debug(|ctx, prefix):
    term -> <new-task(|ctx)> Debug(prefix, term)
    
  task-is-combinator = ?Debug(_, _)

  perform-task(|nr):
    Debug(prefix, term) -> <debug(!$[[nr] - [prefix]]); !term> msg
    with
      if <?[]> term then
        msg := \"FAIL\"
      else
        msg := term
      end
    
"

  create-task-tasks = 
    <output-text-file(|["lib", "runtime", "task"], "tasks.str")>
"module runtime/task/tasks

imports
  
  runtime/task/core
  runtime/task/messages
  runtime/task/interface
  
signature

  constructors
    
    Id       : Term              -> Instruction
    Choice   : List(List(Term))  -> Instruction
    Sequence : List(Term)        -> Instruction
    Combine  : List(Term)        -> Instruction
    Collect  : List(Term)        -> Instruction
    Not      : Result            -> Instruction
    Index    : Int * List(Term)  -> Instruction
    Length   : List(Term)        -> Instruction
    Insert   : Term              -> Instruction
    Rewrite  : ID * Term         -> Instruction

rules // Identity
  
  /**
  * Create an identity task
  * @type term -> Result(Int)
  */
  task-create-id(|ctx) = <new-task(|ctx)> Id(<id>)
  
  task-create-id(|ctx, dep*) =
    ?term;
    all-dep* := <union> (<dependent-tasks> dep*, <dependent-tasks>);
    <new-task(|ctx, all-dep*)> Id(term)
  
  perform-task(|nr) = ?Id(<MkSingleton>)

rules // Choice
  
  /**
  * Create a choice task
  * @type List(task) -> Result(Int)
  */
  task-create-choice(|ctx) = <new-task(|ctx)> Choice(<id>)
  
  /**
  * Create a choice task between two tasks, where t1 and t2 take a ctx and produce a task.
  * @type term -> Result(Int)
  */
  task-create-choice(t1, t2|ctx):
    term -> <task-create-choice(|ctx)> [<t1(|ctx)> term, <t2(|ctx)> term]
  
  task-is-combinator = ?Choice(_)
  perform-task(|nr)  = ?Choice(<fetch-elem(not(?[]))>)
  
rules // Sequence
  
  /**
  * Create a sequence task
  * @type List(task) -> Result(Int)
  */
  task-create-sequence(|ctx) = <new-task(|ctx)> Sequence(<id>)

  /**
  * Create a sequence task between two tasks, where t1 and t2 take a ctx and produce a task.
  * @type term -> Result(Int)
  */
  task-create-sequence(t1, t2|ctx):
    term -> <task-create-sequence(|ctx)> [<t1(|ctx)> term, <t2(|ctx)> term]
  
  task-is-combinator = ?Sequence(_)
  perform-task(|nr)  = ?Sequence(<not(fetch-elem(?[])); last>)

rules // Combine
       
  /**
  * Create a combine task
  * @type List(task) -> Result(Int)
  */
  task-create-combine(|ctx)= <new-task(|ctx)> Combine(<id>)
       
  task-is-combinator = ?Combine(_)
  perform-task(|nr)  = ?Combine(<map(is-list <+ MkSingleton)>); concat

rules // Collect
       
  /**
  * Create a collect task
  * @type List(task) -> Result(Int)
  */
  task-create-collect(|ctx) = <new-task(|ctx)> Collect(<id>)
       
  task-is-combinator = ?Collect(_)
  perform-task(|nr)  = ?Collect(<map(is-list <+ MkSingleton)>); concat; MkSingleton

rules // Where
  
  task-create-where(s|ctx):
    term -> <task-create-sequence(|ctx)> <try(flatten-list)> [<s> term, term]

rules // Negation
  
  /**
  * Create negation task
  * @type task -> Result(Int)
  */
  task-create-not(|ctx) = <new-task(|ctx)> Not(<id>)
  
  /**
  * Create negation task, where t takes a ctx argument and produces the task to be negated 
  */
  task-create-not(t|ctx) = t(|ctx); task-create-not(|ctx)
  
  /**
  * Negation on the success of a task
  * @type: Not(result) -> !Success(result)
  */
  perform-task(|nr):
    Not(result) -> ()
    where
      <?[]> result
      
  task-is-combinator = ?Not(_)
  
rules // Index
  
  perform-task(|nr) = ?Index(i, <index(|i)>);  MkSingleton
  
rules // Length
  
  perform-task(|nr) = ?Length(<length>);  MkSingleton

rules // Result insertion
  
  task-create-insert(|ctx):
    term -> <new-task(|ctx)> Insert(term)
  
  perform-task(|nr):
    Insert(term) -> result
    where
      inserted := <insert-results-or-create-dependency> term
    ; result   := <try(task-has-dependencies; task-collect-dependencies)> inserted
      
  task-is-combinator = ?Insert(_)
  
rules // General purpose rewrite
        
  /**
  * Create a rewrite task
  * @type term -> Result(Int)
  */
  task-create-rewrite(|ctx, key):
    term -> <new-task(|ctx)> Rewrite(key, term)
        
  perform-task(|nr) = ?Rewrite(key, term); <task-rewrite; MkSingleton> (key, term)
  
rules // Cyclic task execution
  
  perform-cyclic-task(|nr) = fail
  
  perform-task(|nr):
    (instruction, \"cyclic\") -> <perform-cyclic-task(|nr) <+ perform-task(|nr)> instruction

"

  create-index-globals = 
    <output-text-file(|["lib", "runtime", "index"], "globals.str")>
"module runtime/index/globals

imports

  runtime/index/core
  runtime/index/query
  
signature 

  constructors
    
    Global : URI               -> Entry
    Global : URI * List(Entry) -> Entry
    
rules
    
  /**
   * Gets the 'fake' path where globals are stored in the index.
   *
   * @internal
   */
  index-globals-path:
    names -> <separate-by(|\"/\"); concat-strings> path
    with
      if is-list then
        path := <concat> [names, [\"globals\", \".internal\"]]
      else
        path := [names, \"global\", \".internal\"]
      end
    
  /**
   * Gets the URI where globals are stored in the index for given name or names.
   *
   * @internal
   * @type name or List(name) -> uri
   */
  index-globals-uri:
    names -> uri
    with
      if is-list then
        uri := <concat> [names, [\"globals\", \".internal\"]]
      else
        uri := [names, \"global\", \".internal\"]
      end
    
  /**
   * Gets the first value in global storage with given name, or fail.
   *
   * Example:
   *   index-get-global(|\"last-compile\") => Timestamp(1334322856)
   *   index-get-global(|[\"last-compile\", \"file.str\"]) => Timestamp(1334322856)
   * 
   * @param name  The name or list of names to identify the global value.
   * @type _ -> ?value
   */
  index-get-global(|name):
    _ -> value
    where
      Global(_, value) := <index-get-all; Hd> Global(<index-globals-uri> name, ())
    
  /**
   * Gets all values in global storage with given name.
   *
   * Example:
   *   index-get-global(|\"last-compile\") => [Timestamp(1334322856), ...]
   *   index-get-global(|[\"last-compile\", \"file.str\"]) => [Timestamp(1334322856), ...]
   *
   * @param name  The name or list of names to identify the global value.
   * @type _ -> List(value)
   */ 
  index-get-all-globals(|name):
    _ -> values'
    with
      values  := <index-get-all> Global(<index-globals-uri> name, ());
      values' := <filter(?Global(_, <id>))> values
    
  /**
   * Add value to global storage with given name.
   *
   * Example:
   *   <index-add-global(|\"last-compile\")> Timestamp(1334322856)
   *   <index-add-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-add-global(|name):
    value -> <id>
    with
      <index-add(|<index-globals-path>)> Global(<index-globals-uri> name, value)
      
  /**
   * Overwrites value in global storage with given value.
   *
   * Example:
   *   <index-set-global(|\"last-compile\")> Timestamp(1334322856)
   *   <index-set-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-set-global(|name):
    value -> <id>
    with
      index-clear-global(|name);
      <index-add-global(|name)> value
    
  /**
   * Removes all values from global storage with given name.
   *
   * Example:
   *   index-clear-global(|\"last-compile\")
   *   index-clear-global(|[\"last-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global value.
   * @type x -> x
   */   
  index-clear-global(|name):
    _ -> <id>
    with
      <index-globals-path; index-clear-partition> name
rules
  
  /**
   * Gets the 'fake' path where boolean globals are stored in the index.
   *
   * @internal
   */
  index-boolean-globals-path:
    names -> <separate-by(|\"/\"); concat-strings> path
    with
      if is-list then
        path := <concat> [names, [\"boolean\", \"globals\", \".internal\"]]
      else
        path := [names, \"boolean\", \"global\", \".internal\"]
      end
        
  /**
   * Gets the URI where boolean globals are stored in the index for given name or names.
   *
   * @internal
   */
  index-boolean-globals-uri:
    names -> uri
    with
      if is-list then
        uri := <concat> [names, [\"boolean\", \"globals\", \".internal\"]]
      else
        uri := [names, \"boolean\", \"global\", \".internal\"]
      end
      
  /**
   * Sets boolean value true to global boolean storage with given name.
   *
   * Example:
   *   index-enable-global(|\"can-compile\")
   *   index-enable-global(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> x
   */   
  index-enable-global(|name):
    _ -> <id>
    with
      <index-add(|<index-globals-path>)> Global(<index-boolean-globals-uri> name)
      
  /**
   * Sets boolean value false to global boolean storage with given name.
   *
   * Example:
   *   index-disable-global(|\"can-compile\")
   *   index-disable-global(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> x
   */   
  index-disable-global(|name):
    _ -> <id>
    with
      <index-boolean-globals-path; index-clear-partition> name
      
  /**
   * Query for boolean value true in global boolean storage with given name.
   *
   * Example:
   *   index-is-global-enabled(|\"can-compile\")
   *   index-is-global-enabled(|[\"can-compile\", \"file.str\"])
   *
   * @param name  The name or list of names to identify the global boolean value.
   * @type x -> ?x
   */   
  index-is-global-enabled(|name):
    _ -> <id>
    where
      <index-get-all; Hd> Global(<index-boolean-globals-uri> name)

"

  create-index-legacy = 
    <output-text-file(|["lib", "runtime", "index"], "legacy.str")>
"module runtime/index/legacy

imports
  
  runtime/index/core
  runtime/index/utils

rules // Redirects
  
  index-setup(|language, project-path, current-partition) =
    index-setup(|language, <index-setup-paths> project-path)
    
  index-clear = index-reset
  index-clear-all = index-reset
  
  index-commit = index-persist
    
rules // Deprecated
    
  index-depricated-switch = fail
  index-depricated = try(not(index-depricated-switch); with(fail|\"Deprecated.\"))
    
  index-get-all-with-partitions = index-depricated
    
  index-remove(|partition) = index-depricated
    
  index-remove-all = index-depricated
    
  index-remove-one = index-depricated
  
  index-get-current-partition = index-depricated
  
  index-set-current-partition = index-depricated
  
  index-get-partition-revision = index-depricated
    
  index-start-transaction = index-depricated
  
  index-end-transaction = index-depricated
  
  index-transaction(s) = index-depricated; s

"

  create-index-core = 
    <output-text-file(|["lib", "runtime", "index"], "core.str")>
"module runtime/index/core

imports
  
  runtime/index/utils

signature

  sorts
  
    URI Entry
  
rules

  /**
   * Sets up the index library for given language, project paths and current file.
   * Must be called once before doing anything with the library.
   *
   * Example:
   *   <index-setup(|\"MiniJava\", <project-path>)
   *
   * @param language          The language to set the index up for.
   * @param project-path      The project path that contains all source files to analyse.
   * @type x -> x
   */
  index-setup(|language, project-path) =
    prim(\"LANG_index_setup_new\", language, <index-setup-paths> project-path)
    
  index-setup:
    (language, project-path) -> <prim(\"LANG_index_setup_new\", language, <index-setup-paths> project-path)>
    
  /**
   * Unloads the currently loaded index.
   *
   * Example:
   *   index-unload(|<project-path>)
   *
   * @param project-path The project path that contain all source files to analyse and compile.
   *
   * @type x -> x
   */
  index-unload(|project-path) =
    prim(\"LANG_index_unload\", project-path)

  /**
   * Tries to recover the index from an invalid state, for example after a crash.
   */
  index-recover =
    prim(\"LANG_index_recover\")
    
  /**
   * Starts collection for given partition. Used in conjunction with index-stop-collection to 
   * retrieve a list of added and removed index entries in relation to the previous entries in
   * given partition.
   *
   * Example:
   *   index-start-collection(|\"fullpath/file.ext\")
   *   index-start-collection(|(\"fullpath/file.ext\", \"subfile\"))
   *
   * @type x -> x
   */
  index-start-collection(|partition) =
    prim(\"LANG_index_start_collection\", partition)
    
  /**
   * Stops collection for the partition on which index-start-collection was called. Returns 
   * a tuple with removed and added entries in relation to the previous entries in that partition.
   *
   * Example:
   *   index-stop-collection => (removed, added)
   *
   * @type x -> (List(elem), List(elem))
   */
  index-stop-collection =
    prim(\"LANG_index_stop_collection\")
  
  /**
   * Pushes a new index on the stack and sets that as the current index. Entries from the parent
   * index are still visible, but additions only apply to the current index. Clearing a partition
   * also hides all entries in that partition from the parent index.
   *
   * Example:
   *   index-push
   *
   * @type x -> x 
   */ 
  index-push = 
    prim(\"LANG_index_push\")

  /**
   * Pops the current index from the stack and sets the parent index as the current index. All
   * modifications from the current index are discarded. The root index cannot be popped.
   *
   * Example:
   *   index-pop
   *
   * @type x -> x 
   */ 
  index-pop = 
    prim(\"LANG_index_pop\")

  /**
   * Pops the current index from the stack and sets the parent index as the current index. All
   * modifications from the current index are merged into the parent index; partitions that were
   * cleared in the current index are cleared in the parent, and entries added to the current
   * index are also added to the parrent. The root index cannot be merged.
   *
   * Example:
   *   index-merge
   *
   * @type x -> x 
   */ 
  index-merge = 
    prim(\"LANG_index_merge\")
    
  /**
   * Adds given element to the index.
   *
   * Example:
   *   <index-add(|\"fullpath/file.ext\")> Def([Entity(), \"Bar\"])
   *   <index-add(|(\"fullpath/file.ext\", \"subfile\"))> Def([Entity(), \"Bar\"])
   *
   * @param partition The partition to add the element to.
   * @type x -> ?x
   */
  index-add(|partition) =
    prim(\"LANG_index_add\", <id>, partition)

  /**
   * Adds all given elements to the index.
   *
   * Example:
   *   <index-add-all(|\"fullpath/file.ext\")> [Def([Entity(), \"Bar\"]), ...]
   *   <index-add-all(|(\"fullpath/file.ext\", \"subfile\"))> [Def([Entity(), \"Bar\"]), ...]
   *
   * @param partition The partition to add the elements to.
   * @type List(x) -> ?List(x)
   */
  index-add-all(|partition) =
    list-loop(with(index-add(|partition)))
    
  /**
   * Removes all elements from the index that are contained in given partition.
   *
   * Example:
   *   <index-clear-partition> \"fullpath/file.ext\"
   *   <index-clear-partition> (\"fullpath/file.ext\", \"subfile\")
   *
   * @type x -> ?x
   */
  index-clear-partition = 
    prim(\"LANG_index_clear_partition\", <id>)
    
  /**
   * Removes all elements from the index.
   *
   * @type x -> x
   */
  index-reset = 
    prim(\"LANG_index_clear_all\")
    
  /**
   * Removes all elements from the index and re-analyzes all partitions in the project.
   *
   * @type x -> x
   */
  index-reload = 
    prim(\"LANG_index_reload\")
   
  /**
   * Persists index to a cache on disk.
   *
   * @type x -> x
   */
  index-persist = 
    prim(\"LANG_index_persist\")

"

  create-index-query = 
    <output-text-file(|["lib", "runtime", "index"], "query.str")>
"module runtime/index/query

rules

  /**
   * Get all index entries that match the given template.
   *
   * Example:
   *   <index-get-all> Def([Entity(), \"Bar\"]) => [Def([Entity(), \"Bar\"]), ...]
   *
   * @type template -> List(elem)
   */
  index-get-all:
    template -> <prim(\"LANG_index_get\", template)>

  /**
   * Get all children entries of the given template.
   *
   * Example:
   *   <index-get-children> Def([Entity(), \"Bar\", \"Foo\"]) => [Def([Method(), \"Bar\"]), Def([Field(), \"Baz\"]), ...]
   *
   * @type template -> List(elem)
   */    
  index-get-children:
    template -> <prim(\"LANG_index_get_children\", template)>
  
  /**
   * Gets a list of all partitions for current project.
   *
   * Example:
   *   <index-get-all-partitions> => [(\"fullpath/file.ext\", \"subfile\"), ...]
   *
   * @type x -> List(partition)
   */   
  index-get-all-partitions =
    prim(\"LANG_index_all_partitions\")
  
  /**
   * Gets all index entries for the given partition.
   *
   * Examples:
   *   <index-get-all-in-partition> \"fullpath/file.ext\" => [Def([Entity(), \"Bar\"]), ...]
   *   <index-get-all-in-partition> (\"fullpath/file.ext\", \"subfile\") => [Def([Entity(), \"Bar\"]), ...]
   *
   * @type partition -> List(elem)
   */  
  index-get-all-in-partition =
    prim(\"LANG_index_get_all_in_partition\", <id>)

  /**
   * Gets the containing partitions of index entry with given template.
   *
   * Example:
   *   <index-get-partitions-of> Def([Entity(), \"Bar\"]) => [(\"fullpath/file.ext\", \"subfile\"), ...]
   *
   * @type template -> List(partition)
   */  
  index-get-partitions-of:
    template -> <prim(\"LANG_index_get_partitions_of\", template)>

"

  create-index-partition = 
    <output-text-file(|["lib", "runtime", "index"], "partition.str")>
"module runtime/index/partition

rules // Construction
  
  index-create-partition(|file) =
    !file
    
  index-create-partition(|file, uri) =
    !(file, uri)

rules // Projections
  
  index-partition-file:
    (file, _) -> file
    
  index-partition-file:
    file -> file
    where
      <is-string> file
    
  index-partition-uri:
    (_, uri) -> uri
"

  create-index-utils = 
    <output-text-file(|["lib", "runtime", "index"], "utils.str")>
"module runtime/index/utils

rules
  
  index-setup-paths = try(is-list; Hd)
"

  create-tmpl-pp = 
    <output-text-file(|["lib", "runtime", "tmpl"], "pp.str")>
"module runtime/tmpl/pp

imports
  libstratego-lib
  libstratego-gpp

signature constructors

  Parenthetical : Unknown -> Unknown

strategies

  // Unwrap Parenthetical/1 if pp fails, in case the user is using
  // parenthesize, but grammar does not contain {bracket} production.
  pp-one(pp) = (pp <+ ?Parenthetical(<pp>)); filter(gpp-is-real-vbox)

  pp-one-V(pp) = pp-one(pp); (?[] <+ !V([], <id>))
  pp-one-Z(pp) = pp-one(pp); (?[] <+ !Z([], <id>))

  pp-option(pp) = \\None() -> []\\ + ?Some(<pp>)

  pp-V-list(pp)    = ?[] <+ !V([], <map(pp-one-V(pp))>)
  pp-V-list(pp|vs) = ?[] <+ !V([SOpt(VS(), vs)], <map(pp-one-V(pp))>)
  pp-V-list(pp|vs, sep) = ?[] <+ !V([SOpt(VS(), vs)], <map(pp-one-V(pp)); at-init(add-sep(|sep), id)>)

  pp-indent(|is) = filter(gpp-is-real-vbox); (?[] <+ !I([SOpt(IS(), is)], H([SOpt(HS(), \"0\")], <id>)))

  pp-H-list(pp)     = ?[] <+ !H([], <map(pp-one-Z(pp))>)
  pp-H-list(pp|sep) = ?[] <+ !H([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

  pp-HV-list(pp)     = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
  pp-HV-list(pp|sep) = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

  pp-HZ-list(pp)     = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
  pp-HZ-list(pp|sep) = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

rules
  
  add-sep(|sep):
    V(a, [b]) -> V(a, [b-with-sep])
    where
      (c, [d, e]) := <explode-term> b;
      b-with-sep := <mkterm> (c, [d, <conc> (e, [S(sep)])])

"

create-all-runtime-libraries = 
  create-nabl-lookup
;   create-nabl-query
;   create-nabl-uri
;   create-nabl-constraints
;   create-nabl-incremental
;   create-nabl-namegen
;   create-nabl-check
;   create-nabl-utils
;   create-nabl-resolve
;   create-nabl-interface
;   create-nabl-tasks
;   create-nabl-complete
;   create-nabl-entries
;   create-nabl-collect
;   create-editor-interop
;   create-editor-queue
;   create-editor-positions
;   create-editor-origins
;   create-editor-annotations
;   create-editor-outline-library
;   create-editor-editor
;   create-modelware-model2tree
;   create-modelware-signatures
;   create-modelware-tree2model
;   create-relations-query
;   create-relations-interface
;   create-relations-tasks
;   create-relations-entries
;   create-properties-query
;   create-properties-eq
;   create-properties-interface
;   create-properties-tasks
;   create-properties-entries
;   create-properties-collect
;   create-types-query
;   create-types-interface
;   create-types-collect
;   create-analysis-core
;   create-analysis-resolve
;   create-analysis-interface
;   create-analysis-debug
;   create-analysis-reanalysis
;   create-analysis-multiple
;   create-analysis-single
;   create-analysis-complete
;   create-analysis-defaults
;   create-task-core
;   create-task-messages
;   create-task-new-messages
;   create-task-utils
;   create-task-interface
;   create-task-debug
;   create-task-tasks
;   create-index-globals
;   create-index-legacy
;   create-index-core
;   create-index-query
;   create-index-partition
;   create-index-utils
;   create-tmpl-pp
