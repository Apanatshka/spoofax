module sdf2imp/util/construct-text

imports
	libstratego-lib 
	libstratego-gpp
	sdf2imp/util/layout-adaption
	sdf2imp/util/origin-tracking

signature constructors
  Parenthetical : Unknown -> Unknown

rules //Parenthetical

  origin-indent = ?Parenthetical(<origin-indent>)

rules //pp rules for default nodes 
	  
  pp-default(pp):
  	Parenthetical(node) -> <concat-strings> ["(", <pp> node, ")"]
  
  pp-default(pp):
  	None() -> ""

  pp-default(pp):
  	Some(x) -> <pp> x

  //pp-default(pp): amb([h|tail])

  pp-default(pp) = is-string

  pp-default(pp) = int-to-string
  
rules //interface

// backwards compatibility
//TODO: change refactoring esv, geen pp-table meer
construct-textual-change(pp|pp-table)=
	construct-textual-change(pp <+ (ast2abox(|[pp-table]); box2text-string(|100)))

/*
 * Constructs the textual change associated with 
 * the transformation that replaces a (sub)term 'oldnode' with a new (sub)term 'newnode'.
 * @param custom pp strategy used to construct the text fragment for nodes that miss origin information
 * pp strategy is assumed to be homomorphic (except for lists separators that require parent node information)
 * @type (original-node, new-node) -> (Int,Int, String)
 */	
construct-textual-change(pp):
	t@(oldnode, newnode) -> (start-offset, end-offset, newText)
	where
		<is-tuple> t;
		<has-origin-term> oldnode		
	with
		reconstructed-text := <topdown(try(strip-annos)); construct-text-from-old(pp)> (oldnode, newnode); 
		r-text := <origin-set-relation>(newnode, reconstructed-text);
		(start-offset, end-offset, newText) := <ast-change-to-text-change(pp)> REPLACEMENT(oldnode, r-text)
		

construct-textual-change(pp):
	t@(oldnode, newnode) -> (0, 0, "")
	where
		<is-tuple> t;
		<equal> (oldnode, newnode)

construct-textual-change(pp) =
	map(construct-textual-change(pp))

//treat olnode as a candidate origin term to protect against loss of origin (and to preserve sugar in first diff)
construct-text-from-old(pp):
	(oldnode, newnode) -> reconstructed-text
	where
		reconstructed-text := <construct-text-from-origin(pp)> (oldnode, newnode) <+ //possible desugared
		reconstructed-text := <construct-text-from-origin(pp)> (<where(not(is-origin-term)); origin-term> oldnode, newnode) <+
		reconstructed-text := <construct-text(pp)> newnode

rules //text-reconstruction

construct-text(pp) = 
	pp-default(construct-text(pp)) <+ //Parenthesis, None, ...
	construct-text-from-origin-desugared(pp) <+
	construct-text-from-origin(pp) <+
	construct-text-by-pp(pp) <+
	pp

construct-text-from-origin-desugared(pp):
	node -> <construct-text-from-origin(pp)> (origin-desugared-node, node)
	where 
		origin-desugared-node := <origin-term-desugared; topdown(try(strip-annos))> node
	//TODO: apply-resugaring here?
		//; <debug(!"          desugared: ")> origin-desugared-node
		//; <origin-term; debug(!"origin of desugared: ")> origin-desugared-node

construct-text-from-origin(pp):
	node -> <construct-text-from-origin(pp)> (origin-node, node)
	where
		origin-node := <origin-term> node
 
//list must be constructed with comments that preceed the first element or succeed the last element
//(otherwise insert-at-end gives problems)
construct-text-from-origin(pp):
	lst -> <construct-text-with-comments(pp|"")> (origin-lst, lst)
	where
		origin-lst := <find-origin-sublist> lst

construct-text-from-origin(pp):
	t@(origin-node, node) -> text
	where //guarantees that node can be formatted from the origin node, preventing non-termination
		<is-tuple> t; //debug(!"ast-changes?: ");
		<has-origin-term> origin-node;
		ast-changes := <collect-ast-changes> (origin-node, node); 
		<is-terminating-diff(|node)> ast-changes //prevent non termination
		//; debug(!"ast-changes!: ")
	with
		text-changes := <map(ast-change-to-text-change(pp))> ast-changes; //debug(!"txt-changes: ");
		text := <apply-text-changes>(text-changes, <origin-text> origin-node, <origin-start-offset> origin-node)

construct-text-by-pp(pp):
	node -> text
	where
		text := <
			all(alltd(construct-text-with-comments(pp|<DEFAULT-INDENT>))); 
			topdown(try(pp-default(pp))); //handle brackets
			pp
		> node

construct-text-with-comments(pp|default-indent) = 
	construct-text-with-comments-desugared(pp|default-indent) <+
	construct-text-with-comments-origin(pp|default-indent)

construct-text-with-comments-desugared(pp|default-indent):
	node -> <construct-text-with-comments(pp|default-indent)> (origin-desugared-node, node)
	where 
		origin-desugared-node := <origin-term-desugared; topdown(try(strip-annos))> node;
		<same-signature> (origin-desugared-node, node)

construct-text-with-comments-origin(pp|default-indent):
	node -> <construct-text-with-comments(pp|default-indent)> (origin-node, node)
	where
		origin-node := <origin-term <+ find-origin-sublist> node

//construct-text-with-comments(pp|default-indent): Parentetical(node) -> ...
// on this moment the parenthesis will be placed on the layouted text, 
// which is awful. It should be: {indent + comments before}{(}{node-text}{)}{comments after} 

construct-text-with-comments(pp|default-indent):
	t@(origin-node, node) -> node-text
	where 
		<is-tuple> t;
		<has-origin-term> origin-node
	with //termination check is not needed (we need to Replace to keep comments), since it is called on a subterm in construct-text-by-pp
		ast-changes := <collect-ast-changes> (origin-node, node); //debug(!"--ast-changes: ");
		text-changes := <map(ast-change-to-text-change(pp))> ast-changes; //debug(!"--txt-changes: ");
		full-text := <origin-text-with-layout> origin-node; 
		full-text-start-offset := <origin-layout-prefix-start-offset> origin-node; 
		modified-full-text := <apply-text-changes>(text-changes, full-text, full-text-start-offset);
		node-text := <replace-indentation(|default-indent, <origin-indent <+ !""> origin-node)> modified-full-text

signature constructors //signatures for AST changes
	DELETION      : OldList -> AST_CHANGE
	REPLACEMENT   : OldNode * NewNode -> AST_CHANGE //TODO: REPLACEMENT_IN_LIST, REPLACEMENT + bracket insertion for REPLACEMENT
	INSERT_BEFORE : OldNode * NewList -> AST_CHANGE
	INSERT_AT_END : OldNode * NewList -> AST_CHANGE

rules //ast-diff

collect-ast-changes = 
	where(is-tuple); 
	try(remove-superfluous-parentethical);
	(collect-ast-changes-eq <+
	collect-ast-changes-rec-node <+
	collect-ast-changes-rec-list <+
	collect-ast-changes-resugared <+
	collect-ast-changes-replace)

remove-superfluous-parentethical:
	(origin-node, Parenthetical(node)) -> (origin-node, node)
	where //apparently, parenthesis already in source
		<same-signature> (origin-node, node)

collect-ast-changes-eq:
	(origin-node, node) -> []
	where
		<equal> (origin-node, node)

collect-ast-changes-rec-node:
	(origin-node, node) -> ast-changes
	where
		<same-signature <+ ?([_],[_])> (origin-node, node);
		arg-tuples := <zip>(<get-arguments> origin-node, <get-arguments> node); 
		ast-changes := <map(collect-ast-changes); flatten-list> arg-tuples 
 
collect-ast-changes-rec-list:
	(origin-lst, lst) -> ast-changes
	where 
		<is-list> lst;
		<is-list> origin-lst;
		<not(violates-homomorphism-list)> (origin-lst, lst)
	where
		ast-changes := <
			list-diff(|origin-lst);
			filter(not(?INSERT_BEFORE(_, [])));
			filter(not(?INSERT_AT_END(_, [])))
		> (origin-lst, lst)

collect-ast-changes-resugared:
	(origin-node, node) -> ast-changes
	where
		ast-changes := <collect-ast-changes-rec-node> (origin-node, <origin-term> node)
	where
		<is-origin-term-desugared> node;
		<not(is-origin-term)> node

collect-ast-changes-replace:
	(origin-node, node) -> [REPLACEMENT(origin-node, node)]
	where
		<has-origin-term> origin-node;
		<not(is-list)> node //list-text can only be constructed in a context  

rules //validity

/*
//desugaring: changes must fall inside region of original text
//issue: is it correct if we simply filter context sensitive changes?
in-parent-context(|origin-parent):
	ast-change -> ast-change
	where 
		start-offset-node := <origin-deletion-start-offset> origin-parent; 
		end-offset-node := <origin-deletion-end-offset> origin-parent; 
		start-offset-change := <get-arguments; Hd; origin-start-offset> ast-change; 
		end-offset-change := <get-arguments; Hd; origin-end-offset> ast-change
	where 
		<leq> (start-offset-node, start-offset-change); 
		<leq> (end-offset-change, end-offset-node) 
*/
	
rules //list diff

list-diff(|origin-lst) = 
	(list-diff-fuzzy(|origin-lst) <+
	list-diff-origin-related(|origin-lst)) 
	
list-diff-fuzzy(|origin-lst):
	([origin-elem|origin-rest], [new-elem|new-rest]) -> ast-changes
	where
		<is-deletion(|new-rest)> origin-elem;
		<is-insertion(|origin-rest)> new-elem;
		<is-related-to-fuzzy(|origin-elem)> new-elem //fuzzy to prevent deletion + insertion
	with
		ast-changes := <flatten-list>[
			<collect-ast-changes>(origin-elem, new-elem)|
			<list-diff(|origin-lst)> (origin-rest, new-rest)
		]

list-diff-origin-related(|origin-lst): 
	(origin-elems, new-elems) -> ast-changes
	where 
		deleted-elems := <take-while(is-deletion(|new-elems))> origin-elems;  
		origin-rest := <drop-while(is-deletion(|new-elems))> origin-elems;
		<not(?[])> deleted-elems 
	with
		ast-changes := <flatten-list>[DELETION(deleted-elems)|<list-diff(|origin-lst)> (origin-rest, new-elems)]

list-diff-origin-related(|origin-lst):
	([origin-elem|origin-rest], new-elems) -> ast-changes
	where
		(inserted, elem, rest) := <split-fetch-keep(is-related-to(|origin-elem))> new-elems
	with
		ast-changes := <flatten-list>[
			INSERT_BEFORE(origin-elem, inserted), 
			<collect-ast-changes>(origin-elem, elem)|
			<list-diff(|origin-lst)> (origin-rest, rest)
		]

list-diff-origin-related(|origin-lst):
	([], new-elems) -> [INSERT_AT_END(origin-lst, new-elems)]


rules //helper rules text construction

find-origin-sublist:
	lst -> sublst
	where
		at-suffix(sublst := <origin-sublist-term; ?[_,_|_]>) <+
		sublst := <init; find-origin-sublist> lst

is-terminating-diff(|newnode):
	ast-changes -> ast-changes
	where
		<not(fetch(?REPLACEMENT(_, newnode)))> ast-changes 
		//lists are constructed from their elements, so non-termination is not a problem for insertion

rules //helper rules diff
	
same-signature:
	t@(trm1, trm2) -> (trm1, trm2)
	where(
		<is-tuple> t;
		<eq>(<get-constructor> trm1, <get-constructor> trm2);
		<eq>(<get-arguments; length> trm1, <get-arguments; length> trm2);
		<not(is-list)> trm1
	)

same-signature(|t1):
	t -> t
	where
		<same-signature> (t1,t)

violates-homomorphism-list =
	?([],[_,_|_]) <+ 
	?([_],[_,_|_]) <+
	(?([ortrm],[newtrm]); where(not(<is-related-to-fuzzy(|ortrm)> newtrm)))  //insertion constructs list with 2 elements from list with one element 

is-insertion(|origin-elems):
	new-elem -> new-elem
	where
		<?[or-elem|tail]> origin-elems;
		<not(is-related-to(|or-elem))> new-elem;
		<is-insertion(|tail)> new-elem

is-insertion(|origin-elems) =
	<?[]> origin-elems

is-deletion(|new-elems) = 
	?origin-elem;
	<not(fetch(is-related-to(|origin-elem)))> new-elems

is-related-to(|origin-node):
	node -> node
	where
		<equal> (origin-node, node) <+
		<equal> (<origin-term> origin-node, node) <+
		<equal>(<origin-term> origin-node, <origin-term> node)

is-related-to:
	(origin-node, node) -> (origin-node, node)
	where
		<is-related-to(|origin-node)> node

//related via child
is-related-to-fuzzy(|origin-node):
	node -> node
	where 
		<not(has-origin-term)> node;
		arg-tuples := <zip>(<get-arguments> origin-node, <get-arguments> node);
		<map(is-related-to <+ (Snd; not(has-origin-term)))> arg-tuples;
		<fetch(is-related-to)> arg-tuples