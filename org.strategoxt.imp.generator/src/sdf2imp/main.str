module sdf2imp/main

imports
  libstratego-lib
  libstratego-xtc
  libstratego-rtg

  libjava-front
  
  EditorService
  
  sdf2imp/options
  sdf2imp/project/-
  sdf2imp/services/-
  sdf2imp/util/-
  sdf2imp/lib/-

overlays

  tname_ASTNODE      = tname |[ org.strategoxt.imp.runtime.parser.ast.AstNode ]|
  tname_VISITOR      = tname |[ org.strategoxt.imp.runtime.parser.ast.AbstractVisitor ]|
  tname_OUTLINERBASE = tname |[ org.strategoxt.imp.runtime.services.OutlinerBase ]|
  tname_FOLDINGBASE  = tname |[ org.strategoxt.imp.runtime.services.FoldingBase ]|
  tname_ITOKEN       = tname |[ lpg.runtime.IToken ]|

strategies

  main-sdf2imp =
    option-wrap(
      sdf2imp-options
    , 
      sdf2imp
    <+
      prim("SSL_stacktrace_get_all_frame_names") => trace;       
      report-failure // proper stack traces
    )
  
  sdf2imp-jvm:
    esv -> <packed-descriptor-file-name>
    with
      file-exists
    ; not(<get-config> SdfMainModuleFlag()) // (should be read from the file)
    where
      rules(
        InputFile := esv
        IsLaunchedFromEclipse: _ 
      );
      <sdf2imp> FILE(esv)
  
  // FIXME: dirty hack for getting the .def file
  //        (should do this based on the esv contents instead...)
  find-def-file =
    remove-extension;
    rules(
      MainDescriptorName   := <base-filename>
      DescriptorNamePrefix := <base-filename; remove-extension>
    );
    with(<chdir> <dirname>; <chdir> "..");
    guarantee-extension(|"def"); // remove .main.esv
    base-filename;
    (file-exists <+ <conc-strings> ("include/", <id>));
    if not(file-exists) then
      fatal-err(|"Accompanying .def file not found.")
    end;
    verbose-msg(!"Found accompanying .def file: ", id)

strategies

  sdf2imp =
    with(
      <set-verbosity> 2
    );
    if InputFile then
      !FILE(<InputFile>);
      if FILE(has-extension(|"esv") => esv) then
        <find-def-file> esv;
        rules(InputFile := <id>);
        !FILE(<id>)
      end;
      ?input
    else
      require-option(
        <get-config> SdfMainModuleFlag()
      | "Main module (-m)"
      );
      if not(StartSymbol) then
        rules(StartSymbol := "Start")
      end;
      create-grammar;
      create-trans;
      input := <pack-sdf> FILE(<conc-strings> ("syntax/", <get-sdf-main-module>, ".sdf"))
    end;
  
    configure-main-descriptor;
    <sdf2rtg> input;
    
    if not(IsLaunchedFromEclipse) then
      // We could build the table here, but doing it from ant is more customizable
      // (also, this way we don't expose our xtc underbelly)
      <copy-or-create-parse-table> input
    end;
  
    if NoExistingDescriptor then
      create-main-descriptor
    end;
    
    create-syntax-descriptor;
    create-folding-descriptor;
    create-outliner-descriptor;
    create-colorer-descriptor;
    create-analysis-descriptor;
    create-occurrences-descriptor;
    create-references-descriptor;

    create-packed-descriptor-file;
    
    create-parse-controller;
    create-build-properties;
    create-project-file;
    create-activator;
    create-classpath;
    create-manifest;
    create-plugin-xml;
    create-build-xml;
    create-builder-xml;
    create-example-file;
    copy-jars;
    copy-def-file;
    
    say(!"SUCCESS: completed with 0 fatal errors.")
  
  // TODO: XTC detox -_-;;
  sdf2rtg:
    FILE(sdf) -> rtg
    with
      verbose-msg(!"Analyzing grammar...");
      if FILE(has-extension(|"sdf")) then
        fatal-err(|"Input file must be a .def file.")
      end;
      xtc-transform(!"sdf2table", !["-n", "-m", <get-sdf-main-module> | <pass-v-verbose>]);
      xtc-transform(!"implodePT");
      read-from;
      sdf-desugar;
      core-sdf-grammar2rtg => rtg;
      ?RTG(_, ProdRules(<id>));
      register-rtg

  pack-sdf:
    FILE(sdf) -> FILE(def)
    with
      def := <conc-strings> ("include/", <get-sdf-main-module>, ".def");
      <file-exists <+ mkdir> "include";
      <xtc-command(!"pack-sdf")> ["-i", sdf, "-o", def | <pass-verbose>]
