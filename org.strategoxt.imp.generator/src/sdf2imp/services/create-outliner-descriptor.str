module sdf2imp/services/create-outliner-descriptor

imports
  libstratego-lib
  
  sdf2imp/util/-
  sdf2imp/services/common
  sdf2imp/services/ast-form-heuristic

strategies

  create-outliner-descriptor =
  	sdf-name := <get-sdf-main-module>;
    if not(<conc-strings; file-exists> ("editor/", sdf-name, "-Outliner.str")) then
      <output-text-file(|["editor"], $[[sdf-name]-Outliner.str])>

${module editor/{sdf-name}-Outliner

imports
  include/{sdf-name}
  lib/runtime/editor/outline-library
  editor/{sdf-name}-Outliner.generated
}

    end;
    rtg-prods := <heuristic-outliner-productions>;
    outline-rules := <collect-om(rtg-prod-to-outline-rule(|"to-outline-label"), conc)> rtg-prods;
    <output-text-file(|["editor"], $[[sdf-name]-Outliner.generated.str])>
      
${module editor/{sdf-name}-Outliner

imports
  include/{sdf-name}
  lib/runtime/editor/outline-library
  editor/{sdf-name}-Outliner.generated

rules

  outline-strategy = simple-label-outline(to-outline-label)
  outline-expand-to-level = !3
  
  {<separate-by(|"\n"); map(write-to-string)> outline-rules}
}
  
  heuristic-outliner-productions =
    StartSymbol;
    
    heuristic-collect-all-rtg({
      not(is-list-production);
      
      where(
        heuristic-child-sorts;
        one(heuristic-sort-is-identifier => reason1);      
        one(heuristic-sort-is-unvisited-list => reason2)
      );
      
      if-verbose3(
        verbose-msg(!"Outliner match:", heuristic-asfix-sort-name, constructor-name);
        verbose-msg(!"  because:     ", !reason1);
        verbose-msg(!"  and:         ", !reason2)
      )
    })
  
  rtg-prod-to-outline-rule(|sname): ProdRule(
        _
      , [ Appl(
            Term(Plain(cons))
          , symbols
          )
        ]
      ) -> result
      where
        c@Ref(Nonterm(Plain(sort))) := <fetch-elem(is-outline-label-candidate)> symbols;
        index := <get-index> (c, symbols);
        pattern-before := <copy> (<dec> index, "_");
        pattern-after := <copy> (<subt> (<length> symbols, index), "_");
        pattern := <flatten-list; separate-by(!", ")> [pattern-before, "label", pattern-after];
        result := <flatten-list; concat-strings> [sname, ": ", cons, "(", pattern, ") -> label"]

  is-outline-label-candidate:
    r@Ref(Nonterm(Plain(sort))) -> r
      where not ( <string-starts-with(|"List") + string-starts-with(|"Opt")> sort )