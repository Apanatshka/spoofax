module sdf2imp/services/create-outliner-descriptor

imports
  libstratego-lib
  
  sdf2imp/util/-
  sdf2imp/services/common
  sdf2imp/services/ast-form-heuristic

strategies

  create-outliner-descriptor =
  	sdf-name := <get-sdf-main-module>;
    if not(<conc-strings; file-exists> ("editor/", sdf-name, "-Outliner.str")) then
      <output-text-file(|["editor"], $[[sdf-name]-Outliner.str])>

${module editor/{sdf-name}-Outliner

imports
  include/{sdf-name}
  lib/runtime/editor/outline-library
  editor/{sdf-name}-Outliner.generated
}

    end;
    rtg-prods := <heuristic-outliner-productions; debug>;
    label-strategy := "to-outline-label";
    if ([] := rtg-prods)
    then outline-rules := [<conc-strings> (label-strategy, " = fail")]
    else outline-rules := <map(rtg-prod-to-outline-rule(|label-strategy))> rtg-prods
    end;
    <output-text-file(|["editor"], $[[sdf-name]-Outliner.generated.str])>
      
${module editor/{sdf-name}-Outliner.generated

imports
  include/{sdf-name}
  lib/runtime/editor/outline-library
  editor/{sdf-name}-Outliner.generated

rules

  outline-strategy = simple-label-outline(to-outline-label)
  outline-expand-to-level = !3
  
  {<separate-by(|"\n"); concat-strings> outline-rules}
}
    
    ;output-initial-descriptor-file(
      <descriptor-name> "-Outliner"
    , !|[
        module <descriptor-name> "-Outliner"
        
        imports <descriptor-name> "-Outliner.generated"
        
        outliner
          ~
          ~// This file can be used for custom outliner rules.
          ~//
          ~// See the imported file for a brief introduction and examples.
      ]|
    );
    
    create-derived-outliner-descriptor
  
  create-derived-outliner-descriptor =
    not(is-heuristic-services-needed);
    verbose-msg(!"Skipping", <descriptor-name> "-Outliner.generated")
  <+
    output-derived-descriptor-file(
      <descriptor-name> "-Outliner.generated"
    , 
      heuristic-outliner-productions;
      map(create-folding-or-outliner-rule);
      !|[
        module <descriptor-name> "-Outliner.generated"
        
        outliner Default outliner        
          ~
          ~// Outliner rules indicate which syntactic constructs should be shown in the outline
          ~// and quick outline views, and take one of the following forms:
          ~//
          ~//   <sort>.<constructor>
          ~//
          ~//   <sort>._
          ~//
          ~//   _.<constructor>
          ~
          ~*<id>
      ]|
    )
  
  heuristic-outliner-productions =
    StartSymbol;
    
    heuristic-collect-all-rtg({
      not(is-list-production);
      
      where(
        heuristic-child-sorts;
        one(heuristic-sort-is-identifier => reason1);      
        one(heuristic-sort-is-unvisited-list => reason2)
      );
      
      if-verbose3(
        verbose-msg(!"Outliner match:", heuristic-asfix-sort-name, constructor-name);
        verbose-msg(!"  because:     ", !reason1);
        verbose-msg(!"  and:         ", !reason2)
      )
    })
  
  rtg-prod-to-outline-rule(|sname): 
    ProdRule(_, [ Appl(cons, symbols)]) -> result
      where
        label := <fetch-elem(is-outline-label-candidate)> symbols;
        index := <get-index> (label, symbols);
        pattern-before := <copy> (<dec> index, "_");
        pattern-after := <copy> (<subt> (<length> symbols, index), "_");
        pattern := <flatten-list; separate-by(!", ")> [pattern-before, "label", pattern-after];
        result := <flatten-list; concat-strings> [sname, ": ", <collect-one(is-string)> cons, "(", pattern, ") -> label"]

  rtg-prod-to-outline-rule(|sname):
    ProdRule(_, [ Appl(cons, symbols)]) -> result
      where
        not( <fetch-elem(is-outline-label-candidate)> symbols );
        pattern := <separate-by(!", ")> <copy> (<length> symbols, "_");
        result := <flatten-list; concat-strings> [sname, " = ?", <collect-one(is-string)> cons, "(", pattern, "); origin-text-at-start"]

  is-outline-label-candidate = ?s; collect-one(is-string); where(not(string-starts-with(|"List") + string-starts-with(|"Opt"))); !s
