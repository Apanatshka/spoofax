module sdf2imp/services/create-references-descriptor

imports
  libstratego-lib
  libstratego-sdf
  
  sdf2imp/util/-
  sdf2imp/main

signature constructors

  lit  : Term -> Term
  prod : Term * Term * Term -> Term

strategies

  create-references-descriptor =
    output-initial-descriptor-file(
      <descriptor-name> "-References"
    , !|[
        module <descriptor-name> "-References"
        
        imports <descriptor-name> "-References.generated"
        
        references
          ~~
          ~~// This file can be used for custom reference resolving,
          ~~// hover help, occurrence highlighting rules.
          ~~// See the imported file for a brief introduction and examples.
          ~~
        references
          ~~
          completion proposer: editor-complete
          completion lexical: [A-Za-z0-9_]+
          completion trigger: ":"
          ~~
          reference _ : editor-resolve
          hover     _ : editor-hover
      ]|
    );
    create-derived-references-descriptor
    
  create-derived-references-descriptor =
    not(is-heuristic-services-needed);
    verbose-msg(!"Skipping", <descriptor-name> "-References.generated")
  <+
    output-derived-descriptor-file(
      <descriptor-name> "-References.generated"
    ,
      completion-rules := <collect-all-keywords; map(keyword-to-completion-rule)>;
      !|[
        module <descriptor-name> "-References.generated"
        
        references
          ~
          ~// Building and analysis is defined in Stratego program or programs:
          ~//
          ~//   provider : stratego-program.ctree
          ~//   provider : stratego-library.jar
          ~
          ~// Reference resolving rules can specify the syntax constructors for which
          ~// a reference resolving function is available:
          ~//
          ~//   reference FunctionCall : resolve-function-call 
          ~//
          ~// This defines that for each FunctionCall, resolve-function-call
          ~// will retrieve the AST node that declares it.
          ~
          ~// Likewise, hover help and occurrence highlighting functionality and can be
          ~// specified as follows: (note: occurrence highlighting is not implemented at this time)
          ~//
          ~//   hover      FunctionCall : hover-help-function-call
          ~//   occurrence _            : find-occurrences
          ~
          ~// Content completion can be defined using the following declarations:
          ~//
          ~//   completion proposer : completion-function-call  
          ~//   completion lexical  : [A-Za-z0-9_]+
          ~//   completion trigger  : "\."
          ~//   completion keyword  : "keyword"
          ~//
          ~// This sets completion-function-call as the completion strategy,
          ~// and declares that [A-Za-z0-9_]+ may be used as a lexical pattern
          ~// to parse identifiers (used when the input file has syntax errors).
          ~// The completion trigger uses a regular expression to specify that  
          ~// completions should be proposed as the user types ".".
          ~// Finally, the above also defines a completion for the keyword "keyword."
          ~
          ~~// All semantic services may make use of the
          ~~// dynamic rules created by the observer.

        references

          ~
          ~*completion-rules
      ]|
    )

  keyword-to-completion-rule:
    keyword -> |[ completion keyword : ~String(keyword) ]|

  collect-all-keywords =
    (InputFile <+ DefaultDefFile);
    parse-sdf-definition-file;
    collect-all(?prod(<pattern-to-keywords>, _, _));
    concat;
    make-set

  pattern-to-keywords =
    pattern-to-keywords-1 <+ pattern-to-keywords-2 <+ []

  pattern-to-keywords-1:
    [lit(lit) | p*] -> [keyword | <pattern-to-keywords> p'*]
    where
      <is-proper-keyword> lit
    with
      keyword-suffix := <take-while(lit(is-proper-keyword))> p*; 
      keyword        := <map(?lit(<id>)); separate-by(|" "); concat-strings> [lit(lit) | keyword-suffix];
      p'*            := <drop-while(?lit(_))> p*

  pattern-to-keywords-2:
    [_ | p*] -> <pattern-to-keywords> p*

  is-proper-keyword =
    explode-string; one(is-alpha); not("")
